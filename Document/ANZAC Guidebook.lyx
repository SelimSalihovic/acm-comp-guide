#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{pdflscape}
\usepackage{datetime}
\newdateformat{shortdatem}{%
\twodigit{\THEDAY}-\shortmonthname--\THEYEAR}
\shortdatem
\usepackage[bottom]{footmisc}
\lhead{ANZAC Competition Guide}
\rhead{}
\lfoot{}
\rfoot{\small\today}
\renewcommand{\footrulewidth}{0.4pt}
\usepackage{tocloft}
\renewcommand\cftsecleader{\bfseries\cftdotfill\cftdotsep}
\renewcommand\cftsecfont{\normalfont}
\renewcommand\cftsecpagefont{\normalfont}
\renewcommand{\cftsecleader}{\cftdotfill{\cftsecdotsep}}
\renewcommand\cftsecdotsep{\cftdot}
\renewcommand\cftsubsecdotsep{\cftdot}
\renewcommand\cftsecdotsep{\cftdot}
\renewcommand\cftsubsubsecdotsep{\cftdot}
\renewcommand\cftparadotsep{\cftdot}
\sloppy
\tiny
\usepackage{colortbl}
\definecolor{lightgray}{gray}{0.95}
\definecolor{dkgray}{gray}{0.7}
\renewcommand*\arraystretch{1.5}
\exhyphenpenalty=10000
\hyphenpenalty=10000
\usepackage{xcolor}
\usepackage{algpseudocode}
\renewcommand{\ps@plain}{\pagestyle{fancy}}
\algrenewcommand\algorithmicrequire{\textbf{Input}}
\algrenewcommand\algorithmicensure{\textbf{Output}}
\end_preamble
\use_default_options false
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman charter
\font_sans default
\font_typewriter lmtt
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 80

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref false
\pdf_title "ANZAC Guidebook"
\pdf_author "Darran Kartaschew"
\pdf_keywords "ACM-ICPC, ANZAC"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 0
\use_mhchem 0
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 4
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\listings_params "basicstyle={\small,\ttfamily},frame=single,language=Java"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Guide for Advanced Algorithms for Australia and New Zealand Algorithmics
 & Computing League Competition.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename images/by-sa.eps

\end_inset


\end_layout

\begin_layout Standard
This work is licensed under the Creative Commons Attribution-ShareAlike
 3.0 Australia License.
 To view a copy of this license, visit 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://creativecommons.org/licenses/by-sa/3.0/au/
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Prepared By: Darran Kartaschew
\end_layout

\begin_layout Standard
Document Version: 1.0
\end_layout

\begin_layout Standard
Last Updated on: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
About the Competition
\end_layout

\begin_layout Standard
The programming contests held in Universities across Australia and New Zealand,
 are part of the Australia and New Zealand Algorithmics & Computing League
 Competition and is used in conjunction with the ACM-ICPC competition.
 These competitions are aimed at challenging students in completing a set
 number of problems within the allocated time slot (typically 5 hours),
 with the winners in each location given some prestige.
\end_layout

\begin_layout Standard
In recent years teams from not only Universities taken part, but teams from
 TAFE and other educational institutions have taken part in the competition.
 Additionally teams outside of Australia and New Zealand such as those from
 the Phillipines have also taken part.
\end_layout

\begin_layout Subsubsection
ANZAC 2012
\end_layout

\begin_layout Standard
The ANZAC 2012 competition takes place in 5 to 6 rounds each year and are
 sponsored by a local University and associated Faculty member.
 Typically, a single round will run for 5 hours (starting at midday for
 East Coast Australia), and at least 6 problems will be presented for completion
 by students.
\end_layout

\begin_layout Standard
All challenges require some form of problem solving skills or techniques
 and do require at least a basic understanding of different algorithms in
 order to complete the challenges, let alone to be competitive in the competitio
n.
\end_layout

\begin_layout Standard
In order to compete within the competition it is recommended that 3 students
 form a team to work together on solving the challenges.
 Each team is only given 1 computer to work on, and all reference material
 brought into the competion must be in printed form only
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The printed material requirement is to ensure that no copying of existing
 source code is allowed, only transcription of source code from written
 form
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Scores are awarded for completed challenges (typically 1 point), and the
 time elasped from the start of the competition to accepted submission of
 the challenge is also noted.
 If a submitted challenge fails, then a 20 minute time penalty to added
 to the teams total time value.
\end_layout

\begin_layout Standard
As a minimum each contest will allow either C/C++ and Java, however additional
 programming languages may also be included.
 Typically C# has been allowed in recent years, due to the popularity of
 the language, especially as it is taught farily early in a students undergradua
te degree.
\end_layout

\begin_layout Standard
Overall, the competition is designed to be challenging, fun and also students
 to advance within their field of study.
 It is also a great way to network amongst other equally capable students
 within the programming field.
\end_layout

\begin_layout Subsubsection
ACM-ICPC
\end_layout

\begin_layout Standard
The ACM-ICPC competition is an International level competition sponsored
 by IBM, ACM and Upsilon Pi Epsilon, and contestants who make the world
 finals are often sort after by industry for later employment, as well as
 bringing notoriety and prestige to the University or College to which the
 constestants originate from.
 The regional component of the competition is typically held as the last
 ANZAC competition, as both competitions share the same tools, resources
 and rules.
\end_layout

\begin_layout Standard
The top two teams from each region (and in the case of Australia and New
 Zealand, the top team from Australia and top team from New Zealand), attend
 the International competition held annually in late March/early April in
 an overseas location.
 The 2012 ACM-ICPC Finals consisting of teams from all over the world was
 held in Warsow, Poland.
\end_layout

\begin_layout Subsection
About this Guide
\end_layout

\begin_layout Standard
This guide is designed to give students some background knowledge of the
 environments utilised within the competition, as well as information on
 various algorithms needed to solve problems.
 The included algorithms are by no means exhaustive, however represent the
 bulk of the algorithms that will be useful in completion of challenges.
\end_layout

\begin_layout Standard
This guide book is split into multiple parts:
\end_layout

\begin_layout Enumerate
Basic Source Templates that cover the basic frameworks needed for challenge
 submissions.
\end_layout

\begin_layout Enumerate
Basic Algorithms and techniques.
\end_layout

\begin_layout Enumerate
Advanced Algorithms.
\end_layout

\begin_layout Standard
All algorithms described will include:
\end_layout

\begin_layout Enumerate
A short statement on the algorithm and the intended uses, as well as other
 possible uses.
\end_layout

\begin_layout Enumerate
The pseudocode for the algorithm.
\end_layout

\begin_layout Enumerate
An actual implementation in at least 1 programming language.
 This will typically be in the form of a function or method call.
\end_layout

\begin_layout Enumerate
An example challenge that requires the use of the algorithm.
\end_layout

\begin_layout Enumerate
An example solution to the challenge.
\end_layout

\begin_layout Standard
Throughout the guide there will be notes on performance aspects of each
 algorithm, as well as helpful utility functions to make better use of the
 algorithm implementations.
 One example will be a function to convert an Adjancy List into an Adjancy
 Matrix used for different graph based algorithms.
\end_layout

\begin_layout Subsubsection
Development System
\end_layout

\begin_layout Standard
The applications and source code snippets developed for this guide were
 performed on the following hardware and software combinations as noted
 below.
 Any performance measurements, in particular times required for certain
 functions reflect times as acquired with listed hardware and software combinati
ons.
 Performance measurements will vary accordingly with different hardware
 and software combinations when performing your own performance measurements.
\end_layout

\begin_layout Paragraph
Hardware
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
HP xw4600 Workstation, with:
\end_layout

\begin_layout Itemize
Intel Core 2 Quad, Q9400 @ 2.66GHz (Quad core, 2.66GHz, 6MB L2 cache, 64bit
 enabled).
\end_layout

\begin_layout Itemize
4GB RAM (4 × 1GB Reg ECC DDR2-800Mhz)
\end_layout

\begin_layout Itemize
250GB 7200rpm HDD
\end_layout

\begin_layout Itemize
nVidia Quadro FX580 graphics card.
\end_layout

\begin_layout Itemize
Dual 20
\begin_inset Quotes erd
\end_inset

 LCD Monitors (1680x1050 resolution).
\end_layout

\begin_layout Paragraph
Software
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Oracle Solaris 11 11/11, with:
\end_layout

\begin_layout Itemize
Solaris Studio 12.3 (C++)
\end_layout

\begin_layout Itemize
Netbeans 7.2 (Java)
\end_layout

\begin_layout Itemize
Java 6 JDK 1.6u26 or Java 7 JDK 1.7u5
\end_layout

\begin_layout Itemize
gcc 4.5.2 (C++)
\end_layout

\begin_layout Standard
Microsoft Windows XP x64, with:
\end_layout

\begin_layout Itemize
Mircosoft Visual Studio 2010 (C# and C++)
\end_layout

\begin_layout Itemize
.NET Frameowrk 2.0
\end_layout

\begin_layout Subsection
License
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename images/by-sa.eps

\end_inset


\end_layout

\begin_layout Standard
This work is licensed under the Creative Commons Attribution-ShareAlike
 3.0 Australia License.
 To view a copy of this license, visit 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://creativecommons.org/licenses/by-sa/3.0/au/
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
This means you are free:
\end_layout

\begin_layout Itemize
to copy, distribute, display, and perform the work 
\end_layout

\begin_layout Itemize
to make derivative works 
\end_layout

\begin_layout Itemize
to make commercial use of the work 
\end_layout

\begin_layout Standard
Under the following conditions:
\end_layout

\begin_layout Itemize

\series bold
Attribution
\series default
 — You must give the original author credit.
\end_layout

\begin_layout Itemize

\series bold
Share Alike
\series default
 — If you alter, transform, or build upon this work, you may distribute
 the resulting work only under a licence identical to this one.
 
\end_layout

\begin_layout Standard
With the understanding that:
\end_layout

\begin_layout Itemize

\series bold
Waiver
\series default
 — Any of the above conditions can be waived if you get permission from
 the copyright holder.
 
\end_layout

\begin_layout Itemize

\series bold
Public Domain
\series default
 — Where the work or any of its elements is in the public domain under applicabl
e law, that status is in no way affected by the license.
 
\end_layout

\begin_layout Itemize

\series bold
Other Rights
\series default
 — In no way are any of the following rights affected by the license: 
\end_layout

\begin_deeper
\begin_layout Itemize
Your fair dealing or fair use rights, or other applicable copyright exceptions
 and limitations; 
\end_layout

\begin_layout Itemize
The author's moral rights; 
\end_layout

\begin_layout Itemize
Rights other persons may have either in the work itself or in how the work
 is used, such as publicity or privacy rights.
 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Notice
\series default
 — For any reuse or distribution, you must make clear to others the licence
 terms of this work.
 
\end_layout

\begin_layout Standard
Original Author endorsed waivers:
\end_layout

\begin_layout Itemize
The original author however allows use of source code snippets, that is,
 source code written in the languages of C++, C# or Java contained with
 this guide for any purpose, without attribution.
 This waiver does not extend to the text, nor other materials contained
 within the guide.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Supported Competition Environments
\end_layout

\begin_layout Standard
The guide will focus on Java being developed in Eclipse, and C# being developed
 in Visual Studio.
 However there will be examples in C++ when appropriate.
 Most other IDEs have similar options, when used for development, debugging
 and/or profiling.
\end_layout

\begin_layout Subsection
PC^2
\end_layout

\begin_layout Standard
The primary tool that allow students to submit their challenge entries to
 be judged in the PC^2 Software Suite.
 The application itself is developed by California State University, Sacramento
 for the purposes of programming competitions and has been adopted by both
 the Australia and New Zealand Algorithmics & Computing League (ANZACL)
 and ACM for their respective competitions.
\end_layout

\begin_layout Standard
An example of the Login Interface is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PC^2-Login-Screen"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Screenshot-PC^2 Login.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
PC^2 Login Screen
\begin_inset CommandInset label
LatexCommand label
name "fig:PC^2-Login-Screen"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once logged into the system, the following options are typically available:
\end_layout

\begin_layout Description
Submit
\begin_inset space ~
\end_inset

Run Allows you to submit a challenge entry to be judged, or alternatively
 to test your entry against some supplied sample data.
\end_layout

\begin_layout Description
View
\begin_inset space ~
\end_inset

Runs Allows you to view a history of submissions made to the judges.
\end_layout

\begin_layout Description
Request
\begin_inset space ~
\end_inset

Clarification Allows you to request a clarification from the judges about
 one of the challenges.
\end_layout

\begin_layout Description
View
\begin_inset space ~
\end_inset

Clarifications Allows you to see the responses to your requests for clarificatio
ns.
\end_layout

\begin_layout Description
Options Allows you to access various options that control the clients operation.
 However this tab, only allows you to view the operational log of the client.
\end_layout

\begin_layout Standard
Most of the operations on the various areas are self explanatory, so won't
 be covered in detail.
 The main screen that competitors will utilise is the 
\series bold
Submit Run
\series default
 tab as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PC^2-Client-Submit"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Screenshot-PC^2 Team TEAM 3 (Site 1) [STARTED] Build 2136.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
PC^2 Client Submit Run Tab
\begin_inset CommandInset label
LatexCommand label
name "fig:PC^2-Client-Submit"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This screen has two main modes of operation, allow a competitor to test
 their submission against some sample input, or submit their source code
 to be judged.
 Both have similar operations, except the test has one additional step.
\end_layout

\begin_layout Subsubsection
Submit Run
\end_layout

\begin_layout Standard
To submit a run for judging, perform the following steps:
\end_layout

\begin_layout Enumerate
From the Problem dropdown list select the challenge that you are attempting.
\end_layout

\begin_layout Enumerate
From the Language dropdown list select the programming language in the submissio
n is written in.
\end_layout

\begin_layout Enumerate
Use the Select button to select the source code file for the submission.
 (Note: A single Source Code file is required, do not attempt to submit
 data files or executable files).
\end_layout

\begin_layout Enumerate
Use the Add Button to select any additional files needed to complete your
 submission.
 (Note: This is rarely needed).
\end_layout

\begin_layout Enumerate
Click on Submit, and Yes to confirm to have your submission judged.
\end_layout

\begin_layout Enumerate
You will receive a confirmation dialog confirming that your entry has been
 submitted.
\end_layout

\begin_layout Standard
Once you entry has been judged you will receive one of the following confirmatio
ns:
\end_layout

\begin_layout Itemize
Yes - Your submission was successful in passing all tests.
 Congratulations, you have been awarded one point.
\end_layout

\begin_layout Itemize
No - Your submission failed one or more tests.
\end_layout

\begin_layout Itemize
Time Overrun - Your submission took more time that allowed for the challenge.
\end_layout

\begin_layout Standard
An example Judge's Response Dialog is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Sample-Judge's-Response"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Screenshot-Run Judgement Received.png
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sample Judge's Response
\begin_inset CommandInset label
LatexCommand label
name "fig:Sample-Judge's-Response"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Submit Test
\end_layout

\begin_layout Standard
Before your submit your solution to be judged it is 
\series bold
highly recommended
\series default
 that you perform a test run on your submission first, due to possible differenc
es between the environment you utilised for development and the environment
 in which your submission will be run on the judges machine.
\end_layout

\begin_layout Standard
To test your submission first, perform the following steps:
\end_layout

\begin_layout Enumerate
Ensure that your source code file and the sample data files are in the same
 folder/directory on your system.
\end_layout

\begin_layout Enumerate
From the Problem dropdown list select the challenge that you are attempting.
\end_layout

\begin_layout Enumerate
From the Language dropdown list select the programming language in the submissio
n is written in.
\end_layout

\begin_layout Enumerate
Use the Select button to select the source code file for the submission.
 (Note: A single Source Code file is required, do not attempt to submit
 data files or executable files).
\end_layout

\begin_layout Enumerate
Use the Add Button to select any additional files needed to complete your
 submission.
 (Note: This is rarely needed).
\end_layout

\begin_layout Enumerate
Click on 
\begin_inset Quotes eld
\end_inset

Test
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Enumerate
Select the appropriate sample input file in the open dialog box.
 (Typically the sample input fille will be 
\family typewriter
<challengename>_sample_in.txt
\family default
 ).
\end_layout

\begin_layout Enumerate
Wait for the output dialog and compare to the expected output.
\end_layout

\begin_layout Enumerate
If you are happy with your submission, then submit your solution for judging,
 by clicking on 
\begin_inset Quotes eld
\end_inset

Submit
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Software Languages
\end_layout

\begin_layout Standard
Currently the competition support the following software development languages
 with some variations between regional areas: Java, C++ and C#.
\end_layout

\begin_layout Subsubsection
Java
\end_layout

\begin_layout Standard
Java is compiled utilising the Oracle Java 6SE JRE implementation, however
 future competitions may migrate to Java 7SE as Java 7 becomes more popular.
 (This guide will target the Oracle Java 6 SE JRE).
\end_layout

\begin_layout Standard
By default the competition will utilise the 32bit JRE, however this may
 vary as needed between each region.
 Additionally the Java compiler and JVM are run using default settings only.
 
\end_layout

\begin_layout Subsubsection
C++
\end_layout

\begin_layout Standard
C++ (and by extension C) is compiled with an POSIX compatible compiler,
 typically being mingw on Windows.
 mingw utilises the GNU GCC compiler suite, and offers a near complete POSIX
 environment including the C++ STL.
\end_layout

\begin_layout Standard
It should be noted, that in some instances the Microsoft Visual Studio C++
 compiler has been used within the competition, so it is best to check with
 the local staff supporting the competition which compiler will be utilised.
 
\end_layout

\begin_layout Standard
Irrespective of the C++ compiler and/or environment, it should be noted
 that the default compiler settings are utilised through the competition,
 so features including optimisation flags or 64bit operation are not enabled.
\end_layout

\begin_layout Standard
This guide will target a 100% pure POSIX environment.
 
\end_layout

\begin_layout Subsubsection
C#
\end_layout

\begin_layout Standard
C# will typically be compiled by Microsoft Visual Studio 2010 with the .NET
 2.0 Framework.
 However there may be variations to this, so it is best to check with the
 local staff supporting the competition which compiler and/or .NET framework
 will be utilised.
\end_layout

\begin_layout Subsection
IDEs
\end_layout

\begin_layout Standard
At the moment there are no official supported IDEs utilised by the competition,
 however the majority of contestants utilise either Eclipse and/or Visual
 Studio.
 
\end_layout

\begin_layout Standard
Other IDEs or Editors commonly utilised by competitors include NetBeans
 (Java, C++), Code::Blocks (C++) and Notepad++ (Java, C#, C++).
\end_layout

\begin_layout Subsubsection
Eclipse
\end_layout

\begin_layout Standard
Eclipse may be utilised to develop either Java applications or C++ applications
 (on provision the appropriate eclipse plugins for C++ are installed, and
 a compatible C++ compiler such as mingw is also installed).
\end_layout

\begin_layout Standard
There is no special configuration for Eclipse to be utilised within the
 competition.
 As all competition entries operate within a command line only interface
 there is no requirement for any GUI builder plugins to be present.
\end_layout

\begin_layout Standard
To utilise Eclipse for Java development, perform the following steps:
\end_layout

\begin_layout Enumerate
Start Eclipse, and switch to a Workspace that is empty, or has been designated
 for use for competition.
 (Use 
\family typewriter
File
\family default
 -> 
\family typewriter
Switch Workspace 
\family default
to move).
\end_layout

\begin_layout Enumerate
In the 
\family typewriter
File
\family default
 menu, select 
\family typewriter
New
\family default
.
\end_layout

\begin_layout Enumerate
In the 
\family typewriter
New
\family default
 dialog box, select 
\family typewriter
Java Project
\family default
.
 Click on 
\family typewriter
Next
\family default
.
\end_layout

\begin_layout Enumerate
Enter any name for the project name.
 Leave all other settings as default.
\end_layout

\begin_layout Enumerate
Click on 
\family typewriter
Finish
\family default
.
 This will create a basic project that can be used for developing submissions.
\end_layout

\begin_layout Enumerate
In the Package Explorer pane, right click on the 
\family typewriter
'src'
\family default
 package, and select 
\family typewriter
New
\family default
 -> 
\family typewriter
Java Class
\family default
.
 This will be the first submission that you will work on.
 When developing further submissions, simple start at this point and following
 the remaining steps.
\end_layout

\begin_layout Enumerate
The in 
\family typewriter
New Java Class
\family default
 dialog, enter in the challenge name in the
\family typewriter
 Name:
\family default
 field, and click on 
\begin_inset Quotes eld
\end_inset


\family typewriter
public static void main(String[] args)
\family default

\begin_inset Quotes erd
\end_inset

 to select this option.
 Leave all other options as default, and click on 
\family typewriter
Finish
\family default
.
 (See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Eclipse---New-1"

\end_inset

).
\end_layout

\begin_layout Enumerate
The new submission Java file will open in the file pane.
 (See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Eclipse---New-1"

\end_inset

)
\end_layout

\begin_layout Enumerate
You are now reading to develop you submission.
\end_layout

\begin_layout Standard
All debugging facilities may be utilised within Eclipse with no restrictions.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Eclipse1.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Eclipse - New Java Class
\begin_inset CommandInset label
LatexCommand label
name "fig:Eclipse---New"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Eclipse2.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Eclipse - New Java Application
\begin_inset CommandInset label
LatexCommand label
name "fig:Eclipse---New-1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
One item to note with the file structure of Eclipse and essentially all
 Java application development, you will need to note the exact location
 of the source files so are able to find them later in order to submit your
 solutions.
 
\end_layout

\begin_layout Standard
Using the example in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Eclipse---New"

\end_inset

, note the 
\begin_inset Quotes eld
\end_inset


\family typewriter
Source Folder
\family default

\begin_inset Quotes erd
\end_inset

 location, this is the location that your submissions will be located in,
 in this case 
\family typewriter
ACM/src/AddingNumbers.java
\family default
.
\end_layout

\begin_layout Standard
When testing your submission with PC^2 you will be required to either:
\end_layout

\begin_layout Enumerate
Copy your source code file to the same location as sample input files, or
\end_layout

\begin_layout Enumerate
Copy the sample input files into the same location as the source code file.
\end_layout

\begin_layout Subsubsection
Visual Studio
\end_layout

\begin_layout Standard
Visual Studio is capable of working with a number of programming languages,
 including C# and C++.
 This guide will cover working with both langauges, noting the differences
 between the two.
\end_layout

\begin_layout Paragraph
C#
\end_layout

\begin_layout Standard
There is no special configuration for Visual Studio to be utilised within
 the competition.
 As all competition entries operate within a command line only interface
 there is no requirement for any GUI builder plugins to be present.
\end_layout

\begin_layout Standard
To utilise Visual Studio for C# development, perform the following steps:
\end_layout

\begin_layout Enumerate
Start Visual Studio.
\end_layout

\begin_layout Enumerate
If you receive a 
\family typewriter

\begin_inset Quotes eld
\end_inset

Select Development Language
\family default

\begin_inset Quotes erd
\end_inset

 dialog, select 
\family typewriter
Microsoft C#
\family default
.
\end_layout

\begin_layout Enumerate
Select 
\family typewriter

\begin_inset Quotes eld
\end_inset

New Project
\family default

\begin_inset Quotes erd
\end_inset

 from the Start Page, or alternatively from the 
\family typewriter
File
\family default
 menu.
\end_layout

\begin_layout Enumerate
In the 
\begin_inset Quotes eld
\end_inset


\family typewriter
New Project
\family default

\begin_inset Quotes erd
\end_inset

 dialog, ensure that:
\end_layout

\begin_deeper
\begin_layout Enumerate

\family typewriter
Visual C#
\family default
 > 
\family typewriter
Windows
\family default
 is selected in the Installed Templates pane.
\end_layout

\begin_layout Enumerate

\family typewriter
Console Application - Visual C#
\family default
 is selected in the Application Type pane.
\end_layout

\begin_layout Enumerate

\family typewriter
.NET Framework 2.0
\family default
 is selected in the .NET Framework dropdown.
\end_layout

\begin_layout Enumerate
Enter the name of the challenge in the 
\family typewriter
Name:
\family default
 field.
\end_layout

\begin_layout Enumerate
Note the location in which the project is being created.
\end_layout

\begin_layout Enumerate
Click on
\family typewriter
 OK
\family default
 to build the project.
 (See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Visual-Studio-C"

\end_inset

)
\end_layout

\end_deeper
\begin_layout Enumerate
The new 
\family typewriter
Program.cs
\family default
 file will be opened and displayed in the File Pane.
 (See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Visual-Studio-C-1"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/VS_1.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Visual Studio C# New Project
\begin_inset CommandInset label
LatexCommand label
name "fig:Visual-Studio-C"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/VS_2.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Visual Studio C# Program.cs
\begin_inset CommandInset label
LatexCommand label
name "fig:Visual-Studio-C-1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
When testing your submission with PC^2 you will be required to either:
\end_layout

\begin_layout Enumerate
Copy your source code file to the same location as sample input files, or
\end_layout

\begin_layout Enumerate
Copy the sample input files into the same location as the source code file.
\end_layout

\begin_layout Paragraph
C++
\end_layout

\begin_layout Standard
To utilise Visual Studio for C++ development, perform the following steps:
\end_layout

\begin_layout Enumerate
Start Visual Studio.
\end_layout

\begin_layout Enumerate
If you receive a 
\family typewriter

\begin_inset Quotes eld
\end_inset

Select Development Language
\family default

\begin_inset Quotes erd
\end_inset

 dialog, select 
\family typewriter
Microsoft C
\family default
++.
\end_layout

\begin_layout Enumerate
Select 
\family typewriter

\begin_inset Quotes eld
\end_inset

New Project
\family default

\begin_inset Quotes erd
\end_inset

 from the Start Page, or alternatively from the 
\family typewriter
File
\family default
 menu.
\end_layout

\begin_layout Enumerate
In the 
\begin_inset Quotes eld
\end_inset


\family typewriter
New Project
\family default

\begin_inset Quotes erd
\end_inset

 dialog, ensure that:
\end_layout

\begin_deeper
\begin_layout Enumerate

\family typewriter
Visual C++
\family default
 > 
\family typewriter
Win32
\family default
 is selected in the Installed Templates pane.
\end_layout

\begin_layout Enumerate

\family typewriter
Win32 Console Application - Visual C++
\family default
 is selected in the Application Type pane.
\end_layout

\begin_layout Enumerate

\family typewriter
.NET Framework 2.0
\family default
 is selected in the .NET Framework dropdown.
\end_layout

\begin_layout Enumerate
Enter the name of the challenge in the 
\family typewriter
Name:
\family default
 field.
\end_layout

\begin_layout Enumerate
Note the location in which the project is being created.
\end_layout

\begin_layout Enumerate
Click on
\family typewriter
 OK
\family default
 to build the project.
 (See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Visual-Studio-C-2"

\end_inset

)
\end_layout

\end_deeper
\begin_layout Enumerate
The Win32 Application Wizard will run.
 Select Next on the Wizard Welcome screen.
\end_layout

\begin_layout Enumerate
On the Applications Settings dialog, enusre that 
\begin_inset Quotes eld
\end_inset


\family typewriter
Console Application
\family default

\begin_inset Quotes erd
\end_inset

 is checked, and 
\begin_inset Quotes eld
\end_inset


\family typewriter
Precompiled Headers
\family default

\begin_inset Quotes erd
\end_inset

 is unchecked.
 (See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Visual-Studio-C++"

\end_inset

).
 Click on 
\family typewriter
Finish
\family default
 to build the project.
\end_layout

\begin_layout Enumerate
The new 
\family typewriter
<Application>.cpp
\family default
 file will be opened and displayed in the File Pane.
 (See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Visual-Studio-C-1-1"

\end_inset

)
\end_layout

\begin_layout Enumerate
The following changes are recommended to the main source file to ensure
 maximum platform compatibility:
\end_layout

\begin_deeper
\begin_layout Enumerate
Add 
\begin_inset Quotes eld
\end_inset


\family typewriter
using namespace std;
\family default

\begin_inset Quotes erd
\end_inset

 before any included headers.
\end_layout

\begin_layout Enumerate
Remove or comment out the 
\begin_inset Quotes eld
\end_inset


\family typewriter
#include 
\begin_inset Quotes eld
\end_inset

stdafx.h
\begin_inset Quotes erd
\end_inset


\family default

\begin_inset Quotes erd
\end_inset

 line
\end_layout

\begin_layout Enumerate
Add 
\begin_inset Quotes eld
\end_inset


\family typewriter
#include <stdio.h>
\family default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\family typewriter
#include <iostream>
\family default

\begin_inset Quotes erd
\end_inset

 to ensure POSIX compatibility.
\end_layout

\begin_layout Enumerate
Change 
\family typewriter
int _tmain(int argc, _TCHAR* argv[])
\family default

\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

 to 
\begin_inset Quotes eld
\end_inset


\family typewriter
int main()
\family default

\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
You are now ready to develop your submissions.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/VS_3.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Visual Studio C++ New Project
\begin_inset CommandInset label
LatexCommand label
name "fig:Visual-Studio-C-2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/VS_4.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Visual Studio C++ Project Options
\begin_inset CommandInset label
LatexCommand label
name "fig:Visual-Studio-C++"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/VS_5.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Visual Studio C++ Program.cpp
\begin_inset CommandInset label
LatexCommand label
name "fig:Visual-Studio-C-1-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When testing your submission with PC^2 you will be required to either:
\end_layout

\begin_layout Enumerate
Copy your source code file to the same location as sample input files, or
\end_layout

\begin_layout Enumerate
Copy the sample input files into the same location as the source code file.
\end_layout

\begin_layout Subsection
Submission Guidelines
\begin_inset CommandInset label
LatexCommand label
name "sub:Submission-Guidelines"

\end_inset


\end_layout

\begin_layout Standard
The primary requirement of any submission, is that all source code required
 for the submission is located in a single text file.
\end_layout

\begin_layout Standard
To test your submission, the judges machine will compile your source code
 to an exectuable or class file in the case of Java, then execute it.
 All input for the application is feed in via 
\family typewriter
stdin
\family default
 (or using standard console input), and all application responses and feedback
 should be returned via 
\family typewriter
stdout
\family default
 (or using standard console output).
 In effect the judges machine will run:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
$ submission.exe < challenge1_input.txt > challenge1_output.txt
\end_layout

\begin_layout Standard
Any output the application produces is saved to a file, and this file is
 then compared to a known correct answer file.
 Any variations from between the applications output and the answer file
 will result in a 
\family typewriter
\series bold
No
\family default
\series default
 response.
 If both the output of the application and answer file match, then the judges
 machine will return a 
\family typewriter
\series bold
Yes
\family default
\series default
 response.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Performance
\end_layout

\begin_layout Subsection
BigO Notation
\end_layout

\begin_layout Standard
Big O notation is used in Computer Science to describe the performance or
 complexity of an algorithm.
 Big O specifically describes the 
\series bold
worst-case
\series default
 scenario, and can be used to describe the execution time required or the
 space used (e.g.
 in memory or on disk) by an algorithm.
\end_layout

\begin_layout Standard
Typically, algorithms will be assigned the following functions:
\end_layout

\begin_layout Description
O(1) This algorithm operates in the same time irrespective of the number
 of elements to be processed.
 (The ideal algorithm).
\end_layout

\begin_layout Description
O(log
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

n) This algorithm will have a worst-case runtime of log
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

n with n elements to be processed.
\end_layout

\begin_layout Description
O(n) This algorithm will have a worst case runtime in the order of the number
 of elements to be processed.
\end_layout

\begin_layout Description
O(nlog
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

n) This algorithm will have a worst case runtime in the order of nlog
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

n with n elements to be processed.
\end_layout

\begin_layout Description
O(n
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

) This algoritm will have a worst case runtime in the order of n
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

 with n elements to be processed.
\end_layout

\begin_layout Description
O(n
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

) This algorithm will have a worst case runtime in the order of n
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

 with n elements to be processed.
\end_layout

\begin_layout Description
O(2
\begin_inset script superscript

\begin_layout Plain Layout
n
\end_layout

\end_inset

) This algorithm will have a worst case runtime in the order of 2
\begin_inset script superscript

\begin_layout Plain Layout
n
\end_layout

\end_inset

 with n elements to be processed.
\end_layout

\begin_layout Standard
As an example, suppose the each operation can be done in 1 microsecond,
 and we have 256 elements to be processed.
 The respective worst case runtimes for each function is shown in Table
 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Big-O-runtimes"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
log
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 microseconds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256 microseconds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nlog
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 milliseconds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
65 milliseconds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17 seconds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\begin_inset script superscript

\begin_layout Plain Layout
n
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.7×10
\begin_inset script superscript

\begin_layout Plain Layout
64 
\end_layout

\end_inset

centuries
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Big O runtimes
\begin_inset CommandInset label
LatexCommand label
name "tab:Big-O-runtimes"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The information within this section is a very brief introduction to BigO
 notation, is included to help you choose between two different algorithms
 to complete a task based on the Order function given in the algorithm descripti
on.
 Much research has been completed on algorithm analysis, with many text
 books and reference books being authored on this one subject of Computer
 Science.
\end_layout

\begin_layout Subsection
Measuring Performance
\end_layout

\begin_layout Standard
While information described with algorithms can be useful to gain an understandi
ng of the algorithm complexity, it can be helpful to be able to measure
 the actual exectution time needed to complete sections of code.
 All modern languages or software libraries contatins functions to determine
 exectution times
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Modern IDEs such as Oracle Solaris Studio 12.3 include profiling tools to
 determine 'hot-spots' within applications and also be able to automatically
 record execution times of individual functions/methods to later analysis.
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
C#
\end_layout

\begin_layout Standard
The .NET Framework provides a Stopwatch class that is capable of being used
 to measure execution times.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Timing---Csharp"

\end_inset

 shows an example of the syntax.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language={[Sharp]C}"
inline false
status open

\begin_layout Plain Layout

Stopwatch st = new Stopwatch();
\end_layout

\begin_layout Plain Layout

st.Start();
\end_layout

\begin_layout Plain Layout

// code to be timed goes here
\end_layout

\begin_layout Plain Layout

st.Stop();
\end_layout

\begin_layout Plain Layout

// time in milliseconds 
\end_layout

\begin_layout Plain Layout

long elapsed = (long) st.ElapsedTicks * 1000000 / Stopwatch.Frequency; 
\end_layout

\begin_layout Plain Layout

Console.WriteLine("time = {0}", elapsed);
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Timing - C#
\begin_inset CommandInset label
LatexCommand label
name "fig:Timing---Csharp"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
C++
\end_layout

\begin_layout Standard
The C standard library includes time specific functions in 
\family typewriter
<time.h>
\family default
 on most systems.
 The primary function is the clock() function that returns the number of
 'clicks' since the application started execution.
 A macro 
\family typewriter
CLOCKS_PER_SEC
\family default
 is used to determine the ratio between clicks and seconds.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Timing---C++"

\end_inset

 shows an example of the syntax.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language={C++}"
inline false
status open

\begin_layout Plain Layout

#include <time.h> 
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

clock_t start = clock();
\end_layout

\begin_layout Plain Layout

// code to be timed goes here
\end_layout

\begin_layout Plain Layout

clock_t end = clock();
\end_layout

\begin_layout Plain Layout

// time in clicks 
\end_layout

\begin_layout Plain Layout

long elapsed = (long)(end - start)/CLOCKS_PER_SEC; 
\end_layout

\begin_layout Plain Layout

printf("time = %d
\backslash
n", elapsed);
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Timing - C++
\begin_inset CommandInset label
LatexCommand label
name "fig:Timing---C++"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Java
\end_layout

\begin_layout Standard
The Java System library provides multiple timers with varying accuracy.
 Since Java 5, nanosecond timers has been available via the 
\family typewriter
System.nanoTime()
\family default
 method
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Accuracy of the System.nanoTime() method is reliant on the JVM version and
 underlying Operating System.
 However most modern operating systems do provide some form on nanosecond
 timer.
\end_layout

\end_inset

.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Timing---Java"

\end_inset

 shows an example of the syntax.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Java"
inline false
status open

\begin_layout Plain Layout

long start = System.nanoTime();
\end_layout

\begin_layout Plain Layout

// code to be timed goes here
\end_layout

\begin_layout Plain Layout

long end = System.nanoTime();
\end_layout

\begin_layout Plain Layout

// time in nanoseconds 
\end_layout

\begin_layout Plain Layout

long elapsed = (end - start)/1000000; 
\end_layout

\begin_layout Plain Layout

System.out.printf("time = %d%n", elapsed);
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Timing - Java
\begin_inset CommandInset label
LatexCommand label
name "fig:Timing---Java"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Integers vs Floating Point
\end_layout

\begin_layout Standard
Modern CPUs have integrated high-performance floating-point execution units,
 however it should be noted that the choice of Integer, Long's and Floating
 Point number will have an impact of performance of your solution.
 The code snippet in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Source-code-for"

\end_inset

 demonstrates the performance differences of using 'int', 'long' and 'double'
 for a simple add, multiple and divide sequence.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset listings
lstparams "tabsize=2"
inline false
status open

\begin_layout Plain Layout

 public class NumberTypeTesting {
\end_layout

\begin_layout Plain Layout

   static final long ITERATIONS = 1000000000;
\end_layout

\begin_layout Plain Layout

   public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

     final double DOUBLE_PRIME = 73;
\end_layout

\begin_layout Plain Layout

     final int INT_PRIME = 73;
\end_layout

\begin_layout Plain Layout

     final long LONG_PRIME = 73;
\end_layout

\begin_layout Plain Layout

     long start;
\end_layout

\begin_layout Plain Layout

     long end;
\end_layout

\begin_layout Plain Layout

     long count;
\end_layout

\begin_layout Plain Layout

     double valueDoubleA = 1.00;
\end_layout

\begin_layout Plain Layout

     double valueDoubleB = Math.PI; // pi = 3.142
\end_layout

\begin_layout Plain Layout

     double valueDoubleC = Math.E; // e = 2.718
\end_layout

\begin_layout Plain Layout

     int valueIntA = 1;
\end_layout

\begin_layout Plain Layout

     int valueIntB = 10;
\end_layout

\begin_layout Plain Layout

     int valueIntC = 31;
\end_layout

\begin_layout Plain Layout

     long valueLongA = 1;
\end_layout

\begin_layout Plain Layout

     long valueLongB = 31;
\end_layout

\begin_layout Plain Layout

     long valueLongC = 33;
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

     // Integers
\end_layout

\begin_layout Plain Layout

     count = ITERATIONS;
\end_layout

\begin_layout Plain Layout

     start = System.nanoTime();
\end_layout

\begin_layout Plain Layout

     while (count-- != 0) {
\end_layout

\begin_layout Plain Layout

       valueIntA += valueIntC * valueIntB / INT_PRIME;
\end_layout

\begin_layout Plain Layout

     }
\end_layout

\begin_layout Plain Layout

     end = System.nanoTime();
\end_layout

\begin_layout Plain Layout

     System.out.printf("Integer time = %d msec%n", (end - start) / 1000000);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     // Long
\end_layout

\begin_layout Plain Layout

     count = ITERATIONS;
\end_layout

\begin_layout Plain Layout

     start = System.nanoTime();
\end_layout

\begin_layout Plain Layout

     while (count-- != 0) {
\end_layout

\begin_layout Plain Layout

       valueLongA += valueLongC * valueLongB / LONG_PRIME;
\end_layout

\begin_layout Plain Layout

     }
\end_layout

\begin_layout Plain Layout

     end = System.nanoTime();
\end_layout

\begin_layout Plain Layout

     System.out.printf("Long time = %d msec%n", (end - start) / 1000000);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     // Double
\end_layout

\begin_layout Plain Layout

     count = ITERATIONS;
\end_layout

\begin_layout Plain Layout

     start = System.nanoTime();
\end_layout

\begin_layout Plain Layout

     while (count-- != 0) {
\end_layout

\begin_layout Plain Layout

       valueDoubleA += valueDoubleC * valueDoubleB / DOUBLE_PRIME;
\end_layout

\begin_layout Plain Layout

     }
\end_layout

\begin_layout Plain Layout

     end = System.nanoTime();
\end_layout

\begin_layout Plain Layout

     System.out.printf("Double time = %d msec%n", (end - start) / 1000000);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Source code for timing test
\begin_inset CommandInset label
LatexCommand label
name "fig:Source-code-for"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The results
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Java 6SE 32bit was used to generate the following results.
\end_layout

\end_inset

 for the above test in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Source-code-for"

\end_inset

 are:
\end_layout

\begin_layout Verse

\family typewriter
Integer time = 1131 msec
\begin_inset Newline newline
\end_inset

Long time = 2673 msec 
\begin_inset Newline newline
\end_inset

Double time = 1298 msec
\end_layout

\begin_layout Standard
While there is a minor performance drop for using floating point numbers,
 using 64bit longs yields over double the execution time.
 This may easily be fixed by utilising an environment that runs as 64bit
 code, but this is not guaranteed to be available during the competition.
\end_layout

\begin_layout Subsection
Implementation and Modern Software Engineering Practices
\end_layout

\begin_layout Standard
One of the aims of the competition is to develop efficient solutions to
 the challenges being presented.
 However often this also means not following modern software engineering
 practices and taking as many shortcuts as possible.
\end_layout

\begin_layout Standard
Some items that are typically seen (and encouraged) are:
\end_layout

\begin_layout Enumerate
Liberal use of global variables utlised by direct access.
\end_layout

\begin_layout Enumerate
Libreal use of function pointers and jump tables in C++.
\end_layout

\begin_layout Enumerate
Dispite strong OOP principles with each programming language, these are
 often ignored for more simple data structures and items like inheritence
 and encapsulation are ignored.
\end_layout

\begin_layout Enumerate
Nested classes liberally use public variables allowing for direct access.
\end_layout

\begin_layout Enumerate
The 
\begin_inset Quotes eld
\end_inset


\family typewriter
goto
\family default

\begin_inset Quotes erd
\end_inset

 statement being used in C++ and C# submissions
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
While most professional programmers avoid 
\begin_inset Quotes eld
\end_inset

goto
\begin_inset Quotes erd
\end_inset

 as it's considered inherently evil, there are some instances where its
 use can save execution time and/or reduce code complexity.
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
Ignoring typical design patterns, unless they provide direct and significant
 benefit in utlising an algorithm to complete a challenge.
\end_layout

\begin_layout Enumerate
Error checking is kept to a minimum, mainly designed around corner cases
 for algorithms to handle rather than handling bad and malformed input.
\end_layout

\begin_layout Standard
As mentioned in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Submission-Guidelines"

\end_inset

, that all source code required for the submission is located in a single
 text file, also requires some creative uses of both local and anonymous
 classes.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Basic Source Templates
\end_layout

\begin_layout Standard
All source code submissions are to consist of a single source code file,
 as previously mentioned.
 This section aims to provide simple templates that can be utilised to create
 your submissions.
 It will also cover some of the basic console functions available with each
 langauge.
\end_layout

\begin_layout Subsection
Input / Output
\end_layout

\begin_layout Subsubsection
C#
\end_layout

\begin_layout Standard
The .NET Framework unfortunately has rather cumbersome support for handling
 console input and output.
 The 
\family typewriter
System.Console
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout
http://msdn.microsoft.com/en-us/library/system.console.aspx
\end_layout

\end_inset

 class provides methods for dealing with the console.
 The three main methods that are typically used are:
\end_layout

\begin_layout Enumerate

\family typewriter
Console.ReadLine();
\end_layout

\begin_layout Enumerate

\family typewriter
Console.Write();
\end_layout

\begin_layout Enumerate

\family typewriter
Console.WriteLine();
\end_layout

\begin_layout Paragraph
Input
\end_layout

\begin_layout Standard
The primary function for input from the Console is the 
\family typewriter
Console.ReadLine()
\family default
 method which as the name indicates, reads a single line from the console
 and returns a 
\family typewriter
string
\family default
.
\end_layout

\begin_layout Standard
In order to extract information from the string, it is needed to split the
 string based on a delimiter (typically a space), then attempt to convert
 each part into the desired type.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Cs-Input-Template"

\end_inset

 shows how to read a group of 3 integers (per line) from the console, until
 a three 0's (zeroes) are entered.
 The numbers for each line is added, and the sum is written back to the
 console.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={[Sharp]C}"
inline false
status open

\begin_layout Plain Layout

using System;
\end_layout

\begin_layout Plain Layout

namespace AddNumbers {
\end_layout

\begin_layout Plain Layout

  class Program {
\end_layout

\begin_layout Plain Layout

    static void Main(string[] args) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Define our numbers to read.
\end_layout

\begin_layout Plain Layout

      int[] numbers;
\end_layout

\begin_layout Plain Layout

      int index;
\end_layout

\begin_layout Plain Layout

      int sum;
\end_layout

\begin_layout Plain Layout

      string line;
\end_layout

\begin_layout Plain Layout

      string[] linesplit;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Keep reading the input from the console until we have nothing left.
\end_layout

\begin_layout Plain Layout

      while ((line = Console.ReadLine()) != null) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Test for exit condition.
\end_layout

\begin_layout Plain Layout

        if (line.CompareTo("0 0 0") == 0) {
\end_layout

\begin_layout Plain Layout

          break;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Reset array indices and sum of numbers
\end_layout

\begin_layout Plain Layout

        index = 0;
\end_layout

\begin_layout Plain Layout

        sum = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Split the line read, and create a new int array to hold our value.
\end_layout

\begin_layout Plain Layout

        linesplit = line.Split(' ');
\end_layout

\begin_layout Plain Layout

        numbers = new int[linesplit.Length];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Attempt to convert the individual parts to int's
\end_layout

\begin_layout Plain Layout

        foreach (string element in linesplit) {
\end_layout

\begin_layout Plain Layout

          try {
\end_layout

\begin_layout Plain Layout

            numbers[index] = Convert.ToInt32(element);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          catch {
\end_layout

\begin_layout Plain Layout

            numbers[index] = 0;
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          index++;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Sum our number and output the sum to Console.
\end_layout

\begin_layout Plain Layout

        foreach (int number in numbers) {
\end_layout

\begin_layout Plain Layout

          sum += number;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        Console.WriteLine("{0}", sum);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
C# Input Template
\begin_inset CommandInset label
LatexCommand label
name "fig:Cs-Input-Template"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Output
\end_layout

\begin_layout Standard
The primary functions for output to the Console are the 
\family typewriter
Console.Write()
\family default
 and 
\family typewriter
Console.WriteLine()
\family default
 methods.
 These two differ only by the latter terminating the line with a 
\family typewriter
carriage-return
\family default
, while the former does not.
\end_layout

\begin_layout Standard
One item to note, that a single 
\family typewriter
Console.Write() 
\family default
method may only take up to 5 parameters, the first being a string, and the
 other 4 being items to be inserted into the string.
 Item placement within the string is denoted by a number with 
\family typewriter
{}
\family default
 brackets.
 (See the last line in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Cs-Input-Template"

\end_inset

 for an example).
 The item placement parameter, may also take a second argument, being the
 type to have the item converted to, or displayed as.
 Common types include:
\end_layout

\begin_layout Verse

\family typewriter
(C) Currency: .
 .
 .
 .
 .
 .
 .
 .
 {0:C}
\begin_inset Newline newline
\end_inset

(D) Decimal:.
 .
 .
 .
 .
 .
 .
 .
 .
 {0:D}
\begin_inset Newline newline
\end_inset

(E) Scientific:.
 .
 .
 .
 .
 .
 .
 .
 {0:E}
\begin_inset Newline newline
\end_inset

(F) Fixed point: .
 .
 .
 .
 .
 .
 .
 {0:F}
\begin_inset Newline newline
\end_inset

(G) General:.
 .
 .
 .
 .
 .
 .
 .
 .
 {0:G}
\begin_inset Newline newline
\end_inset

(P) Percent:.
 .
 .
 .
 .
 .
 .
 .
 .
 {0:P}
\begin_inset Newline newline
\end_inset

(X) Hexadecimal: .
 .
 .
 .
 .
 .
 .
 {0:X}
\end_layout

\begin_layout Standard
By default, console output is buffered, and only written periodically as
 determined by underlying system settings.
 To flush the output to console immediately, the 
\family typewriter
Console.Out.Flush()
\family default
 method can be utilised.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
C++
\end_layout

\begin_layout Standard
Due to the environment in which C++ was originally developed, C++ has very
 strong capabilities for handling both console input and output.
 C++ offers two methods when working with the console:
\end_layout

\begin_layout Enumerate
iostreams
\end_layout

\begin_layout Enumerate
C standard library functions.
\end_layout

\begin_layout Standard
While the two methods can be intermixed, it is recommended that programmers
 utilise a single method for their application
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Mixing the two methods is possible, on provision that all input and output
 streams are emtpy when switching between either method.
 This is due to the buffering that each method utilises during Console IO
 operations.
\end_layout

\end_inset

.
 For the purposes of this guide, I'll only explain the 
\family typewriter
iostream
\family default
s method as it is often seen as easy to use of the two methods.
\end_layout

\begin_layout Paragraph
Input
\end_layout

\begin_layout Standard
Input from the console is handled by the 
\family typewriter
std::cin
\family default
 stream, and has the ability to take multiple types of inputs in a single
 line or function call.
 (This is possible due to operator overloading in C++).
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:C++-input-and"

\end_inset

 shows the same application written in C++, as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Cs-Input-Template"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={[ANSI]C++}"
inline false
status open

\begin_layout Plain Layout

#include <cstdlib>
\end_layout

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    int a, b, c;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    do {
\end_layout

\begin_layout Plain Layout

        // Get input of 3 integers and store in a, b and c.
\end_layout

\begin_layout Plain Layout

        cin >> a >> b >> c;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Test exit condition, and exit if true.
\end_layout

\begin_layout Plain Layout

        if(a == 0 && b == 0 && c == 0)
\end_layout

\begin_layout Plain Layout

            break;
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        // Output the sum.
\end_layout

\begin_layout Plain Layout

        cout << (a + b + c) << endl;
\end_layout

\begin_layout Plain Layout

    } while(true);
\end_layout

\begin_layout Plain Layout

   return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
C++ input and output example
\begin_inset CommandInset label
LatexCommand label
name "fig:C++-input-and"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since the 
\family typewriter
cin
\family default
 and 
\family typewriter
cout
\family default
 streams operate on single variables, an alternate method is required to
 read a complete line in one function call.
 This method is 
\family typewriter
getline ( istream& is, string& str );
\family default
, where 
\family typewriter
is
\family default
 is the character stream, and 
\family typewriter
str
\family default
 is the string to place the input into.
 As example of 
\family typewriter
getline() 
\family default
is in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:C++-getline()-example"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={[ANSI]C++}"
inline false
status open

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include <string>
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main () {
\end_layout

\begin_layout Plain Layout

  string str;
\end_layout

\begin_layout Plain Layout

  cout << "Please enter full name: ";
\end_layout

\begin_layout Plain Layout

  getline (cin,str);
\end_layout

\begin_layout Plain Layout

  cout << "Thank you, " << str << ".
\backslash
n";
\end_layout

\begin_layout Plain Layout

  return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
C++ getline() example
\begin_inset CommandInset label
LatexCommand label
name "fig:C++-getline()-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once the line has been fetched with the 
\family typewriter
getline()
\family default
 method, you are free to use any of the other string functions to extract
 information from the string.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Paragraph
Output
\end_layout

\begin_layout Standard
The primary method of output is via the 
\family typewriter
cout
\family default
 iostream, as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:C++-input-and"

\end_inset

.
 The format is simply:
\end_layout

\begin_layout Standard

\family typewriter
cout << {object} << {object} << {object} << 
\begin_inset Quotes eld
\end_inset

 string 
\begin_inset Quotes erd
\end_inset

 << ..
 << endl;
\end_layout

\begin_layout Standard
where each {object} represents any C++ primitive type or any C++ object.
\end_layout

\begin_layout Standard
There are two methods to generating a newline character, utilising C++.
 You may either:
\end_layout

\begin_layout Enumerate
Output string 
\family typewriter

\begin_inset Quotes eld
\end_inset


\backslash
n
\begin_inset Quotes erd
\end_inset


\family default
, or
\end_layout

\begin_layout Enumerate
Output 
\family typewriter
std::endl
\family default
 .
\end_layout

\begin_layout Standard
The difference between the two methods, is that 
\begin_inset Quotes eld
\end_inset


\family typewriter
std::endl
\family default

\begin_inset Quotes erd
\end_inset

 will flush the output buffer to console, where 
\begin_inset Quotes eld
\end_inset


\family typewriter

\backslash
n
\family default

\begin_inset Quotes erd
\end_inset

 will not.
\end_layout

\begin_layout Standard
To control the precision of floating point numbers, you can use the 
\family typewriter
setprecision(
\shape italic
x
\shape default
)
\family default
 method as part of the output sequence.
 eg: 
\family typewriter
cout << setprecision(4) << (double)1.23456788 << endl
\family default
; will output 
\family typewriter
1.235
\family default
 to the console.
\end_layout

\begin_layout Paragraph
iostreams vs printf
\begin_inset CommandInset label
LatexCommand label
name "par:iostreams-vs-printf"

\end_inset


\end_layout

\begin_layout Standard
The other method to perform console output is the C function 
\family typewriter
printf()
\family default
.
 
\family typewriter
printf()
\family default
 offers the same features as the 
\family typewriter
cout
\family default
 iostream, and may be used when very fine control over output is required
 especially with floating point numbers.
 
\end_layout

\begin_layout Standard
The general format of the printf() function is:
\end_layout

\begin_layout Verse

\family typewriter
printf(const char *str, ...);
\end_layout

\begin_layout Standard

\family typewriter
str
\family default
 is a formatted string, that may contain 0 or more place holders for additional
 arguments.
 Placeholders in the formatted string are simply filled in order of additional
 arguments as specified in the function call, and the additional arguments
 must be of the same type as specified by the placeholder.
\end_layout

\begin_layout Standard
Formats for placeholders include:
\end_layout

\begin_layout Verse

\family typewriter
%d
\family default
 - decimal 
\family typewriter

\begin_inset Newline newline
\end_inset

%du
\family default
 - decimal unsigned
\begin_inset Newline newline
\end_inset


\family typewriter
%f
\family default
 - floating point
\begin_inset Newline newline
\end_inset


\family typewriter
%s
\family default
 - string (char*)
\begin_inset Newline newline
\end_inset


\family typewriter
%c
\family default
 - character
\begin_inset Newline newline
\end_inset


\family typewriter
%x
\family default
 - hexidecimal number
\begin_inset Newline newline
\end_inset


\family typewriter
%l
\family default
 - long 
\begin_inset Newline newline
\end_inset


\family typewriter
%lu
\family default
 - long unsigned
\end_layout

\begin_layout Standard
Additional fields may be added to the place holders to specify field width
 and/or precisions.
 For example:
\end_layout

\begin_layout Verse

\family typewriter
%.5f
\family default
 - will display a floating point number to 5 decimal places.
\begin_inset Newline newline
\end_inset


\family typewriter
%5s
\family default
 - will consume at exactly 5 character spaces for a string.
 
\end_layout

\begin_layout Standard
There are a few special reserved characters for the printf(), some of these
 include:
\end_layout

\begin_layout Verse

\family typewriter

\backslash
n
\family default
 - carriage return.
\begin_inset Newline newline
\end_inset


\family typewriter

\backslash
t
\family default
 - tab character.
\end_layout

\begin_layout Standard
There are has been some debate over the performance aspects of the two methods,
 often siting that there is no performance difference.
 Utilising the source code in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:C++,-cout-vs"

\end_inset

, I've found that in some cases there can be significant differences in
 performance, with 
\family typewriter
printf()
\family default
 being up to 250 times faster than the equivalent 
\family typewriter
cout
\family default
 function.
\end_layout

\begin_layout Standard
Based on average times for 5 runs of the test application in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:C++,-cout-vs"

\end_inset

, yeilds the following results:
\end_layout

\begin_layout Enumerate
cout time = 67240 msec
\end_layout

\begin_layout Enumerate
printf() time = 280 msec
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={[ANSI]C++}"
inline false
status open

\begin_layout Plain Layout

#include <cstdlib>
\end_layout

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define LOOPCOUNT 1000000
\end_layout

\begin_layout Plain Layout

#define NUMBER1 31.0 
\end_layout

\begin_layout Plain Layout

#define NUMBER2 21
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    long count = LOOPCOUNT;
\end_layout

\begin_layout Plain Layout

    double dbl = NUMBER1;
\end_layout

\begin_layout Plain Layout

    int Int = NUMBER2;
\end_layout

\begin_layout Plain Layout

    char* str = (char*) &"hello";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    clock_t start = clock(); // Start timing
\end_layout

\begin_layout Plain Layout

    while (count--) {
\end_layout

\begin_layout Plain Layout

        cout << dbl << " " << Int++ << " " << str << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

        dbl = dbl * (double) Int / ((double) Int * 2.0);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    clock_t end = clock(); // End timing
\end_layout

\begin_layout Plain Layout

    cerr << "cout time = " << double(end - start)*1000.0/CLOCKS_PER_SEC 
\end_layout

\begin_layout Plain Layout

         << "msec " << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // reset start values
\end_layout

\begin_layout Plain Layout

    count = LOOPCOUNT;
\end_layout

\begin_layout Plain Layout

    dbl = NUMBER1;
\end_layout

\begin_layout Plain Layout

    Int = NUMBER2;
\end_layout

\begin_layout Plain Layout

    start = clock(); // Start timing
\end_layout

\begin_layout Plain Layout

    while (count--) {
\end_layout

\begin_layout Plain Layout

        printf("%f %d %s
\backslash
n", dbl, Int++, str);
\end_layout

\begin_layout Plain Layout

        dbl = dbl * (double) Int / ((double) Int * 2.0);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    end = clock(); // End timing
\end_layout

\begin_layout Plain Layout

    cerr << "printf time = " << double(end - start)*1000.0/CLOCKS_PER_SEC
\end_layout

\begin_layout Plain Layout

         << "msec" << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
C++, 
\family typewriter
cout
\family default
 vs 
\family typewriter
printf()
\family default

\begin_inset CommandInset label
LatexCommand label
name "fig:C++,-cout-vs"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Java
\end_layout

\begin_layout Standard
Similar to C++, Java has a very capable set of support functions for handling
 console input and output.
 These are mainly archived through the 
\family typewriter
System.in 
\family default
and 
\family typewriter
System.out
\family default
 classes used in conjuction with the 
\family typewriter
Java.util.Scanner
\family default
 class provided with the default Java libraries.
\end_layout

\begin_layout Paragraph
Input
\end_layout

\begin_layout Standard
Java historically has had a large number of different methods for handling
 console input, with each new version of Java providing a more streamlined
 method of handling these functions.
\end_layout

\begin_layout Standard
The current prefered method for console input in Java is to use the 
\family typewriter
Java.util.Scanner
\family default
 class tied with the 
\family typewriter
System.in
\family default
 object to extract the required information from the console.
 An example of the 
\family typewriter
Scanner
\family default
 class can be found in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Java-Input-and"

\end_inset

 which solves the same problem as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Cs-Input-Template"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

public class AddNumbers {
\end_layout

\begin_layout Plain Layout

   public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // get first line and check for end of test cases
\end_layout

\begin_layout Plain Layout

      String line = in.nextLine();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Continue until exit condition
\end_layout

\begin_layout Plain Layout

      while (!line.equals("0 0 0")) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

         // extract three ints
\end_layout

\begin_layout Plain Layout

         Scanner sc = new Scanner(line);
\end_layout

\begin_layout Plain Layout

         int a = sc.nextInt();
\end_layout

\begin_layout Plain Layout

         int b = sc.nextInt();
\end_layout

\begin_layout Plain Layout

         int c = sc.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

         System.out.printf("%d%n", (a + b + c));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

         // get next line
\end_layout

\begin_layout Plain Layout

         line = in.nextLine();
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Java Input and Output
\begin_inset CommandInset label
LatexCommand label
name "fig:Java-Input-and"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Output
\end_layout

\begin_layout Standard
Output is easiest handled via the 
\family typewriter
System.out.printf()
\family default
 method, as it offers a good match between flexiblity and performance.
 The format for the method call is the same as the C++ 
\family typewriter
printf()
\family default
 function as described in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:iostreams-vs-printf"

\end_inset

.
 An example of the method call is also in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Java-Input-and"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Basic Algorithms
\end_layout

\begin_layout Subsection
Sorting
\end_layout

\begin_layout Standard
The majority of data structures that will be utilised within the competition
 all provide some form of inbuilt sorting algorithm, or through their design
 are naturally sorted as in the case of a Binary Search Tree.
\end_layout

\begin_layout Standard
It is highly recommended as far as competition submissions are concerned,
 that you utilise the built-in sort methods rather that attempting to implement
 your own sort method.
\end_layout

\begin_layout Standard
Typically, most data structures will utilise either quicksort or merge sort
 (depending on the underlying structure) as they both offer 
\series bold
O(
\shape italic
n
\shape default
 log 
\shape italic
n
\shape default
)
\series default
 performance in the average case.
 
\end_layout

\begin_layout Subsection
Searching
\end_layout

\begin_layout Standard
When given a linear array of data items, search algorithms find information
 about a particular data item in the list or find the location of the data
 item in the list.
 Two primary search algorithms are:
\end_layout

\begin_layout Enumerate
Linear Search
\end_layout

\begin_layout Enumerate
Binary Search
\end_layout

\begin_layout Subsubsection
Linear Search
\end_layout

\begin_layout Standard
Linear Search algorithms transverse through a list of data items in sequential
 order attempting to find the location of the data item.
 The list itself may or may not be sorted, and the underlying data structure
 may be a linear array or a linked list.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require Vector $S$, with $n$ elements, with search key $k$
\end_layout

\begin_layout Plain Layout


\backslash
Ensure if $k 
\backslash
in S$ return index of $k$, else return -1
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{LinearSearch}{$S,k$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$i$ = 0 to $n-1$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$S$[$i$] = $k$}
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return $i$
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return -1
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Linear Search
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
The linear search algorithm takes a vector (aka array) of elements, and
 simply searches all elements in order as stored.
 This can yeild slow performance with large vectors, as the worst case for
 linear search is 
\series bold
O(
\shape italic
n
\shape default
)
\series default
.
\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Linear-Search-Implementation"

\end_inset

 and Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Linear-Search-Implementation2"

\end_inset

 show the linear search algorithm as implemented in Java and C++ respectively.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public int LinearSearch(E[] vector, E key){
\end_layout

\begin_layout Plain Layout

  for(int index = 0; index < vector.length; index++){
\end_layout

\begin_layout Plain Layout

    if(vector[index] == key){
\end_layout

\begin_layout Plain Layout

      return index;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return -1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Linear Search Implementation (Java)
\begin_inset CommandInset label
LatexCommand label
name "fig:Linear-Search-Implementation"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public int LinearSearch(E[] vector, int vsize, E key){
\end_layout

\begin_layout Plain Layout

  for(int index = 0; index < vsize; index++){
\end_layout

\begin_layout Plain Layout

    if(vector[index] == key){
\end_layout

\begin_layout Plain Layout

      return index;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return -1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Linear Search Implementation (C++)
\begin_inset CommandInset label
LatexCommand label
name "fig:Linear-Search-Implementation2"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem - Linear Search 
\begin_inset CommandInset label
LatexCommand label
name "par:SP-Linear-Search"

\end_inset


\end_layout

\begin_layout Standard
Given a list of numbers (integers) in a line, determine if the first value
 on the line is present within the subsequent list of numbers.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
Input consists of one or more lines, with the first line being the number
 of cases to test.
\end_layout

\begin_layout Standard
Each line consists of one or more integers in the range of 0 to 32767.
 The first integer is the key value, followed by a list of up to 32 integers
 forming a vector of numbers.
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
3
\begin_inset Newline newline
\end_inset

10 12 327 0 10 
\begin_inset Newline newline
\end_inset

1 2 3 4 5 6 7 8
\begin_inset Newline newline
\end_inset

10 20 30 40 50 60 70 90 10
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
The output of each line should consist of a single integer being either
 the index of the key within the vector, being zero (0) offset, or the value
 -1 if the key is not present in the vector.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
3
\begin_inset Newline newline
\end_inset

-1
\begin_inset Newline newline
\end_inset

7
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Problem Solution
\end_layout

\begin_layout Standard
A solution to the above problem utilising a linear search can be seen in
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Solution-to-Linear"

\end_inset

.
 The solution included simply reads in a line of numbers, and attempts to
 find the first value in the list of other values in the line.
 It continues to do this, until the exit condition is reached.
\end_layout

\begin_layout Standard
Some of the test cases to handle include:
\end_layout

\begin_layout Enumerate
The case count being less or equal to 0.
\end_layout

\begin_layout Enumerate
The line itself contains a single integer, being the key, but provided with
 an empty vector to search.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class LinearSearch {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Perform linear search of array (vector) for item (key).
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param vector array of numbers
\end_layout

\begin_layout Plain Layout

   * @param key item to look for in array
\end_layout

\begin_layout Plain Layout

   * @return index of key in vector, or -1 is not present
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static int LinearSearch(int[] vector, int key) {
\end_layout

\begin_layout Plain Layout

    for (int index = 0; index < vector.length; index++) {
\end_layout

\begin_layout Plain Layout

      if (vector[index] == key) {
\end_layout

\begin_layout Plain Layout

        return index;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return -1;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // get first line and get the number of cases to test.
\end_layout

\begin_layout Plain Layout

    int caseCount = Integer.parseInt(in.nextLine());
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Keep reading each line while caseCount > 0
\end_layout

\begin_layout Plain Layout

    while (caseCount-- > 0) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // split by white space.
 so we have an array of numbers
\end_layout

\begin_layout Plain Layout

      String[] numStrs = in.nextLine().split("
\backslash

\backslash
s+");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // create an array to hold our numbers, and convet the array of strings
 to
\end_layout

\begin_layout Plain Layout

      // numbers.
 Note: numStrs[0] is the key value
\end_layout

\begin_layout Plain Layout

      int[] nums = new int[numStrs.length - 1];
\end_layout

\begin_layout Plain Layout

      for (int i = 1; i < nums.length; i++) {
\end_layout

\begin_layout Plain Layout

        nums[i - 1] = Integer.parseInt(numStrs[i]);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Output the index of the key in the vector
\end_layout

\begin_layout Plain Layout

      System.out.printf("%d%n", LinearSearch(nums, Integer.parseInt(numStrs[0]))));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Solution to Linear Search Problem (Java)
\begin_inset CommandInset label
LatexCommand label
name "fig:Solution-to-Linear"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Binary Search
\end_layout

\begin_layout Standard
The binary search algorithm is a more efficient method of searching a vector,
 on provision that the vector is sorted and any element can be accessed
 in 
\series bold
O(1)
\series default
 time.
 Becuase of these two conditions, it can't with some storage data structures
 like linked lists (as elements can't be accessed in 
\series bold
O(1)
\series default
 time), nor is suitable for vectors that are unsorted.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require An ordered vector $S$, with $n$ elements, with search key $k$.
 Items $low$ and $high$ indicate current search space of vector $S$
\end_layout

\begin_layout Plain Layout


\backslash
Ensure if $k 
\backslash
in S$ return index of $k$, else return -1
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{BinarySearch}{$S, k, low, high$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$low$ > $high$}
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return -1
\end_layout

\begin_layout Plain Layout


\backslash
Else
\end_layout

\begin_layout Plain Layout


\backslash
State $mid 
\backslash
leftarrow 
\backslash
lfloor ( low + high ) / 2 
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout


\backslash
If {$k = S[mid]$}
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return $mid$
\end_layout

\begin_layout Plain Layout


\backslash
ElsIf {$k < S[mid]$}
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return BinarySearch($S,k,low,mid-1$)
\end_layout

\begin_layout Plain Layout


\backslash
Else
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return BinarySearch($S,k,mid+1,high$)
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Binary Search
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
The binary search algorithm is a naturally recursive algorithm, in that
 it calls itself to continue searching the vector.
 
\end_layout

\begin_layout Standard
The algorithm starts with the entire space of the vector, and looks at the
 mid point between the 
\shape italic
low
\shape default
 and 
\shape italic
high
\shape default
 values.
 If this value is not the required key (
\shape italic
k
\shape default
), it will then determine if the key is less than or greater than the current
 value at 
\shape italic
mid
\shape default
.
 If the key is lower than mid, then it will redefine the search space to
 be that between 
\shape italic
low
\shape default
 and 
\shape italic
mid-1
\shape default
, otherwise redefine the search space between 
\shape italic
mid
\shape default
+1 and 
\shape italic
high
\shape default
.
 It then calls itself to perform another search.
 In the event that 
\shape italic
low
\shape default
 is greater than 
\shape italic
high
\shape default
, it determines that the key is not in 
\shape italic
S
\shape default
, and will return -1.
\end_layout

\begin_layout Standard
What the algorithm effectively does is split the entire search space of
 vector 
\shape italic
S
\shape default
 into 2 parts, if the key is not at 
\shape italic
mid
\shape default
.
 By virtue, if the value at 
\shape italic
mid
\shape default
 is less than the key, it understands that there is no justification to
 look at values located to the left of the current 
\shape italic
mid
\shape default
 point in the vector.
 With each iteration of the search it effectively reduces the search space
 by half.
\end_layout

\begin_layout Standard
By reduction of the search by half, the worst case performance of a binary
 search is 
\series bold
O(log
\shape italic
 n
\shape default
)
\series default
.
 As this is a vast improvement on a linear search, a binary search should
 be utilised when ever possible.
 However, this requires that the vector be sorted before a binary search
 can be performed.
\end_layout

\begin_layout Standard
Utilising a quicksort or merge sort, will add overhead (both of these typically
 yield 
\series bold
O(
\shape italic
n
\shape default
 log
\shape italic
 n
\shape default
)
\series default
 performance), so for very large vectors, the overhead of a sort prior to
 search is not that great, but for small size vectors, the overhead of a
 sort may not yield greater performance over the simple (and slow) linear
 search.
\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Binary-Search-(Java)"

\end_inset

 shows an implementation of the binary search in Java.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public int BinarySearch(E[] vector, E key, int low, int high){
\end_layout

\begin_layout Plain Layout

  if(low > high){
\end_layout

\begin_layout Plain Layout

    return -1;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  int mid = (low+high)/2;
\end_layout

\begin_layout Plain Layout

  if(vector[mid] == key){
\end_layout

\begin_layout Plain Layout

    return mid;
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    if(key < vector[mid]){
\end_layout

\begin_layout Plain Layout

      return BinarySearch(vector, key, low, (mid-1));
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      return BinarySearch(vector, key, (mid+1), high);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Binary Search (Java)
\begin_inset CommandInset label
LatexCommand label
name "fig:Binary-Search-(Java)"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem
\end_layout

\begin_layout Standard
For demonstration of the Binary Search algorithm, I will use the same problem
 as shown in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:SP-Linear-Search"

\end_inset

, Linear Search Problem.
 However, it is expected that the input of numbers (except for the key)
 will be in order from lowest to highest.
\end_layout

\begin_layout Paragraph
Problem Solution
\end_layout

\begin_layout Standard
A solution to the sample problem utilising a binary search can be seen in
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Solution-to-Linear-1"

\end_inset

.
 The solution included simply reads in a line of numbers, and attempts to
 find the first value in the list of other values in the line.
 It continues to do this, until the exit condition is reached.
\end_layout

\begin_layout Standard
Some of the test cases to handle include:
\end_layout

\begin_layout Enumerate
The case count being less or equal to 0.
\end_layout

\begin_layout Enumerate
The line itself contains a single integer, being the key, but provided with
 an empty vector to search.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !th
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class LinearSearch {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Perform binary search of array (vector) for item (key).
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param vector array of numbers
\end_layout

\begin_layout Plain Layout

   * @param key item to look for in array
\end_layout

\begin_layout Plain Layout

   * @param low start position of array to search
\end_layout

\begin_layout Plain Layout

   * @param high end position of array to search
\end_layout

\begin_layout Plain Layout

   * @return index of key in vector, or -1 is not present
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static int BinarySearch(int[] vector, int key, int low, int high){
\end_layout

\begin_layout Plain Layout

    if(low > high){
\end_layout

\begin_layout Plain Layout

      return -1;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    int mid = (low+high)/2;
\end_layout

\begin_layout Plain Layout

    if(vector[mid] == key){
\end_layout

\begin_layout Plain Layout

      return mid;
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      if(key < vector[mid]){
\end_layout

\begin_layout Plain Layout

        return BinarySearch(vector, key, low, (mid-1));
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        return BinarySearch(vector, key, (mid+1), high);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // get first line and get the number of cases to test.
\end_layout

\begin_layout Plain Layout

    int caseCount = Integer.parseInt(in.nextLine());
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Keep reading each line while caseCount > 0
\end_layout

\begin_layout Plain Layout

    while (caseCount-- > 0) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // split by white space.
 so we have an array of numbers
\end_layout

\begin_layout Plain Layout

      String[] numStrs = in.nextLine().split("
\backslash

\backslash
s+");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // create an array to hold our numbers, and convet the array of strings
 to
\end_layout

\begin_layout Plain Layout

      // numbers.
 Note: numStrs[0] is the key value
\end_layout

\begin_layout Plain Layout

      int[] nums = new int[numStrs.length - 1];
\end_layout

\begin_layout Plain Layout

      for (int i = 1; i < nums.length; i++) {
\end_layout

\begin_layout Plain Layout

        nums[i - 1] = Integer.parseInt(numStrs[i]);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Output the index of the key in the vector
\end_layout

\begin_layout Plain Layout

      System.out.printf("%d%n", 
\end_layout

\begin_layout Plain Layout

        BinarySearch(nums, Integer.parseInt(numStrs[0]), 0, nums.length-1));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Solution to Binary Search Problem (Java)
\begin_inset CommandInset label
LatexCommand label
name "fig:Solution-to-Linear-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Array Handling
\end_layout

\begin_layout Standard
When talking about arrays, we typical define one as a single string
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A string in many languages (notably low level langauges like assembler)
 does not define a String of letters, numbers and punctuation, but rather
 a linear memory region of bytes.
\end_layout

\end_inset

 or allocation of elements in a linear continous region.
 Ee can define an array of arrays to form a two dimensional array, or an
 array of arrays of arrays to form a three dimensional array, and continue
 to do so, allowing for infinite dimensional array.
 This section will typically discuss array operations on two dimensional
 arrays, such as rotation and mirroring that may support application of
 algorithms or may simply speed up implementions due to underlying hardware
 constraints.
\end_layout

\begin_layout Subsubsection
Array Performance
\begin_inset CommandInset label
LatexCommand label
name "sub:Array-Performance"

\end_inset


\end_layout

\begin_layout Standard
When most people are taught programming in either High School or early Universit
y level, performance constraints in regards to arrays is either neglected
 or very limited discussion is made without concrete examples.
 This section aims to give some insight to performance issues when dealing
 with arrays, primarily around performance bottlenecks.
\end_layout

\begin_layout Standard
The primary reason for poor performance when using arrays, is not based
 on a programming language or library issue, but is based on lack of understandi
ng the underlying hardware and how memory access works.
\end_layout

\begin_layout Standard
From a hardware achitectural viewpoint there are different classes of hardware
 memory:
\end_layout

\begin_layout Enumerate
Primary - The RAM that the CPU sees as the address space given to it.
\end_layout

\begin_layout Enumerate
Secondary - The Harddrive installed within the system, providing non-voliatile
 memory.
 
\end_layout

\begin_layout Enumerate
Teritiary - Removable non-voliatile memory such as DVD's, CD's, USB Flash
 Keys, etc.
\end_layout

\begin_layout Standard
What is typically not taught are the different levels of primary storage.
 Utilising a modern Intel x86 processor
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The size and access latencies described are taken from the Intel Core 2
 Quad Family Datasheet and Vol 3 of the Intel Architecture Manuals.
\end_layout

\end_inset

 as an example, the primary levels include:
\end_layout

\begin_layout Enumerate
CPU registers, internal to the CPU and these are where typically most operations
 are performed.
 These typically have a zero latency access.
\end_layout

\begin_layout Enumerate
Level 1 Data and Code caches, these hold the most recent code and data being
 accessed from the Level 2 cache.
 There are typically two Level 1 caches, each desginated for holding either
 code or data, and are typically 16kilobytes size in size
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Each CPU make/model can have different L1 cache sizes, for example the Intel
 E7 Xeon CPUs have 32KB for code and 32KB for data in it's L1 cache, and
 the AMD Opteron utilises 64KB L1 caches.
 
\end_layout

\end_inset

.
 The Level 1 cache will typically have a 1-2 CPU cycle access latency, and
 besides the CPU registers is the fastest memory available to the CPU.
\end_layout

\begin_layout Enumerate
Level 2 unified Code and Data cache will typically be in the size of anywhere
 from 256kilobytes up to 16megabytes in size depending on the CPU make and
 model.
 This acts a large cache between the main memory of the system, and the
 CPU and Level 1 caches.
 The Level 2 cache will typically have a 5-10 CPU cycle access latency,
 primarily due to restrictions of the size of the cache.
 (The larger the cache, the slower the access due to it's size
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is a very crude approximation, as there are many factors that determine
 the performance of the L2 cache.
\end_layout

\end_inset

).
\end_layout

\begin_layout Enumerate
Level 3 unified Code and Data caches are present in some CPUs and act as
 a third level between the CPU and main memory of the system.
 Level 3 caches are becoming more common with multi-core CPUs, as Level
 2 and Level 1 caches are being tied to a particular CPU core, where the
 Level 3 cache can act as a unified cache for all CPU cores.
 While Level 3 caches can be quite big, in some cases now approaching 32MB
 in size
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The Sun UltraSPARC IV+ utilises a 32MB L3 cache and the Intel Itanium 9300
 utilises a 24MB L3 cache.
\end_layout

\end_inset

, they are even slower that the Level 2 cache with access latency between
 15-35 CPU cycles.
\end_layout

\begin_layout Enumerate
Main Memory, is typically in the form of the DIMMs that get installed in
 the mainboard of the computer.
 While systems are approaching very large capacities (32GB can be found
 in home desktop systems, and up to 194GB in workstations), they are very
 slow compared to the CPU registers and even the Level 1,2 and 3 caches.
 Typical access latencies can be measured anywhere from hundreds to thousands
 of CPU cycles.
 That is, if the CPU needs some information that is not present in one of
 the caches, it can potentially stall for 100's, if not 1000's of CPU cycles
 doing nothing while it waits for the information
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
CPU vendors do a lot to avoid this, and even resort to techniques such as
 SMT (aka HyperThreading), or even offer CPU instructions that allow application
s to preload the caches with information to avoid these stalls.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Why is knowing all about the different level of cache's important in regards
 to arrays? Simply, if you try to access an array element that is not in
 one of the caches, your application will suffer a performance hit whilst
 waiting for the information from main memory.
 By ensuring that your next memory access will be in one of the CPUs cache,
 you can ensure the best possible performance for your applicaton when dealing
 with any sized array.
\end_layout

\begin_layout Standard
To quote Terje Mathisen (a well known programming optimization guru
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Terje, at one time worked for iD Software on the original Doom and Quake
 games and was able to get Quake running a full 3D environment utilising
 a software based graphics renderer on hardware such as the Intel Pentium
 60.
 (The Intel Pentium 60, ran at 60MHz, roughly 60-90 times slower than current
 CPUs).
\end_layout

\end_inset

): "All programming is an exercise in caching."
\end_layout

\begin_layout Standard
The problem with current programming languages, notably Java and C# is that
 they run on top of virtual machines or utilise some form of JIT compilation,
 negating any direct control of the CPU and cache management functions.
 Even C++ applications lack cache management functions (unless you utilise
 inline assembler in your application).
 The way to work with these languages is to exploit the nature of the CPU's
 cache management engine to your advantage.
\end_layout

\begin_layout Standard
The CPUs cache management engine works by loading the contents of most recently
 accessed memory address into the cache in either 32byte chunks for the
 level 1 cache, or 4kilobyte chunks for the level 2 and 3 caches.
 To ensure that the next memory address is located in the cache, ensure
 that the next array element to access is located very close of the last
 one accessed.
 When the CPU cache management engine sees your last access was on a border
 of a chunk it will load in the next chunk in a linear fashion based on
 the last accessed memory address.
\end_layout

\begin_layout Standard
Therefore the to gain the best possible performance when dealing with arrays,
 either utilise very small arrays that will fit into the level 1 cache,
 or only access arrays in a linear fashion row by row.
\end_layout

\begin_layout Standard
To illustrate these cache performance aspects, the application in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Array-Access-Performance"

\end_inset

 yeilds the results show in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Array-Access-Performance"

\end_inset

.
 As can be seen, when dealing with a 16384 
\begin_inset Formula $\times$
\end_inset

 16384 sized array (consuming 256MB), accessing the array row by row takes
 1.35 seconds, however accessing it column by column takes just over 16 seconds.
 This clearly demonstrates the caches hits/misses taking place and confirms
 the latencies expected by the cache misses.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

#include <time.h>
\end_layout

\begin_layout Plain Layout

#include <stdio.h> 
\end_layout

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

char array1[1024][1204]; 
\end_layout

\begin_layout Plain Layout

char array2[2048][2048]; 
\end_layout

\begin_layout Plain Layout

char array3[4096][4096]; 
\end_layout

\begin_layout Plain Layout

char array4[8192][8192]; 
\end_layout

\begin_layout Plain Layout

char array5[16384][16384];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Row by row.
\end_layout

\begin_layout Plain Layout

  clock_t start = clock();
\end_layout

\begin_layout Plain Layout

  for (int y = 0; y < 1024; y++) {
\end_layout

\begin_layout Plain Layout

    for (int x = 0; x < 1023; x++) {
\end_layout

\begin_layout Plain Layout

      array1[y][x] = array1[y][x + 1];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  clock_t end = clock();
\end_layout

\begin_layout Plain Layout

  long elapsed = (long) (end - start) / (CLOCKS_PER_SEC / 1000);
\end_layout

\begin_layout Plain Layout

  printf("1MB row time = %dmsec
\backslash
n", elapsed);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Column by Column
\end_layout

\begin_layout Plain Layout

  start = clock();
\end_layout

\begin_layout Plain Layout

  for (int x = 0; x < 1024; x++) {
\end_layout

\begin_layout Plain Layout

    for (int y = 0; y < 1023; y++) {
\end_layout

\begin_layout Plain Layout

      array1[y][x] = array1[y + 1][x];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  end = clock();
\end_layout

\begin_layout Plain Layout

  elapsed = (long) (end - start) / (CLOCKS_PER_SEC / 1000);
\end_layout

\begin_layout Plain Layout

  printf("1MB col time = %dmsec
\backslash
n", elapsed);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // ....
 <snip 4MB, 16MB and 64MB loops>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // 256MB Row by row.
\end_layout

\begin_layout Plain Layout

  start = clock();
\end_layout

\begin_layout Plain Layout

  for (int y = 0; y < 16384; y++) {
\end_layout

\begin_layout Plain Layout

    for (int x = 0; x < 16383; x++) {
\end_layout

\begin_layout Plain Layout

      array5[y][x] = array5[y][x + 1];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  end = clock();
\end_layout

\begin_layout Plain Layout

  elapsed = (long) (end - start) / (CLOCKS_PER_SEC / 1000);
\end_layout

\begin_layout Plain Layout

  printf("256MB row time = %dmsec
\backslash
n", elapsed);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Column by Column
\end_layout

\begin_layout Plain Layout

  start = clock();
\end_layout

\begin_layout Plain Layout

  for (int x = 0; x < 16384; x++) {
\end_layout

\begin_layout Plain Layout

    for (int y = 0; y < 16383; y++) {
\end_layout

\begin_layout Plain Layout

      array5[y][x] = array5[y + 1][x];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  end = clock();
\end_layout

\begin_layout Plain Layout

  elapsed = (long) (end - start) / (CLOCKS_PER_SEC / 1000);
\end_layout

\begin_layout Plain Layout

  printf("256MB col time = %dmsec
\backslash
n", elapsed);
\end_layout

\begin_layout Plain Layout

  return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Array Access Performance (C++)
\begin_inset CommandInset label
LatexCommand label
name "fig:Array-Access-Performance"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Row x Row
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Column x Column
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1024 
\begin_inset Formula $\times$
\end_inset

 1024 (1MB)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
~0 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
10 msec
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2048 
\begin_inset Formula $\times$
\end_inset

 2048 (4MB)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
20 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
220 msec
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
4096 
\begin_inset Formula $\times$
\end_inset

 4096 (16MB)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
90 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
830 msec
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
8192 
\begin_inset Formula $\times$
\end_inset

 8192 (64MB)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
350 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
4150 msec
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
16384 
\begin_inset Formula $\times$
\end_inset

 16384 (256MB)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1350 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
16080 msec
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Array Access Performance
\begin_inset CommandInset label
LatexCommand label
name "tab:Array-Access-Performance"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Array Traversal Methods
\end_layout

\begin_layout Standard
Any 3-dimension array, can be accessing in a variety of ways, including
 column-wise, row-wise and starting from the top to bottom, bottom to top,
 left to right and right to left.
\end_layout

\begin_layout Standard
As seen in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Array-Access-Performance"

\end_inset

, row-wise and column-wise access methods where undertaken in a top to bottom,
 left to right fashion.
 Formalised algorithms for row-wise and column-wise access are shown in
 Algorithms 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Row-wise-Traversal-of"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Column-wise-Traversal-of"

\end_inset

 respectively.
\end_layout

\begin_layout Standard
To change from a left to right, to a right to left access pattern, simply
 count down from the width value to 0 for columns.
 To change from top to bottom, to a bottom to top access pattern, simply
 count down from the height value to 0 for rows.
\end_layout

\begin_layout Standard
The same applies to any 2+ dimensional array, to change the direction of
 travsel, either change from counting from 0 to width/height to counting
 down from the width/height to 0, and vice versa.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require A source matrix $S$, with $n$ by $m$ elements.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Prints value in element of matrix
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{MatrixRowWiseTraversal}{$S, n, m$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$row$ = 0 to $m-1$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$column$ = 0 to $n-1$}
\end_layout

\begin_layout Plain Layout


\backslash
State {print $S[row][column]$}
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Row-wise Traversal of an Array
\begin_inset CommandInset label
LatexCommand label
name "alg:Row-wise-Traversal-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require A source matrix $S$, with $n$ by $m$ elements.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Prints value in element of matrix
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{MatrixColumnWiseTraversal}{$S, n, m$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$column$ = 0 to $n-1$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$row$ = 0 to $m-1$}
\end_layout

\begin_layout Plain Layout


\backslash
State {print $S[row][column]$}
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Column-wise Traversal of an Array
\begin_inset CommandInset label
LatexCommand label
name "alg:Column-wise-Traversal-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Diagonal Traversal of an Array
\end_layout

\begin_layout Standard
Diagonal traversal of an array is used for many areas including image analysis,
 map scanning, simple path finding methods
\begin_inset Foot
status open

\begin_layout Plain Layout
There are more comprehensive path finding techniques that utilise graphs/network
s, so these methods are not commonly used.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The one issue with this form of travesal through an array, are the underlying
 performance penalities that will occur due to cache misses, as each subsequent
 access to the array is non-linear.
 Like other array travesal techniques, diagonal traverse is an 
\series bold
O(n
\begin_inset script superscript

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset

)
\series default
 operation.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require A source matrix $S$, with $n$ by $m$ elements.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Prints value in element of matrix
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{MatrixDiagonalTraversal}{$S, n, m$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$x 
\backslash
leftarrow 0$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$y 
\backslash
leftarrow 0$}
\end_layout

\begin_layout Plain Layout


\backslash
While {
\backslash
texttt{True}}
\end_layout

\begin_layout Plain Layout


\backslash
State {$v 
\backslash
leftarrow x$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$w 
\backslash
leftarrow y$}
\end_layout

\begin_layout Plain Layout


\backslash
While {$v 
\backslash
geq 0 
\backslash
wedge w < m$}
\end_layout

\begin_layout Plain Layout


\backslash
State {print $S[w][v]$} 
\backslash
Comment {$S$[row][column]}
\end_layout

\begin_layout Plain Layout


\backslash
State {$v 
\backslash
leftarrow v-1$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$w 
\backslash
leftarrow w+1$}
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
If {$x < n -1$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$x 
\backslash
leftarrow x+1$}
\end_layout

\begin_layout Plain Layout


\backslash
ElsIf {$y < m -1$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$y 
\backslash
leftarrow y+1$}
\end_layout

\begin_layout Plain Layout


\backslash
Else
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
textbf{return}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Diagonal Traversal of an Array
\begin_inset CommandInset label
LatexCommand label
name "alg:Diagonal-Traversal-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
As described in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Diagonal-Traversal-of"

\end_inset

, the algorithm utilises two loops, with the first loop (
\family typewriter
while(true)
\family default
) determines the start position of the traverse, and the second while loop
 traverses the actual slice, starting from the top and moving downwards
 and to the left, (as denoted by the 
\begin_inset ERT
status open

\begin_layout Plain Layout

$v 
\backslash
leftarrow v-1$
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

{$w 
\backslash
leftarrow w+1$}
\end_layout

\end_inset

 operations).
\end_layout

\begin_layout Standard
The 
\family typewriter
if-else-if-else
\family default
 statements recalculate the new start position for the next travesal, until
 the new start position exceeds the bounds of the array, in which case the
 algorithm exits.
\end_layout

\begin_layout Standard
The algorithm as described, starts in the top left corner, and moves towards
 the bottom right of the array.
 To modify the algorithm to scan from other origins to opposite corner,
 the line to be altered is the access function that prints the current element
 in the array.
 The start at the various origins and traverse to the opposite corner, the
 following forms are needed for the print function:
\end_layout

\begin_layout Itemize
Top-left origin to bottom-right traverse: 
\begin_inset ERT
status open

\begin_layout Plain Layout

print $S[w][v]$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Bottom-left origin to top-right traverse: 
\begin_inset ERT
status open

\begin_layout Plain Layout

print $S[m-w-1][v]$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Top-right origin to bottom-left traverse: 
\begin_inset ERT
status open

\begin_layout Plain Layout

print $S[w][n-v-1]$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Bottom-right origin to top-left traverse: 
\begin_inset ERT
status open

\begin_layout Plain Layout

print $S[m-w-1][n-v-1]$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Diagonal-Traversal-of-1"

\end_inset

 demonstrates the top-left origin to bottom-right traversel on a 3 
\begin_inset Formula $\times$
\end_inset

 4 array, with each slice (or starting location) shown.
\end_layout

\begin_layout Standard
The order of traversel for the other origins would result in the following
 sequences based on the forms listed above:
\end_layout

\begin_layout Itemize
Top-left origin to bottom-right traverse: 
\family typewriter
a, b, d, c, e, g, f, h, j, i, k, l
\end_layout

\begin_layout Itemize
Bottom-left origin to top-right traverse: 
\family typewriter
j, k, g, l, h, d, i, e, a, f, b, c
\end_layout

\begin_layout Itemize
Top-right origin to bottom-left traverse: 
\family typewriter
c, b, f, a, e, i, d, h, l, g, k, j
\end_layout

\begin_layout Itemize
Bottom-right origin to top-left traverse: 
\family typewriter
l, k, i, j, h, f, g, e, c, d, b, a
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Array Diagonal.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Diagonal Traversal of an Array with a Top-Left Origin
\begin_inset CommandInset label
LatexCommand label
name "fig:Diagonal-Traversal-of-1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Diagonal-Traversal-of"

\end_inset

 demonstrates the implementation of the algorithm as described.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static void ArrayDiagonalTraverse(int[][] matrix, int width, int
 height){
\end_layout

\begin_layout Plain Layout

  int start_x = 0;
\end_layout

\begin_layout Plain Layout

  int start_y = 0;
\end_layout

\begin_layout Plain Layout

  int column;
\end_layout

\begin_layout Plain Layout

  int row;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Keep looping until exit condition.
\end_layout

\begin_layout Plain Layout

  while (true) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   // Initialise the starting location in the matrix for the current slice.
\end_layout

\begin_layout Plain Layout

   column = start_x;
\end_layout

\begin_layout Plain Layout

   row = start_y;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   // Traverse the current slice.
\end_layout

\begin_layout Plain Layout

   while (column >= 0 && row < height) {
\end_layout

\begin_layout Plain Layout

     System.out.printf("%d ", matrix[row][column]);
\end_layout

\begin_layout Plain Layout

     column--;
\end_layout

\begin_layout Plain Layout

     row++;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   // Update the start location for the next slice.
\end_layout

\begin_layout Plain Layout

   if (start_x < width - 1) {
\end_layout

\begin_layout Plain Layout

     start_x++;
\end_layout

\begin_layout Plain Layout

   } else if (start_y < height - 1) {
\end_layout

\begin_layout Plain Layout

     start_y++;
\end_layout

\begin_layout Plain Layout

   } else {
\end_layout

\begin_layout Plain Layout

     // Exit the method, as start locations are now out of matrix bounds.
\end_layout

\begin_layout Plain Layout

     break;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Diagonal Traversal of an Array (Java)
\begin_inset CommandInset label
LatexCommand label
name "fig:Diagonal-Traversal-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Array Rotation
\end_layout

\begin_layout Standard
As shown in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Array-Performance"

\end_inset

, the way that an array is accessed can effect the performance of your applicati
on.
 Methods to ensure that you can access an array row by row may require rotation
 of an array, or alternatively rotation of an array may be needed to utilise
 an algorithm or math function.
\end_layout

\begin_layout Standard
Any array rotation or mirroring function requires two copies of the array
 to be present at one time, the source array and target array.
 This must be considered in relation to the amount of memory required, as
 you effectively need double the memory requirement for either operation.
\end_layout

\begin_layout Standard
Both rotation and mirroring functions are 
\series bold
O(n
\begin_inset script superscript

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset

)
\series default
 operations, due to all array members must be accessed to complete the opeation
 successfully.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require A source matrix $S$, with $n$ by $m$ elements, with target matrix
 $T$, with $m$ by $n$ elements.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Matrix $T$ represents matrix $S$ rotated 90
\backslash
textdegree  clockwise.
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{RotateMatrixClockwise}{$S, T, n, m$}
\end_layout

\begin_layout Plain Layout


\backslash
State $f 
\backslash
leftarrow m-1$
\end_layout

\begin_layout Plain Layout


\backslash
For {$y$ = 0 to $m-1$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$x$ = 0 to $n-1$}
\end_layout

\begin_layout Plain Layout


\backslash
State $T[x][(f-y)] 
\backslash
leftarrow S[y][x]$ 
\backslash
Comment{$S$[row][column]}
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Array Rotation Clockwise
\begin_inset CommandInset label
LatexCommand label
name "alg:Array-Rotation-Clockwise"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require A source matrix $S$, with $n$ by $m$ elements, with target matrix
 $T$, with $m$ by $n$ elements.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Matrix $T$ represents matrix $S$ rotated 90
\backslash
textdegree  anti-clockwise.
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{RotateMatrixAntiClockwise}{$S, T, n, m$}
\end_layout

\begin_layout Plain Layout


\backslash
State $f 
\backslash
leftarrow n-1$
\end_layout

\begin_layout Plain Layout


\backslash
For {$x$ = 0 to $n-1$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$y$ = 0 to $m-1$}
\end_layout

\begin_layout Plain Layout


\backslash
State $T[(f-x)][y] 
\backslash
leftarrow S[y][x]$
\backslash
Comment{$S$[row][column]}
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Array Rotation AntiClockwise
\begin_inset CommandInset label
LatexCommand label
name "alg:Array-Rotation-AntiClockwise"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
Algoritms 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Array-Rotation-Clockwise"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Array-Rotation-AntiClockwise"

\end_inset

 depict both clockwise and anti-clock array rotation respectively.
 Simply, both perform substitution of x and y values for the target array.
 An additionl variable is needed to hold an offset, so that the new array
 offsets may be calculated correctly
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
While this is not necessary, it make for slightly cleaner code.
\end_layout

\end_inset

.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Array-Rotation-Diagram"

\end_inset

 shows the clockwise rotation operation in effect.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Array Rotation.eps
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Array Rotation
\begin_inset CommandInset label
LatexCommand label
name "fig:Array-Rotation-Diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Array-Clockwise-Rotation"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Array-Anti-Clockwise-Rotation"

\end_inset

 show implementations of clockwise and anticlockwise rotation respectively.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

public void ArrayRotateClockWise(E[][] source, E[][] target, int width,
 int height){
\end_layout

\begin_layout Plain Layout

  int factor = height-1;
\end_layout

\begin_layout Plain Layout

  for (int y = 0; y < height; y++) {
\end_layout

\begin_layout Plain Layout

    for (int x = 0; x < width; x++) {
\end_layout

\begin_layout Plain Layout

      target[x][(factor-y)] = source[y][x];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Array Clockwise Rotation (Java)
\begin_inset CommandInset label
LatexCommand label
name "fig:Array-Clockwise-Rotation"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

public void ArrayAntiRotateClockWise(E[][] source, E[][] T, int width, int
 height){
\end_layout

\begin_layout Plain Layout

  int factor = width-1;
\end_layout

\begin_layout Plain Layout

  for (int x = 0; x < width; x++) {
\end_layout

\begin_layout Plain Layout

    for (int y = 0; y < height; y++) {
\end_layout

\begin_layout Plain Layout

      target[(factor-x)][y] = source[y][x];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Array Anti-Clockwise Rotation (Java)
\begin_inset CommandInset label
LatexCommand label
name "fig:Array-Anti-Clockwise-Rotation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Performance of both of these implementations will suffer due to access not
 being performed in a row by row fashion, which limits the viability of
 the above algorithms.
 However they should still be considered and used, when the many operations
 are performed on the resulting array, rather than single use post rotation.
\end_layout

\begin_layout Paragraph
Sample Problem- Matrix Rotation 
\begin_inset CommandInset label
LatexCommand label
name "par:SP-Linear-Search-1"

\end_inset


\end_layout

\begin_layout Standard
Given a two dimension matrix measuring n 
\begin_inset Formula $\times$
\end_inset

 m, rotate the matrix in a clockwise direction.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
Input consists of one or more lines, with the first line being the size
 of the matrix to rotate in width and height.
 The width and height will be in a range between 0 and 79.
 The application should exit when the size given is 
\begin_inset Quotes eld
\end_inset

0 0
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The following lines denote the matrix to be rotated, with each element being
 a 1 or 0, separated by a space.
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
3 3
\begin_inset Newline newline
\end_inset

1 0 1
\begin_inset Newline newline
\end_inset

0 0 0
\begin_inset Newline newline
\end_inset

1 0 0
\begin_inset Newline newline
\end_inset

2 2
\begin_inset Newline newline
\end_inset

1 0
\begin_inset Newline newline
\end_inset

0 1
\begin_inset Newline newline
\end_inset

0 0 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
The output of each rotation should be the resultant matrix, without spaces
 between each column in the matrix.
 There must a blank line separating each resultant matrix.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
101
\begin_inset Newline newline
\end_inset

000
\begin_inset Newline newline
\end_inset

001
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

00
\begin_inset Newline newline
\end_inset

01
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Solution
\end_layout

\begin_layout Standard
A solution to the sample problem utilising an array rotation can be seen
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Solution-to-Array"

\end_inset

.
 The solution performs the following:
\end_layout

\begin_layout Enumerate
Reads in the width and height values.
 If these are not 0 and 0, continue the main loop body, otherwise exit.
\end_layout

\begin_layout Enumerate
If either of the values is 0, (indicating a 0 width or height), skip attempting
 to read in a matrix, and go back to step 1.
\end_layout

\begin_layout Enumerate
Create a new array of size width, height to hold integers.
 Read in the values from stdin, and fill in these values into the respective
 position within the array.
\end_layout

\begin_layout Enumerate
Create a new array to hold the result of the rotation.
 Rotate the array, and print the results.
 Goto step 1.
\end_layout

\begin_layout Standard
As this challenge is very simple, the only issue to account for is if either
 the width or height is given as 0 (zero), in which case a blank line should
 be returned.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

public class ArrayRotation {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Rotate an Array in a clockwise direction
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param source The source array
\end_layout

\begin_layout Plain Layout

   * @param target The target array
\end_layout

\begin_layout Plain Layout

   * @param width The width of the source array
\end_layout

\begin_layout Plain Layout

   * @param height The height of the target array
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void ArrayRotateClockWise(int[][] source, int[][] target,
 int width, int height) {
\end_layout

\begin_layout Plain Layout

    int factor = height - 1;
\end_layout

\begin_layout Plain Layout

    for (int y = 0; y < height; y++) {
\end_layout

\begin_layout Plain Layout

      for (int x = 0; x < width; x++) {
\end_layout

\begin_layout Plain Layout

        target[x][(factor - y)] = source[y][x];
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // get the size of the matrix to rotate.
\end_layout

\begin_layout Plain Layout

    String matrixSizeLine = in.nextLine();
\end_layout

\begin_layout Plain Layout

    Scanner matrixSize = new Scanner(matrixSizeLine);
\end_layout

\begin_layout Plain Layout

    int width = matrixSize.nextInt();
\end_layout

\begin_layout Plain Layout

    int height = matrixSize.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Keep reading in a matrix until exit condition 
\end_layout

\begin_layout Plain Layout

   while (!((width == 0) && (height == 0))) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Ignore the line if either width or height = 0.
\end_layout

\begin_layout Plain Layout

      if (!((width == 0) || (height == 0))) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Read in our matrix.
\end_layout

\begin_layout Plain Layout

        int[][] matrix = new int[height][width];
\end_layout

\begin_layout Plain Layout

        for (int count = 0; count < height; count++) {
\end_layout

\begin_layout Plain Layout

          String[] matrixLine = in.nextLine().split("
\backslash

\backslash
s+");
\end_layout

\begin_layout Plain Layout

          for (int element = 0; element < matrixLine.length; element++) {
\end_layout

\begin_layout Plain Layout

            matrix[count][element] = Integer.parseInt(matrixLine[element]);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Rotate the matrix and print.
\end_layout

\begin_layout Plain Layout

        int[][] target = new int[width][height];
\end_layout

\begin_layout Plain Layout

        ArrayRotateClockWise(matrix, target, width, height);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Print the resultant matrix.
\end_layout

\begin_layout Plain Layout

        for (int row = 0; row < width; row++) {
\end_layout

\begin_layout Plain Layout

          for (int column = 0; column < height; column++) {
\end_layout

\begin_layout Plain Layout

            System.out.print(target[row][column]);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          System.out.println();
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Print line between each matrix output
\end_layout

\begin_layout Plain Layout

        System.out.println();
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      // get the size of the matrix to rotate.
\end_layout

\begin_layout Plain Layout

      matrixSizeLine = in.nextLine();
\end_layout

\begin_layout Plain Layout

      matrixSize = new Scanner(matrixSizeLine);
\end_layout

\begin_layout Plain Layout

      width = matrixSize.nextInt();
\end_layout

\begin_layout Plain Layout

      height = matrixSize.nextInt();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Solution to Array Rotation Problem (Java)
\begin_inset CommandInset label
LatexCommand label
name "fig:Solution-to-Array"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Array Mirroring or Flipping
\end_layout

\begin_layout Standard
Array mirroring or flipping is a very simple technique, that simply requires
 a offset to be calculated from the current height or width value.
 Typically, to calculate the mirror location, we simple subtract the current
 source column (or row) value from the width (or height) size to calculate
 the target location.
 Algorithms 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Array-Mirror-Vertical"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Array-Mirror-Horizon"

\end_inset

 depict mirroring along the vertical axis and horizontal axis respectively.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require A source matrix $S$, with $n$ by $m$ elements, with target matrix
 $T$, with $n$ by $m$ elements.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Matrix $T$ represents matrix $S$ mirrored along a vertical axis
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{MirrorMatrixVeritcal}{$S, T, n, m$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$y$ = 0 to $m-1$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$x$ = 0 to $n-1$}
\end_layout

\begin_layout Plain Layout


\backslash
State $T[m-y][x] 
\backslash
leftarrow S[y][x]$ 
\backslash
Comment{$S$[row][column]}
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Mirror Array Along Vertical Axis
\begin_inset CommandInset label
LatexCommand label
name "alg:Array-Mirror-Vertical"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require A source matrix $S$, with $n$ by $m$ elements, with target matrix
 $T$, with $n$ by $m$ elements.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Matrix $T$ represents matrix $S$ mirrored along a horizontal axis
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{MirrorMatrixHorizontal}{$S, T, n, m$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$y$ = 0 to $m-1$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$x$ = 0 to $n-1$}
\end_layout

\begin_layout Plain Layout


\backslash
State $T[y][n-x] 
\backslash
leftarrow S[y][x]$ 
\backslash
Comment{$S$[row][column]}
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Mirror Array Along Horizontal Axis
\begin_inset CommandInset label
LatexCommand label
name "alg:Array-Mirror-Horizon"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As both of these algorithms access both the source and target arrays row
 by row, there should be no (or few) performance penalities due to cache
 misses.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Advanced Algorithms
\end_layout

\begin_layout Subsection
Simple Maths
\end_layout

\begin_layout Subsubsection
Greatest common divisor
\end_layout

\begin_layout Standard
The Greatest Common Divisor or Eucilidean algorithm was originally developed
 by Euclid of Alexandria in 3
\begin_inset script superscript

\begin_layout Plain Layout
rd
\end_layout

\end_inset

 BC, and computes the greatest common divisor of two non-negative, not-both-zero
 integers 
\family typewriter
m
\family default
 and 
\family typewriter
n
\family default
, that is the largest integer that divides both 
\family typewriter
m
\family default
 and 
\family typewriter
n
\family default
 
\shape italic
evenly
\shape default
.
\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
The Euclidean algorithm is based on the principle that the greatest common
 divisor of two numbers does not change if the smaller number is subtracted
 from the larger number.
 For if k, m, and n are integers, and k is a common factor of two integers
 A and B, then A=(n×k) and B=(m×k) implies A-B=(n-m)×k, therefore k is also
 a common factor of the difference.
 That k may also represent the greatest common divisor is proven below.
 For example, 21 is the GCD of 252 and 105 (252 = 12 × 21; 105 = 5 × 21);
 since 252 − 105 = (12 - 5) × 21 = 147, the GCD of 147 and 105 is also 21.
\end_layout

\begin_layout Standard
Since the larger of the two numbers is reduced, repeating this process gives
 successively smaller numbers until one of them is zero.
 When that occurs, the GCD is the remaining nonzero number.
 By reversing the steps in the Euclidean algorithm, the GCD can be expressed
 as a sum of the two original numbers each multiplied by a positive or negative
 integer, e.g., 21 = [5 × 105] + [(−2) × 252].
\end_layout

\begin_layout Standard
Iterative and recursive implementations of the algorithm are shown in Algorithms
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Euclidean-Algorithm-Iterative"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Euclidean-Algorithm-Recursive"

\end_inset

 respectively.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Euclid}{$m,n$}
\end_layout

\begin_layout Plain Layout


\backslash
While{$n
\backslash
not=0$}
\backslash
Comment{We have the answer if n is 0} 
\end_layout

\begin_layout Plain Layout


\backslash
State $r
\backslash
gets m
\backslash
bmod n$ 
\end_layout

\begin_layout Plain Layout


\backslash
State $m
\backslash
gets n$ 
\end_layout

\begin_layout Plain Layout


\backslash
State $n
\backslash
gets r$ 
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
textbf{return} $m$
\backslash
Comment{The gcd is m} 
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure 
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Euclidean Algorithm (Iterative)
\begin_inset CommandInset label
LatexCommand label
name "alg:Euclidean-Algorithm-Iterative"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Euclid}{$m,n$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$n = 0$}
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
textbf{return} $m$
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
textbf{return} gcd($n, m
\backslash
bmod n$)
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Euclidean Algorithm (Recursive)
\begin_inset CommandInset label
LatexCommand label
name "alg:Euclidean-Algorithm-Recursive"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
An implementation of the iterative form of the algorithm can be found in
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Euclidean-Algorithm-(Java)"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

public static int gcd(int m, int n) {
\end_layout

\begin_layout Plain Layout

  int r;
\end_layout

\begin_layout Plain Layout

  while (n != 0) {
\end_layout

\begin_layout Plain Layout

    r = m % n;
\end_layout

\begin_layout Plain Layout

    m = n;
\end_layout

\begin_layout Plain Layout

    n = r;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return m;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Euclidean Algorithm (Java)
\begin_inset CommandInset label
LatexCommand label
name "fig:Euclidean-Algorithm-(Java)"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem - GCD
\end_layout

\begin_layout Standard
Calculate the GCD of two integers.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
The first line of input will be 
\shape italic
N
\shape default
 (1 <= 
\shape italic
N
\shape default
 <= 1000), the number of test cases to run.
 On each of the next 
\shape italic
N
\shape default
 lines will be two integers m and n (0 <= 
\shape italic
m, n 
\shape default
<= 2
\begin_inset script superscript

\begin_layout Plain Layout
31
\end_layout

\end_inset

 - 1).
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
3 
\begin_inset Newline newline
\end_inset

12 60
\begin_inset Newline newline
\end_inset

60 24
\begin_inset Newline newline
\end_inset

3 5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
Output the greatest common denominator of 
\shape italic
m
\shape default
 and 
\shape italic
n
\shape default
, one value on each line.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
12
\begin_inset Newline newline
\end_inset

12
\begin_inset Newline newline
\end_inset

1
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Solution
\end_layout

\begin_layout Standard
The solution to this problem utilised Euclid's GCD algorithm can be seen
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Solution-to-GCD"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

public class GCD {
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Compute the Greatest Common Divisor
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param m number 1, greater or equal to 0.
\end_layout

\begin_layout Plain Layout

   * @param n number 2, greater or equal to 0.
\end_layout

\begin_layout Plain Layout

   * @return the GCD
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static int EuclidGCD(int m, int n) {
\end_layout

\begin_layout Plain Layout

    int r;
\end_layout

\begin_layout Plain Layout

    while (n != 0) {
\end_layout

\begin_layout Plain Layout

      r = m % n;
\end_layout

\begin_layout Plain Layout

      m = n;
\end_layout

\begin_layout Plain Layout

      n = r;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return m;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // get first line and get the number of cases to test.
\end_layout

\begin_layout Plain Layout

    int caseCount = Integer.parseInt(in.nextLine());
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Keep reading each line while caseCount > 0
\end_layout

\begin_layout Plain Layout

    while (caseCount-- > 0) {
\end_layout

\begin_layout Plain Layout

      String line = in.nextLine();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // extract numbers ints
\end_layout

\begin_layout Plain Layout

      Scanner sc = new Scanner(line);
\end_layout

\begin_layout Plain Layout

      int a = sc.nextInt();
\end_layout

\begin_layout Plain Layout

      int b = sc.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Output the gcd for the two given numbers.
\end_layout

\begin_layout Plain Layout

      System.out.printf("%d%n", EuclidGCD(a,b));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Solution to GCD Problem (Java)
\begin_inset CommandInset label
LatexCommand label
name "fig:Solution-to-GCD"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Whilst this solution/challenge is rather simple, the following test cases
 must be considered:
\end_layout

\begin_layout Enumerate
One or both values are 0 (zero).
\end_layout

\begin_layout Enumerate
There will be longer run times if one or both numbers are primes.
 (The GCD is 1 in this case).
\end_layout

\begin_layout Enumerate
The input range is 
\begin_inset Formula $0<m<2^{31}-1$
\end_inset

, which requires the use of at least a signed 32bit number (typically 
\family typewriter
int
\family default
 on all platforms).
\end_layout

\begin_layout Subsubsection
Sieve of Eratosthenes (prime number generation)
\end_layout

\begin_layout Subsection
String based algorithms
\end_layout

\begin_layout Standard
substring search
\end_layout

\end_body
\end_document
