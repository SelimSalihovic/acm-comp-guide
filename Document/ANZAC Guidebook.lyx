#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{pdflscape}
\usepackage{datetime}
\newdateformat{shortdatem}{%
\twodigit{\THEDAY}-\shortmonthname--\THEYEAR}
\shortdatem
\usepackage[bottom]{footmisc}
\lhead{ANZAC Competition Guide}
\rhead{}
\lfoot{}
\rfoot{\small\today}
\renewcommand{\footrulewidth}{0.4pt}
\usepackage{tocloft}
\renewcommand\cftsecleader{\bfseries\cftdotfill\cftdotsep}
\renewcommand\cftsecfont{\normalfont}
\renewcommand\cftsecpagefont{\normalfont}
\renewcommand{\cftsecleader}{\cftdotfill{\cftsecdotsep}}
\renewcommand\cftsecdotsep{\cftdot}
\renewcommand\cftsubsecdotsep{\cftdot}
\renewcommand\cftsecdotsep{\cftdot}
\renewcommand\cftsubsubsecdotsep{\cftdot}
\renewcommand\cftparadotsep{\cftdot}
\sloppy
\tiny
\usepackage{colortbl}
\definecolor{lightgray}{gray}{0.95}
\definecolor{dkgray}{gray}{0.7}
\renewcommand*\arraystretch{1.5}
\exhyphenpenalty=10000
\hyphenpenalty=10000
\usepackage{xcolor}
\usepackage{algpseudocode}
\renewcommand{\ps@plain}{\pagestyle{fancy}}
\algrenewcommand\algorithmicrequire{\textbf{Input}}
\algrenewcommand\algorithmicensure{\textbf{Output}}
\usepackage[english]{babel}
\renewcommand\lstlistlistingname{List of Source Code Implementations and Solutions}
\end_preamble
\use_default_options false
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman charter
\font_sans default
\font_typewriter lmtt
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 80

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "ANZAC Guidebook"
\pdf_author "Darran Kartaschew"
\pdf_keywords "ACM-ICPC, ANZAC"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 0
\use_mhchem 0
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 5
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\listings_params "basicstyle={\small,\ttfamily},captionpos=b,frame=single,language=Java,numberbychapter=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict true
\end_header

\begin_body

\begin_layout Title
Guide for Advanced Algorithms for Australia and New Zealand Algorithmics
 & Computing League Competition.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename images/by-sa.eps

\end_inset


\end_layout

\begin_layout Standard
This work is licensed under the Creative Commons Attribution-ShareAlike
 3.0 Australia License.
 To view a copy of this license, visit 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://creativecommons.org/licenses/by-sa/3.0/au/
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Prepared By: Darran Kartaschew
\end_layout

\begin_layout Standard
Document Version: 1.0
\end_layout

\begin_layout Standard
Last Updated on: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstlistoflistings
\end_layout

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
About the Competition
\end_layout

\begin_layout Standard
The programming contests held in Universities across Australia and New Zealand,
 are part of the Australia and New Zealand Algorithmics & Computing League
 Competition and is used in conjunction with the ACM-ICPC competition.
 These competitions are aimed at challenging students in completing a set
 number of problems within the allocated time slot (typically 5 hours),
 with the winners in each location given some prestige.
\end_layout

\begin_layout Standard
In recent years teams from not only Universities taken part, but teams from
 TAFE and other educational institutions have taken part in the competition.
 Additionally teams outside of Australia and New Zealand such as those from
 the Phillipines have also taken part.
\end_layout

\begin_layout Subsubsection
ANZAC 2012
\end_layout

\begin_layout Standard
The ANZAC 2012 competition takes place in 5 to 6 rounds each year and are
 sponsored by a local University and associated Faculty member.
 Typically, a single round will run for 5 hours (starting at midday for
 East Coast Australia), and at least 6 problems will be presented for completion
 by students.
\end_layout

\begin_layout Standard
All challenges require some form of problem solving skills or techniques
 and do require at least a basic understanding of different algorithms in
 order to complete the challenges, let alone to be competitive in the competitio
n.
\end_layout

\begin_layout Standard
In order to compete within the competition it is recommended that 3 students
 form a team to work together on solving the challenges.
 Each team is only given 1 computer to work on, and all reference material
 brought into the competion must be in printed form only
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The printed material requirement is to ensure that no copying of existing
 source code is allowed, only transcription of source code from written
 form
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Scores are awarded for completed challenges (typically 1 point), and the
 time elasped from the start of the competition to accepted submission of
 the challenge is also noted.
 If a submitted challenge fails, then a 20 minute time penalty to added
 to the teams total time value.
\end_layout

\begin_layout Standard
As a minimum each contest will allow either C/C++ and Java, however additional
 programming languages may also be included.
 Typically C# has been allowed in recent years, due to the popularity of
 the language, especially as it is taught farily early in a students undergradua
te degree.
\end_layout

\begin_layout Standard
Overall, the competition is designed to be challenging, fun and also students
 to advance within their field of study.
 It is also a great way to network amongst other equally capable students
 within the programming field.
\end_layout

\begin_layout Subsubsection
ACM-ICPC
\end_layout

\begin_layout Standard
The ACM-ICPC competition is an International level competition sponsored
 by IBM, ACM and Upsilon Pi Epsilon, and contestants who make the world
 finals are often sort after by industry for later employment, as well as
 bringing notoriety and prestige to the University or College to which the
 constestants originate from.
 The regional component of the competition is typically held as the last
 ANZAC competition, as both competitions share the same tools, resources
 and rules.
\end_layout

\begin_layout Standard
The top two teams from each region (and in the case of Australia and New
 Zealand, the top team from Australia and top team from New Zealand), attend
 the International competition held annually in late March/early April in
 an overseas location.
 The 2012 ACM-ICPC Finals consisting of teams from all over the world was
 held in Warsow, Poland.
\end_layout

\begin_layout Subsection
About this Guide
\end_layout

\begin_layout Standard
This guide is designed to give students some background knowledge of the
 environments utilised within the competition, as well as information on
 various algorithms needed to solve problems.
 The included algorithms are by no means exhaustive, however represent the
 bulk of the algorithms that will be useful in completion of challenges.
\end_layout

\begin_layout Standard
This guide book is split into multiple parts:
\end_layout

\begin_layout Enumerate
Basic Source Templates that cover the basic frameworks needed for challenge
 submissions.
\end_layout

\begin_layout Enumerate
Basic Algorithms and techniques.
\end_layout

\begin_layout Enumerate
Advanced Algorithms.
\end_layout

\begin_layout Standard
All algorithms described will include:
\end_layout

\begin_layout Enumerate
A short statement on the algorithm and the intended uses, as well as other
 possible uses.
\end_layout

\begin_layout Enumerate
The pseudocode for the algorithm.
\end_layout

\begin_layout Enumerate
An actual implementation in at least 1 programming language.
 This will typically be in the form of a function or method call.
\end_layout

\begin_layout Enumerate
An example challenge that requires the use of the algorithm.
\end_layout

\begin_layout Enumerate
An example solution to the challenge.
\end_layout

\begin_layout Standard
Throughout the guide there will be notes on performance aspects of each
 algorithm, as well as helpful utility functions to make better use of the
 algorithm implementations.
 One example will be a function to convert an Adjancy List into an Adjancy
 Matrix used for different graph based algorithms.
\end_layout

\begin_layout Subsubsection
Development System
\end_layout

\begin_layout Standard
The applications and source code snippets developed for this guide were
 performed on the following hardware and software combinations as noted
 below.
 Any performance measurements, in particular times required for certain
 functions reflect times as acquired with listed hardware and software combinati
ons.
 Performance measurements will vary accordingly with different hardware
 and software combinations when performing your own performance measurements.
\end_layout

\begin_layout Paragraph
Hardware
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
HP xw4600 Workstation, with:
\end_layout

\begin_layout Itemize
Intel Core 2 Quad, Q9400 @ 2.66GHz (Quad core, 2.66GHz, 6MB L2 cache, 64bit
 enabled).
\end_layout

\begin_layout Itemize
4GB RAM (4 × 1GB Reg ECC DDR2-800Mhz)
\end_layout

\begin_layout Itemize
250GB 7200rpm HDD + 2TB 7200rpm HDD
\end_layout

\begin_layout Itemize
nVidia Quadro FX580 graphics card.
\end_layout

\begin_layout Itemize
Dual 20
\begin_inset Quotes erd
\end_inset

 LCD Monitors (1680x1050 resolution).
\end_layout

\begin_layout Paragraph
Software
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Oracle Solaris 11 11/11, with:
\end_layout

\begin_layout Itemize
Solaris Studio 12.3 (C++)
\end_layout

\begin_layout Itemize
Netbeans 7.2 (Java)
\end_layout

\begin_layout Itemize
Java 6 JDK 1.6u26 or Java 7 JDK 1.7u5
\end_layout

\begin_layout Itemize
gcc 4.5.2 (C++)
\end_layout

\begin_layout Standard
Microsoft Windows XP x64, with:
\end_layout

\begin_layout Itemize
Mircosoft Visual Studio 2010 (C# and C++)
\end_layout

\begin_layout Itemize
.NET Frameowrk 2.0
\end_layout

\begin_layout Subsection
License
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename images/by-sa.eps

\end_inset


\end_layout

\begin_layout Standard
This work is licensed under the Creative Commons Attribution-ShareAlike
 3.0 Australia License.
 To view a copy of this license, visit 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://creativecommons.org/licenses/by-sa/3.0/au/
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
This means you are free:
\end_layout

\begin_layout Itemize
to copy, distribute, display, and perform the work 
\end_layout

\begin_layout Itemize
to make derivative works 
\end_layout

\begin_layout Itemize
to make commercial use of the work 
\end_layout

\begin_layout Standard
Under the following conditions:
\end_layout

\begin_layout Itemize

\series bold
Attribution
\series default
 — You must give the original author credit.
\end_layout

\begin_layout Itemize

\series bold
Share Alike
\series default
 — If you alter, transform, or build upon this work, you may distribute
 the resulting work only under a licence identical to this one.
 
\end_layout

\begin_layout Standard
With the understanding that:
\end_layout

\begin_layout Itemize

\series bold
Waiver
\series default
 — Any of the above conditions can be waived if you get permission from
 the copyright holder.
 
\end_layout

\begin_layout Itemize

\series bold
Public Domain
\series default
 — Where the work or any of its elements is in the public domain under applicabl
e law, that status is in no way affected by the license.
 
\end_layout

\begin_layout Itemize

\series bold
Other Rights
\series default
 — In no way are any of the following rights affected by the license: 
\end_layout

\begin_deeper
\begin_layout Itemize
Your fair dealing or fair use rights, or other applicable copyright exceptions
 and limitations; 
\end_layout

\begin_layout Itemize
The author's moral rights; 
\end_layout

\begin_layout Itemize
Rights other persons may have either in the work itself or in how the work
 is used, such as publicity or privacy rights.
 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Notice
\series default
 — For any reuse or distribution, you must make clear to others the licence
 terms of this work.
 
\end_layout

\begin_layout Standard
Original Author endorsed waivers:
\end_layout

\begin_layout Itemize
The original author however allows use of source code snippets, that is,
 source code written in the languages of C++, C# or Java contained within
 this guide for any purpose, without attribution.
 This waiver does not extend to the text, nor other materials contained
 within the guide.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Supported Competition Environments
\end_layout

\begin_layout Standard
The guide will focus on Java being developed in Eclipse, and C# being developed
 in Visual Studio.
 However there will be examples in C++ when appropriate.
 Most other IDEs have similar options, when used for development, debugging
 and/or profiling.
\end_layout

\begin_layout Subsection
PC^2
\end_layout

\begin_layout Standard
The primary tool that allow students to submit their challenge entries to
 be judged in the PC^2 Software Suite.
 The application itself is developed by California State University, Sacramento
 for the purposes of programming competitions and has been adopted by both
 the Australia and New Zealand Algorithmics & Computing League (ANZACL)
 and ACM for their respective competitions.
\end_layout

\begin_layout Standard
An example of the Login Interface is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PC^2-Login-Screen"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Screenshot-PC^2 Login.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
PC^2 Login Screen
\begin_inset CommandInset label
LatexCommand label
name "fig:PC^2-Login-Screen"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once logged into the system, the following options are typically available:
\end_layout

\begin_layout Description
Submit
\begin_inset space ~
\end_inset

Run Allows you to submit a challenge entry to be judged, or alternatively
 to test your entry against some supplied sample data.
\end_layout

\begin_layout Description
View
\begin_inset space ~
\end_inset

Runs Allows you to view a history of submissions made to the judges.
\end_layout

\begin_layout Description
Request
\begin_inset space ~
\end_inset

Clarification Allows you to request a clarification from the judges about
 one of the challenges.
\end_layout

\begin_layout Description
View
\begin_inset space ~
\end_inset

Clarifications Allows you to see the responses to your requests for clarificatio
ns.
\end_layout

\begin_layout Description
Options Allows you to access various options that control the clients operation.
 However this tab, only allows you to view the operational log of the client.
\end_layout

\begin_layout Standard
Most of the operations on the various areas are self explanatory, so won't
 be covered in detail.
 The main screen that competitors will utilise is the 
\series bold
Submit Run
\series default
 tab as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PC^2-Client-Submit"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Screenshot-PC^2 Team TEAM 3 (Site 1) [STARTED] Build 2136.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
PC^2 Client Submit Run Tab
\begin_inset CommandInset label
LatexCommand label
name "fig:PC^2-Client-Submit"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This screen has two main modes of operation, allow a competitor to test
 their submission against some sample input, or submit their source code
 to be judged.
 Both have similar operations, except the test has one additional step.
\end_layout

\begin_layout Subsubsection
Submit Run
\end_layout

\begin_layout Standard
To submit a run for judging, perform the following steps:
\end_layout

\begin_layout Enumerate
From the Problem dropdown list select the challenge that you are attempting.
\end_layout

\begin_layout Enumerate
From the Language dropdown list select the programming language in the submissio
n is written in.
\end_layout

\begin_layout Enumerate
Use the Select button to select the source code file for the submission.
 (Note: A single Source Code file is required, do not attempt to submit
 data files or executable files).
\end_layout

\begin_layout Enumerate
Use the Add Button to select any additional files needed to complete your
 submission.
 (Note: This is rarely needed).
\end_layout

\begin_layout Enumerate
Click on Submit, and Yes to confirm to have your submission judged.
\end_layout

\begin_layout Enumerate
You will receive a confirmation dialog confirming that your entry has been
 submitted.
\end_layout

\begin_layout Standard
Once you entry has been judged you will receive one of the following confirmatio
ns:
\end_layout

\begin_layout Itemize
Yes - Your submission was successful in passing all tests.
 Congratulations, you have been awarded one point.
\end_layout

\begin_layout Itemize
No - Your submission failed one or more tests.
\end_layout

\begin_layout Itemize
Time Overrun - Your submission took more time that allowed for the challenge.
\end_layout

\begin_layout Standard
An example Judge's Response Dialog is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Sample-Judge's-Response"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Screenshot-Run Judgement Received.png
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sample Judge's Response
\begin_inset CommandInset label
LatexCommand label
name "fig:Sample-Judge's-Response"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Submit Test
\end_layout

\begin_layout Standard
Before your submit your solution to be judged it is 
\series bold
highly recommended
\series default
 that you perform a test run on your submission first, due to possible differenc
es between the environment you utilised for development and the environment
 in which your submission will be run on the judges machine.
\end_layout

\begin_layout Standard
To test your submission first, perform the following steps:
\end_layout

\begin_layout Enumerate
Ensure that your source code file and the sample data files are in the same
 folder/directory on your system.
\end_layout

\begin_layout Enumerate
From the Problem dropdown list select the challenge that you are attempting.
\end_layout

\begin_layout Enumerate
From the Language dropdown list select the programming language in the submissio
n is written in.
\end_layout

\begin_layout Enumerate
Use the Select button to select the source code file for the submission.
 (Note: A single Source Code file is required, do not attempt to submit
 data files or executable files).
\end_layout

\begin_layout Enumerate
Use the Add Button to select any additional files needed to complete your
 submission.
 (Note: This is rarely needed).
\end_layout

\begin_layout Enumerate
Click on 
\begin_inset Quotes eld
\end_inset

Test
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Enumerate
Select the appropriate sample input file in the open dialog box.
 (Typically the sample input fille will be 
\family typewriter
<challengename>_sample_in.txt
\family default
 ).
\end_layout

\begin_layout Enumerate
Wait for the output dialog and compare to the expected output.
\end_layout

\begin_layout Enumerate
If you are happy with your submission, then submit your solution for judging,
 by clicking on 
\begin_inset Quotes eld
\end_inset

Submit
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Scoring
\end_layout

\begin_layout Standard
If you solve a problem, you get one point for solving the problem.
 The time of submission since the start of the competition is also recorded.
 A submission which is judged to be not correct attracts a time penalty,
 usually twenty minutes, but the penalty does not apply until the problem
 has been judged correct.
\end_layout

\begin_layout Standard
The ordering of the teams is based on the number of correct problems descending
 and then on the total amount of time used by the team ascending.
 An example of how the total time is calculated is given in the next section.
\end_layout

\begin_layout Subsection
Software Languages
\end_layout

\begin_layout Standard
Currently the competition support the following software development languages
 with some variations between regional areas: Java, C++ and C#.
\end_layout

\begin_layout Subsubsection
Java
\end_layout

\begin_layout Standard
Java is compiled utilising the Oracle Java 6SE JRE implementation, however
 future competitions may migrate to Java 7SE as Java 7 becomes more popular.
 (This guide will target the Oracle Java 6 SE JRE).
\end_layout

\begin_layout Standard
By default the competition will utilise the 32bit JRE, however this may
 vary as needed between each region.
 Additionally the Java compiler and JVM are run using default settings only.
 
\end_layout

\begin_layout Subsubsection
C++
\end_layout

\begin_layout Standard
C++ (and by extension C) is compiled with an POSIX compatible compiler,
 typically being mingw on Windows.
 mingw utilises the GNU GCC compiler suite, and offers a near complete POSIX
 environment including the C++ STL.
\end_layout

\begin_layout Standard
It should be noted, that in some instances the Microsoft Visual Studio C++
 compiler has been used within the competition, so it is best to check with
 the local staff supporting the competition which compiler will be utilised.
 
\end_layout

\begin_layout Standard
Irrespective of the C++ compiler and/or environment, it should be noted
 that the default compiler settings are utilised through the competition,
 so features including optimisation flags or 64bit operation are not enabled.
\end_layout

\begin_layout Standard
This guide will target a 100% pure POSIX environment.
 
\end_layout

\begin_layout Subsubsection
C#
\end_layout

\begin_layout Standard
C# will typically be compiled by Microsoft Visual Studio 2010 with the .NET
 2.0 Framework.
 However there may be variations to this, so it is best to check with the
 local staff supporting the competition which compiler and/or .NET framework
 will be utilised.
\end_layout

\begin_layout Subsection
IDEs
\end_layout

\begin_layout Standard
At the moment there are no official supported IDEs utilised by the competition,
 however the majority of contestants utilise either Eclipse and/or Visual
 Studio.
 
\end_layout

\begin_layout Standard
Other IDEs or Editors commonly utilised by competitors include NetBeans
 (Java, C++), Code::Blocks (C++) and Notepad++ (Java, C#, C++).
\end_layout

\begin_layout Subsubsection
Eclipse
\end_layout

\begin_layout Standard
Eclipse may be utilised to develop either Java applications or C++ applications
 (on provision the appropriate eclipse plugins for C++ are installed, and
 a compatible C++ compiler such as mingw is also installed).
\end_layout

\begin_layout Standard
There is no special configuration for Eclipse to be utilised within the
 competition.
 As all competition entries operate within a command line only interface
 there is no requirement for any GUI builder plugins to be present.
\end_layout

\begin_layout Standard
To utilise Eclipse for Java development, perform the following steps:
\end_layout

\begin_layout Enumerate
Start Eclipse, and switch to a Workspace that is empty, or has been designated
 for use for competition.
 (Use 
\family typewriter
File
\family default
 -> 
\family typewriter
Switch Workspace 
\family default
to move).
\end_layout

\begin_layout Enumerate
In the 
\family typewriter
File
\family default
 menu, select 
\family typewriter
New
\family default
.
\end_layout

\begin_layout Enumerate
In the 
\family typewriter
New
\family default
 dialog box, select 
\family typewriter
Java Project
\family default
.
 Click on 
\family typewriter
Next
\family default
.
\end_layout

\begin_layout Enumerate
Enter any name for the project name.
 Leave all other settings as default.
\end_layout

\begin_layout Enumerate
Click on 
\family typewriter
Finish
\family default
.
 This will create a basic project that can be used for developing submissions.
\end_layout

\begin_layout Enumerate
In the Package Explorer pane, right click on the 
\family typewriter
'src'
\family default
 package, and select 
\family typewriter
New
\family default
 -> 
\family typewriter
Java Class
\family default
.
 This will be the first submission that you will work on.
 When developing further submissions, simple start at this point and following
 the remaining steps.
\end_layout

\begin_layout Enumerate
The in 
\family typewriter
New Java Class
\family default
 dialog, enter in the challenge name in the
\family typewriter
 Name:
\family default
 field, and click on 
\begin_inset Quotes eld
\end_inset


\family typewriter
public static void main(String[] args)
\family default

\begin_inset Quotes erd
\end_inset

 to select this option.
 Leave all other options as default, and click on 
\family typewriter
Finish
\family default
.
 (See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Eclipse---New-1"

\end_inset

).
\end_layout

\begin_layout Enumerate
The new submission Java file will open in the file pane.
 (See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Eclipse---New-1"

\end_inset

)
\end_layout

\begin_layout Enumerate
You are now reading to develop you submission.
\end_layout

\begin_layout Standard
All debugging facilities may be utilised within Eclipse with no restrictions.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Eclipse1.png
	width 75text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Eclipse - New Java Class
\begin_inset CommandInset label
LatexCommand label
name "fig:Eclipse---New"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Eclipse2.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Eclipse - New Java Application
\begin_inset CommandInset label
LatexCommand label
name "fig:Eclipse---New-1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
One item to note with the file structure of Eclipse and essentially all
 Java application development, you will need to note the exact location
 of the source files so are able to find them later in order to submit your
 solutions.
 
\end_layout

\begin_layout Standard
Using the example in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Eclipse---New"

\end_inset

, note the 
\begin_inset Quotes eld
\end_inset


\family typewriter
Source Folder
\family default

\begin_inset Quotes erd
\end_inset

 location, this is the location that your submissions will be located in,
 in this case 
\family typewriter
ACM/src/AddingNumbers.java
\family default
.
\end_layout

\begin_layout Standard
When testing your submission with PC^2 you will be required to either:
\end_layout

\begin_layout Enumerate
Copy your source code file to the same location as sample input files, or
\end_layout

\begin_layout Enumerate
Copy the sample input files into the same location as the source code file.
\end_layout

\begin_layout Subsubsection
Visual Studio
\end_layout

\begin_layout Standard
Visual Studio is capable of working with a number of programming languages,
 including C# and C++.
 This guide will cover working with both langauges, noting the differences
 between the two.
\end_layout

\begin_layout Paragraph
C#
\end_layout

\begin_layout Standard
There is no special configuration for Visual Studio to be utilised within
 the competition.
 As all competition entries operate within a command line only interface
 there is no requirement for any GUI builder plugins to be present.
\end_layout

\begin_layout Standard
To utilise Visual Studio for C# development, perform the following steps:
\end_layout

\begin_layout Enumerate
Start Visual Studio.
\end_layout

\begin_layout Enumerate
If you receive a 
\family typewriter

\begin_inset Quotes eld
\end_inset

Select Development Language
\family default

\begin_inset Quotes erd
\end_inset

 dialog, select 
\family typewriter
Microsoft C#
\family default
.
\end_layout

\begin_layout Enumerate
Select 
\family typewriter

\begin_inset Quotes eld
\end_inset

New Project
\family default

\begin_inset Quotes erd
\end_inset

 from the Start Page, or alternatively from the 
\family typewriter
File
\family default
 menu.
\end_layout

\begin_layout Enumerate
In the 
\begin_inset Quotes eld
\end_inset


\family typewriter
New Project
\family default

\begin_inset Quotes erd
\end_inset

 dialog, ensure that:
\end_layout

\begin_deeper
\begin_layout Enumerate

\family typewriter
Visual C#
\family default
 > 
\family typewriter
Windows
\family default
 is selected in the Installed Templates pane.
\end_layout

\begin_layout Enumerate

\family typewriter
Console Application - Visual C#
\family default
 is selected in the Application Type pane.
\end_layout

\begin_layout Enumerate

\family typewriter
.NET Framework 2.0
\family default
 is selected in the .NET Framework dropdown.
\end_layout

\begin_layout Enumerate
Enter the name of the challenge in the 
\family typewriter
Name:
\family default
 field.
\end_layout

\begin_layout Enumerate
Note the location in which the project is being created.
\end_layout

\begin_layout Enumerate
Click on
\family typewriter
 OK
\family default
 to build the project.
 (See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Visual-Studio-C"

\end_inset

)
\end_layout

\end_deeper
\begin_layout Enumerate
The new 
\family typewriter
Program.cs
\family default
 file will be opened and displayed in the File Pane.
 (See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Visual-Studio-C-1"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/VS_1.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Visual Studio C# New Project
\begin_inset CommandInset label
LatexCommand label
name "fig:Visual-Studio-C"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/VS_2.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Visual Studio C# Program.cs
\begin_inset CommandInset label
LatexCommand label
name "fig:Visual-Studio-C-1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
When testing your submission with PC^2 you will be required to either:
\end_layout

\begin_layout Enumerate
Copy your source code file to the same location as sample input files, or
\end_layout

\begin_layout Enumerate
Copy the sample input files into the same location as the source code file.
\end_layout

\begin_layout Paragraph
C++
\end_layout

\begin_layout Standard
To utilise Visual Studio for C++ development, perform the following steps:
\end_layout

\begin_layout Enumerate
Start Visual Studio.
\end_layout

\begin_layout Enumerate
If you receive a 
\family typewriter

\begin_inset Quotes eld
\end_inset

Select Development Language
\family default

\begin_inset Quotes erd
\end_inset

 dialog, select 
\family typewriter
Microsoft C
\family default
++.
\end_layout

\begin_layout Enumerate
Select 
\family typewriter

\begin_inset Quotes eld
\end_inset

New Project
\family default

\begin_inset Quotes erd
\end_inset

 from the Start Page, or alternatively from the 
\family typewriter
File
\family default
 menu.
\end_layout

\begin_layout Enumerate
In the 
\begin_inset Quotes eld
\end_inset


\family typewriter
New Project
\family default

\begin_inset Quotes erd
\end_inset

 dialog, ensure that:
\end_layout

\begin_deeper
\begin_layout Enumerate

\family typewriter
Visual C++
\family default
 > 
\family typewriter
Win32
\family default
 is selected in the Installed Templates pane.
\end_layout

\begin_layout Enumerate

\family typewriter
Win32 Console Application - Visual C++
\family default
 is selected in the Application Type pane.
\end_layout

\begin_layout Enumerate

\family typewriter
.NET Framework 2.0
\family default
 is selected in the .NET Framework dropdown.
\end_layout

\begin_layout Enumerate
Enter the name of the challenge in the 
\family typewriter
Name:
\family default
 field.
\end_layout

\begin_layout Enumerate
Note the location in which the project is being created.
\end_layout

\begin_layout Enumerate
Click on
\family typewriter
 OK
\family default
 to build the project.
 (See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Visual-Studio-C-2"

\end_inset

)
\end_layout

\end_deeper
\begin_layout Enumerate
The Win32 Application Wizard will run.
 Select Next on the Wizard Welcome screen.
\end_layout

\begin_layout Enumerate
On the Applications Settings dialog, enusre that 
\begin_inset Quotes eld
\end_inset


\family typewriter
Console Application
\family default

\begin_inset Quotes erd
\end_inset

 is checked, and 
\begin_inset Quotes eld
\end_inset


\family typewriter
Precompiled Headers
\family default

\begin_inset Quotes erd
\end_inset

 is unchecked.
 (See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Visual-Studio-C++"

\end_inset

).
 Click on 
\family typewriter
Finish
\family default
 to build the project.
\end_layout

\begin_layout Enumerate
The new 
\family typewriter
<Application>.cpp
\family default
 file will be opened and displayed in the File Pane.
 (See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Visual-Studio-C-1-1"

\end_inset

)
\end_layout

\begin_layout Enumerate
The following changes are recommended to the main source file to ensure
 maximum platform compatibility:
\end_layout

\begin_deeper
\begin_layout Enumerate
Add 
\begin_inset Quotes eld
\end_inset


\family typewriter
using namespace std;
\family default

\begin_inset Quotes erd
\end_inset

 before any included headers.
\end_layout

\begin_layout Enumerate
Remove or comment out the 
\begin_inset Quotes eld
\end_inset


\family typewriter
#include 
\begin_inset Quotes eld
\end_inset

stdafx.h
\begin_inset Quotes erd
\end_inset


\family default

\begin_inset Quotes erd
\end_inset

 line
\end_layout

\begin_layout Enumerate
Add 
\begin_inset Quotes eld
\end_inset


\family typewriter
#include <stdio.h>
\family default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\family typewriter
#include <iostream>
\family default

\begin_inset Quotes erd
\end_inset

 to ensure POSIX compatibility.
\end_layout

\begin_layout Enumerate
Change 
\family typewriter
int _tmain(int argc, _TCHAR* argv[])
\family default

\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

 to 
\begin_inset Quotes eld
\end_inset


\family typewriter
int main()
\family default

\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
You are now ready to develop your submissions.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/VS_3.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Visual Studio C++ New Project
\begin_inset CommandInset label
LatexCommand label
name "fig:Visual-Studio-C-2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/VS_4.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Visual Studio C++ Project Options
\begin_inset CommandInset label
LatexCommand label
name "fig:Visual-Studio-C++"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/VS_5.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Visual Studio C++ Program.cpp
\begin_inset CommandInset label
LatexCommand label
name "fig:Visual-Studio-C-1-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When testing your submission with PC^2 you will be required to either:
\end_layout

\begin_layout Enumerate
Copy your source code file to the same location as sample input files, or
\end_layout

\begin_layout Enumerate
Copy the sample input files into the same location as the source code file.
\end_layout

\begin_layout Subsection
Submission Guidelines
\begin_inset CommandInset label
LatexCommand label
name "sub:Submission-Guidelines"

\end_inset


\end_layout

\begin_layout Standard
The primary requirement of any submission, is that all source code required
 for the submission is located in a single text file.
\end_layout

\begin_layout Standard
To test your submission, the judges machine will compile your source code
 to an exectuable or class file in the case of Java, then execute it.
 All input for the application is feed in via 
\family typewriter
stdin
\family default
 (or using standard console input), and all application responses and feedback
 should be returned via 
\family typewriter
stdout
\family default
 (or using standard console output).
 In effect the judges machine will run:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
$ submission.exe < challenge1_input.txt > challenge1_output.txt
\end_layout

\begin_layout Standard
Any output the application produces is saved to a file, and this file is
 then compared to a known correct answer file.
 Any variations from between the applications output and the answer file
 will result in a 
\family typewriter
\series bold
No
\family default
\series default
 response.
 If both the output of the application and answer file match, then the judges
 machine will return a 
\family typewriter
\series bold
Yes
\family default
\series default
 response.
\end_layout

\begin_layout Subsection
Competition Strategy
\end_layout

\begin_layout Standard
It is important to identify the easier problems in the problem set and solve
 them correctly before moving on to problems that are more difficult.
 At the beginning of the competition, the team should quickly identify an
 easy problem and assign one of the team to solve this problem while the
 other two try to prioritize the remaining problems based on their understanding
 of the problems and their abilities to solve them.
\end_layout

\begin_layout Standard
Problems should be submitted as soon as the team believes that they have
 a correct solution.
 This is based on the scoring system where total time is used to break ties
 between teams who have solved the same number of problems.
\end_layout

\begin_layout Standard
Given that there are three people in the team, more than one problem should
 be worked on at a time.
\end_layout

\begin_layout Standard
At least one of the team members should be writing an algorithm for the
 next problem to be attempted.
 There are some benefits to be gained from pair programming while the third
 team member is working on algorithms.
\end_layout

\begin_layout Standard
Alternatively, one person can be writing source code while the other two
 are working on algorithms.
\end_layout

\begin_layout Standard

\series bold
Teams should also build their own test cases to run against their solutions
\series default
.
 This is a very important aspect of the competition and care must be taken
 to account for the constraints given in the problem specification.
 The sample data 
\series bold
will not
\series default
 cover all test cases.
 The judges’ data will.
\end_layout

\begin_layout Standard
Many problems are posed that will require the selection of a correct algorithm
 that runs inside the two minute time limit.
\end_layout

\begin_layout Standard
Another important aspect to be aware of is the range of values that may
 be required in calculations.
 Some problems are posed that have inputs in a 32 byte integer range (
\family typewriter
int
\family default
) and an output in the same range 32 byte range but intermediate calculations
 will overflow the range of the data type, therefore requiring a 64 byte
 long integer range (
\family typewriter
long
\family default
).
\end_layout

\begin_layout Standard

\series bold
Output specifications can sometimes be quite picky.

\series default
 Some problems will require capitalization of some words and some will require
 specific punctuations.
 Problems are judged by matching string output, so if the characters are
 in the wrong case or the string lacks punctuation, it will be judged to
 be a Wrong Answer.
\end_layout

\begin_layout Standard
Some problems will be easier to solve if you create your own data types,
 classes or structs.
 These must all be included in the same source code file.
 Ensure you know how to include more than class or struct in a single file.
\end_layout

\begin_layout Standard
Ensure that you know how to read input from the keyboard (Standard Input
 device) using the language or languages that you are likely to use in the
 competition.
\end_layout

\begin_layout Standard
Ensure that you know how to format output to the monitor using the language
 or languages that you are likely to use.
\end_layout

\begin_layout Standard
As part of any preparation for programming competitions it would probably
 be a good idea to prepare implementations of some of the more complex algorithm
s that are likely to be encountered.
 For example, problems in the medium to difficult range can sometimes be
 transformed into a problem based on a well known graph theory problem e.g.
 minimum spanning tree, depth first search, shortest path or maximum matching.
 In order to recognize a problem description as something that can be solved
 using one of these well known algorithms, it is necessary to know these
 algorithms and have implemented them before.
 
\end_layout

\begin_layout Standard
Familiarise yourself with your language of choice, especially the associated
 libraries that are available.
 Also take careful note on the available collection classes that are available.
\end_layout

\begin_layout Standard
Identify the category of the problem, if it's mathematical / dynamic programming
 / graph theory etc.
 Ask yourself how familiar are you with it.
 After doing this you should make decisions regarding the order in which
 you'll solve them; this goes hand to hand with the next point...
 
\end_layout

\begin_layout Standard
You want to understand the problem completely before typing.
 Solve the right problem.
 In my first competitions I thought that if I wasn't typing, I was wasting
 my time.
 I later found that this was a mistake.
 
\end_layout

\begin_layout Standard
Don't think comments are a waste of time.
 At least in "clever" code, you don't want to go debugging line-by-line
 to see what went wrong (that is a real waste of time).
 Value clarity.
 
\end_layout

\begin_layout Standard
Have fun.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Performance
\end_layout

\begin_layout Subsection
BigO Notation
\end_layout

\begin_layout Standard
Big O notation is used in Computer Science to describe the performance or
 complexity of an algorithm.
 Big O specifically describes the 
\series bold
worst-case
\series default
 scenario, and can be used to describe the execution time required or the
 space used (e.g.
 in memory or on disk) by an algorithm.
\end_layout

\begin_layout Standard
Typically, algorithms will be assigned the following functions:
\end_layout

\begin_layout Description
O(1) This algorithm operates in the same time irrespective of the number
 of elements to be processed.
 (The ideal algorithm).
\end_layout

\begin_layout Description
O(log
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

n) This algorithm will have a worst-case runtime of log
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

n with n elements to be processed.
\end_layout

\begin_layout Description
O(n) This algorithm will have a worst case runtime in the order of the number
 of elements to be processed.
\end_layout

\begin_layout Description
O(nlog
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

n) This algorithm will have a worst case runtime in the order of nlog
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

n with n elements to be processed.
\end_layout

\begin_layout Description
O(n
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

) This algoritm will have a worst case runtime in the order of n
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

 with n elements to be processed.
\end_layout

\begin_layout Description
O(n
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

) This algorithm will have a worst case runtime in the order of n
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

 with n elements to be processed.
\end_layout

\begin_layout Description
O(2
\begin_inset script superscript

\begin_layout Plain Layout
n
\end_layout

\end_inset

) This algorithm will have a worst case runtime in the order of 2
\begin_inset script superscript

\begin_layout Plain Layout
n
\end_layout

\end_inset

 with n elements to be processed.
\end_layout

\begin_layout Standard
As an example, suppose the each operation can be done in 1 microsecond,
 and we have 256 elements to be processed.
 The respective worst case runtimes for each function is shown in Table
 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Big-O-runtimes"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
log
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 microseconds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256 microseconds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nlog
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 milliseconds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
65 milliseconds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17 seconds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\begin_inset script superscript

\begin_layout Plain Layout
n
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.7×10
\begin_inset script superscript

\begin_layout Plain Layout
64 
\end_layout

\end_inset

centuries
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Big O runtimes
\begin_inset CommandInset label
LatexCommand label
name "tab:Big-O-runtimes"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Based on the information in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Big-O-runtimes"

\end_inset

, should 2
\begin_inset script superscript

\begin_layout Plain Layout
n
\end_layout

\end_inset

 algorithms be avoided? Absolutely not, if the algorithm solves the problem
 quickly and easily on provision that the number of elements to be processed
 is relatively small.
 To illustrate, suppose the each operation can be done in 4 microseconds,
 but we only have 16 elements to be processed.
 The respective worst case runtimes for each function is shown in Table
 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Big-O-runtimes-1"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
log
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 microseconds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64 microseconds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nlog
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256 microseconds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1024 microseconds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 milliseconds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\begin_inset script superscript

\begin_layout Plain Layout
n
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256 milliseconds
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Big O runtimes
\begin_inset CommandInset label
LatexCommand label
name "tab:Big-O-runtimes-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
With this comparison, algorithm selection is not merely about the one with
 the least Order value, but also about understanding the number of items
 to be processed compared to the implementation complexity of the algorithm
 itself.
 (One would use an algorithm with 
\series bold
O(2
\begin_inset script superscript

\begin_layout Plain Layout

\series bold
n
\end_layout

\end_inset

)
\series default
 complexity if implementation only takes 5 minutes, versus an algorithm
 with 
\series bold
O(n)
\series default
 complexity if it takes hours to implement and test, if the number of input
 elements is small).
 Sometimes brute force is better than perfect elegance in the competition!
\end_layout

\begin_layout Standard
The information within this section is a very brief introduction to BigO
 notation, has been included to help you choose between two different algorithms
 to complete a task based on the Order function given in the algorithm descripti
on.
 Much research has been completed on algorithm analysis, with many text
 books and reference books being authored on this one subject of Computer
 Science.
 
\end_layout

\begin_layout Subsection
Measuring Performance
\end_layout

\begin_layout Standard
While information described with algorithms can be useful to gain an understandi
ng of the algorithm complexity, it can be helpful to be able to measure
 the actual exectution time needed to complete sections of code.
 All modern languages or software libraries contatins functions to determine
 exectution times
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Modern IDEs such as Oracle Solaris Studio 12.3 include profiling tools to
 determine 'hot-spots' within applications and also be able to automatically
 record execution times of individual functions/methods to later analysis.
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
C#
\end_layout

\begin_layout Standard
The .NET Framework provides a Stopwatch class that is capable of being used
 to measure execution times.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Timing-CSharp"

\end_inset

 shows an example of the syntax.
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language={[Sharp]C}"
inline false
status open

\begin_layout Plain Layout

Stopwatch st = new Stopwatch();
\end_layout

\begin_layout Plain Layout

st.Start();
\end_layout

\begin_layout Plain Layout

// code to be timed goes here
\end_layout

\begin_layout Plain Layout

st.Stop();
\end_layout

\begin_layout Plain Layout

// time in milliseconds 
\end_layout

\begin_layout Plain Layout

long elapsed = (long) st.ElapsedTicks * 1000000 / Stopwatch.Frequency; 
\end_layout

\begin_layout Plain Layout

Console.WriteLine("time = {0}", elapsed);
\begin_inset Caption

\begin_layout Plain Layout
Timing - C#
\begin_inset CommandInset label
LatexCommand label
name "lis:Timing-CSharp"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
C++
\end_layout

\begin_layout Standard
The C standard library includes time specific functions in 
\family typewriter
<time.h>
\family default
 on most systems.
 The primary function is the clock() function that returns the number of
 'clicks' since the application started execution.
 A macro 
\family typewriter
CLOCKS_PER_SEC
\family default
 is used to determine the ratio between clicks and seconds.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Timing---C++"

\end_inset

 shows an example of the syntax.
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language={C++}"
inline false
status open

\begin_layout Plain Layout

#include <time.h> 
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

clock_t start = clock();
\end_layout

\begin_layout Plain Layout

// code to be timed goes here
\end_layout

\begin_layout Plain Layout

clock_t end = clock();
\end_layout

\begin_layout Plain Layout

// time in clicks 
\end_layout

\begin_layout Plain Layout

long elapsed = (long)(end - start)/CLOCKS_PER_SEC; 
\end_layout

\begin_layout Plain Layout

printf("time = %d
\backslash
n", elapsed);
\begin_inset Caption

\begin_layout Plain Layout
Timing - C++
\begin_inset CommandInset label
LatexCommand label
name "lis:Timing---C++"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Java
\end_layout

\begin_layout Standard
The Java System library provides multiple timers with varying accuracy.
 Since Java 5, nanosecond timers has been available via the 
\family typewriter
System.nanoTime()
\family default
 method
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Accuracy of the System.nanoTime() method is reliant on the JVM version and
 underlying Operating System.
 However most modern operating systems do provide some form on nanosecond
 timer.
\end_layout

\end_inset

.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Timing---Java"

\end_inset

 shows an example of the syntax.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=Java"
inline false
status open

\begin_layout Plain Layout

long start = System.nanoTime();
\end_layout

\begin_layout Plain Layout

// code to be timed goes here
\end_layout

\begin_layout Plain Layout

long end = System.nanoTime();
\end_layout

\begin_layout Plain Layout

// time in nanoseconds 
\begin_inset Caption

\begin_layout Plain Layout
Timing - Java
\begin_inset CommandInset label
LatexCommand label
name "lis:Timing---Java"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

long elapsed = (end - start)/1000000; 
\end_layout

\begin_layout Plain Layout

System.out.printf("time = %d%n", elapsed);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Integers vs Floating Point
\end_layout

\begin_layout Standard
Modern CPUs have integrated high-performance floating-point execution units,
 however it should be noted that the choice of Integer, Long's and Floating
 Point number will have an impact of performance of your solution.
 The code snippet in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Source-code-for"

\end_inset

 demonstrates the performance differences of using 'int', 'long' and 'double'
 for a simple add, multiple and divide sequence.
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset listings
lstparams "tabsize=2"
inline false
status open

\begin_layout Plain Layout

 public class NumberTypeTesting {
\end_layout

\begin_layout Plain Layout

   static final long ITERATIONS = 1000000000;
\end_layout

\begin_layout Plain Layout

   public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

     final double DOUBLE_PRIME = 73;
\end_layout

\begin_layout Plain Layout

     final int INT_PRIME = 73;
\end_layout

\begin_layout Plain Layout

     final long LONG_PRIME = 73;
\end_layout

\begin_layout Plain Layout

     long start;
\end_layout

\begin_layout Plain Layout

     long end;
\end_layout

\begin_layout Plain Layout

     long count;
\end_layout

\begin_layout Plain Layout

     double valueDoubleA = 1.00;
\end_layout

\begin_layout Plain Layout

     double valueDoubleB = Math.PI; // pi = 3.142
\end_layout

\begin_layout Plain Layout

     double valueDoubleC = Math.E; // e = 2.718
\end_layout

\begin_layout Plain Layout

     int valueIntA = 1;
\end_layout

\begin_layout Plain Layout

     int valueIntB = 10;
\end_layout

\begin_layout Plain Layout

     int valueIntC = 31;
\end_layout

\begin_layout Plain Layout

     long valueLongA = 1;
\end_layout

\begin_layout Plain Layout

     long valueLongB = 31;
\end_layout

\begin_layout Plain Layout

     long valueLongC = 33;
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

     // Integers
\end_layout

\begin_layout Plain Layout

     count = ITERATIONS;
\end_layout

\begin_layout Plain Layout

     start = System.nanoTime();
\end_layout

\begin_layout Plain Layout

     while (count-- != 0) {
\end_layout

\begin_layout Plain Layout

       valueIntA += valueIntC * valueIntB / INT_PRIME;
\end_layout

\begin_layout Plain Layout

     }
\end_layout

\begin_layout Plain Layout

     end = System.nanoTime();
\end_layout

\begin_layout Plain Layout

     System.out.printf("Integer time = %d msec%n", (end - start) / 1000000);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     // Long
\end_layout

\begin_layout Plain Layout

     count = ITERATIONS;
\end_layout

\begin_layout Plain Layout

     start = System.nanoTime();
\end_layout

\begin_layout Plain Layout

     while (count-- != 0) {
\end_layout

\begin_layout Plain Layout

       valueLongA += valueLongC * valueLongB / LONG_PRIME;
\end_layout

\begin_layout Plain Layout

     }
\end_layout

\begin_layout Plain Layout

     end = System.nanoTime();
\end_layout

\begin_layout Plain Layout

     System.out.printf("Long time = %d msec%n", (end - start) / 1000000);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     // Double
\end_layout

\begin_layout Plain Layout

     count = ITERATIONS;
\end_layout

\begin_layout Plain Layout

     start = System.nanoTime();
\end_layout

\begin_layout Plain Layout

     while (count-- != 0) {
\end_layout

\begin_layout Plain Layout

       valueDoubleA += valueDoubleC * valueDoubleB / DOUBLE_PRIME;
\end_layout

\begin_layout Plain Layout

     }
\end_layout

\begin_layout Plain Layout

     end = System.nanoTime();
\end_layout

\begin_layout Plain Layout

     System.out.printf("Double time = %d msec%n", (end - start) / 1000000);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption

\begin_layout Plain Layout
Source code for Timing test
\begin_inset CommandInset label
LatexCommand label
name "lis:Source-code-for"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The results
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Java 6SE 32bit was used to generate the following results.
\end_layout

\end_inset

 for the above test in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Source-code-for"

\end_inset

 are:
\end_layout

\begin_layout Verse

\family typewriter
Integer time = 1131 msec
\begin_inset Newline newline
\end_inset

Long time = 2673 msec 
\begin_inset Newline newline
\end_inset

Double time = 1298 msec
\end_layout

\begin_layout Standard
While there is a minor performance drop for using floating point numbers,
 using 64bit longs yields over double the execution time.
 This may easily be fixed by utilising an environment that runs as 64bit
 code, but this is not guaranteed to be available during the competition.
\end_layout

\begin_layout Subsection
Implementation and Modern Software Engineering Practices
\end_layout

\begin_layout Standard
One of the aims of the competition is to develop efficient solutions to
 the challenges being presented.
 However often this also means not following modern software engineering
 practices and taking as many shortcuts as possible.
\end_layout

\begin_layout Standard
Some items that are typically seen (and encouraged) are:
\end_layout

\begin_layout Enumerate
Liberal use of global variables utlised by direct access.
\end_layout

\begin_layout Enumerate
Liberal use of function pointers and jump tables in C++.
\end_layout

\begin_layout Enumerate
Dispite strong OOP principles with each programming language, these are
 often ignored for more simple data structures and items like inheritence
 and encapsulation are ignored.
\end_layout

\begin_layout Enumerate
Nested classes liberally use public variables allowing for direct access.
\end_layout

\begin_layout Enumerate
The 
\begin_inset Quotes eld
\end_inset


\family typewriter
goto
\family default

\begin_inset Quotes erd
\end_inset

 statement being used in C++ and C# submissions
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
While most professional programmers avoid 
\begin_inset Quotes eld
\end_inset

goto
\begin_inset Quotes erd
\end_inset

 as it's considered inherently evil, there are some instances where its
 use can save execution time and/or reduce code complexity.
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
Ignoring typical design patterns, unless they provide direct and significant
 benefit in utlising an algorithm to complete a challenge.
\end_layout

\begin_layout Enumerate
Error checking is kept to a minimum, mainly designed around corner cases
 for algorithms to handle rather than handling bad and malformed input.
\end_layout

\begin_layout Enumerate
Utilisation of the most efficient algorithm, even in cases where memory
 requirements may be pushed to the extreme.
 eg, building complete hashtables in memory for 
\series bold
O(1)
\series default
 lookups, rather than recomputing as needed.
\end_layout

\begin_layout Standard
As mentioned in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Submission-Guidelines"

\end_inset

, that all source code required for the submission is located in a single
 text file, also requires some creative uses of both local and anonymous
 classes.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Basic Source Templates
\end_layout

\begin_layout Standard
All source code submissions are to consist of a single source code file,
 as previously mentioned.
 This section aims to provide simple templates that can be utilised to create
 your submissions.
 It will also cover some of the basic console functions available with each
 langauge.
\end_layout

\begin_layout Subsection
Input / Output
\end_layout

\begin_layout Subsubsection
C#
\end_layout

\begin_layout Standard
The .NET Framework unfortunately has rather cumbersome support for handling
 console input and output.
 The 
\family typewriter
System.Console
\family default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "http://msdn.microsoft.com/en-us/library/system.console.aspx"

\end_inset


\end_layout

\end_inset

 class provides methods for dealing with the console.
 The three main methods that are typically used are:
\end_layout

\begin_layout Enumerate

\family typewriter
Console.ReadLine();
\end_layout

\begin_layout Enumerate

\family typewriter
Console.Write();
\end_layout

\begin_layout Enumerate

\family typewriter
Console.WriteLine();
\end_layout

\begin_layout Paragraph
Input
\end_layout

\begin_layout Standard
The primary function for input from the Console is the 
\family typewriter
Console.ReadLine()
\family default
 method which as the name indicates, reads a single line from the console
 and returns a 
\family typewriter
string
\family default
.
\end_layout

\begin_layout Standard
In order to extract information from the string, it is needed to split the
 string based on a delimiter (typically a space), then attempt to convert
 each part into the desired type.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:CS-Input-Template"

\end_inset

 shows how to read a group of 3 integers (per line) from the console, until
 a three 0's (zeroes) are entered.
 The numbers for each line is added, and the sum is written back to the
 console.
\end_layout

\begin_layout Paragraph
Output
\end_layout

\begin_layout Standard
The primary functions for output to the Console are the 
\family typewriter
Console.Write()
\family default
 and 
\family typewriter
Console.WriteLine()
\family default
 methods.
 These two differ only by the latter terminating the line with a 
\family typewriter
carriage-return
\family default
, while the former does not.
\end_layout

\begin_layout Standard
One item to note, that a single 
\family typewriter
Console.Write() 
\family default
method may only take up to 5 parameters, the first being a string, and the
 other 4 being items to be inserted into the string.
 Item placement within the string is denoted by a number with 
\family typewriter
{}
\family default
 brackets.
 (See the last line in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:CS-Input-Template"

\end_inset

 for an example).
 The item placement parameter, may also take a second argument, being the
 type to have the item converted to, or displayed as.
 Common types include:
\end_layout

\begin_layout Verse

\family typewriter
(C) Currency: .
 .
 .
 .
 .
 .
 .
 .
 {0:C}
\begin_inset Newline newline
\end_inset

(D) Decimal:.
 .
 .
 .
 .
 .
 .
 .
 .
 {0:D}
\begin_inset Newline newline
\end_inset

(E) Scientific:.
 .
 .
 .
 .
 .
 .
 .
 {0:E}
\begin_inset Newline newline
\end_inset

(F) Fixed point: .
 .
 .
 .
 .
 .
 .
 {0:F}
\begin_inset Newline newline
\end_inset

(G) General:.
 .
 .
 .
 .
 .
 .
 .
 .
 {0:G}
\begin_inset Newline newline
\end_inset

(P) Percent:.
 .
 .
 .
 .
 .
 .
 .
 .
 {0:P}
\begin_inset Newline newline
\end_inset

(X) Hexadecimal: .
 .
 .
 .
 .
 .
 .
 {0:X}
\end_layout

\begin_layout Standard
By default, console output is buffered, and only written periodically as
 determined by underlying system settings.
 To flush the output to console immediately, the 
\family typewriter
Console.Out.Flush()
\family default
 method can be utilised.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\begin_inset listings
lstparams "language={[Sharp]C}"
inline false
status open

\begin_layout Plain Layout

using System;
\end_layout

\begin_layout Plain Layout

namespace AddNumbers {
\end_layout

\begin_layout Plain Layout

  class Program {
\end_layout

\begin_layout Plain Layout

    static void Main(string[] args) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Define our numbers to read.
\end_layout

\begin_layout Plain Layout

      int[] numbers;
\end_layout

\begin_layout Plain Layout

      int index;
\end_layout

\begin_layout Plain Layout

      int sum;
\end_layout

\begin_layout Plain Layout

      string line;
\end_layout

\begin_layout Plain Layout

      string[] linesplit;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Keep reading the input from the console until we have nothing left.
\end_layout

\begin_layout Plain Layout

      while ((line = Console.ReadLine()) != null) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Test for exit condition.
\end_layout

\begin_layout Plain Layout

        if (line.CompareTo("0 0 0") == 0) {
\end_layout

\begin_layout Plain Layout

          break;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Reset array indices and sum of numbers
\end_layout

\begin_layout Plain Layout

        index = 0;
\end_layout

\begin_layout Plain Layout

        sum = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Split the line read, and create a new int array to hold our value.
\end_layout

\begin_layout Plain Layout

        linesplit = line.Split(' ');
\end_layout

\begin_layout Plain Layout

        numbers = new int[linesplit.Length];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Attempt to convert the individual parts to int's
\end_layout

\begin_layout Plain Layout

        foreach (string element in linesplit) {
\end_layout

\begin_layout Plain Layout

          try {
\end_layout

\begin_layout Plain Layout

            numbers[index] = Convert.ToInt32(element);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          catch {
\end_layout

\begin_layout Plain Layout

            numbers[index] = 0;
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          index++;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Sum our number and output the sum to Console.
\end_layout

\begin_layout Plain Layout

        foreach (int number in numbers) {
\end_layout

\begin_layout Plain Layout

          sum += number;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        Console.WriteLine("{0}", sum);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption

\begin_layout Plain Layout
C# Input Example
\begin_inset CommandInset label
LatexCommand label
name "lis:CS-Input-Template"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
C++
\end_layout

\begin_layout Standard
Due to the environment in which C++ was originally developed, C++ has very
 strong capabilities for handling both console input and output.
 C++ offers two methods when working with the console:
\end_layout

\begin_layout Enumerate
iostreams
\end_layout

\begin_layout Enumerate
C standard library functions.
\end_layout

\begin_layout Standard
While the two methods can be intermixed, it is recommended that programmers
 utilise a single method for their application
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Mixing the two methods is possible, on provision that all input and output
 streams are emtpy when switching between either method.
 This is due to the buffering that each method utilises during Console IO
 operations.
\end_layout

\end_inset

.
 For the purposes of this guide, I'll only explain the 
\family typewriter
iostream
\family default
s method as it is often seen as easy to use of the two methods.
\end_layout

\begin_layout Paragraph
Input
\end_layout

\begin_layout Standard
Input from the console is handled by the 
\family typewriter
std::cin
\family default
 stream, and has the ability to take multiple types of inputs in a single
 line or function call.
 (This is possible due to operator overloading in C++).
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:C++-Input-and"

\end_inset

 shows the same application written in C++, as shown in C# within Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:CS-Input-Template"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={[ANSI]C++}"
inline false
status open

\begin_layout Plain Layout

#include <cstdlib>
\end_layout

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    int a, b, c;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    do {
\end_layout

\begin_layout Plain Layout

        // Get input of 3 integers and store in a, b and c.
\end_layout

\begin_layout Plain Layout

        cin >> a >> b >> c;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Test exit condition, and exit if true.
\end_layout

\begin_layout Plain Layout

        if(a == 0 && b == 0 && c == 0)
\end_layout

\begin_layout Plain Layout

            break;
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        // Output the sum.
\end_layout

\begin_layout Plain Layout

        cout << (a + b + c) << endl;
\end_layout

\begin_layout Plain Layout

    } while(true);
\end_layout

\begin_layout Plain Layout

   return 0;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption

\begin_layout Plain Layout
C++ Input and Output Example
\begin_inset CommandInset label
LatexCommand label
name "lis:C++-Input-and"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since the 
\family typewriter
cin
\family default
 and 
\family typewriter
cout
\family default
 streams operate on single variables, an alternate method is required to
 read a complete line in one function call.
 This method is 
\family typewriter
getline ( istream& is, string& str );
\family default
, where 
\family typewriter
is
\family default
 is the character stream, and 
\family typewriter
str
\family default
 is the string to place the input into.
 As example of 
\family typewriter
getline() 
\family default
is displayed in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:C++-getline()-example"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={[ANSI]C++}"
inline false
status open

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include <string>
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main () {
\end_layout

\begin_layout Plain Layout

  string str;
\end_layout

\begin_layout Plain Layout

  cout << "Please enter full name: ";
\end_layout

\begin_layout Plain Layout

  getline (cin,str);
\end_layout

\begin_layout Plain Layout

  cout << "Thank you, " << str << ".
\backslash
n";
\end_layout

\begin_layout Plain Layout

  return 0;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption

\begin_layout Plain Layout
C++ getline() example
\begin_inset CommandInset label
LatexCommand label
name "lis:C++-getline()-example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once the line has been fetched with the 
\family typewriter
getline()
\family default
 method, you are free to use any of the other string functions to extract
 information from the string.
\end_layout

\begin_layout Paragraph
Output
\end_layout

\begin_layout Standard
The primary method of output is via the 
\family typewriter
cout
\family default
 iostream, as shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:C++-Input-and"

\end_inset

.
 The format is simply:
\end_layout

\begin_layout Standard

\family typewriter
cout << {object} << {object} << {object} << 
\begin_inset Quotes eld
\end_inset

 string 
\begin_inset Quotes erd
\end_inset

 << ..
 << endl;
\end_layout

\begin_layout Standard
where each {object} represents any C++ primitive type or any C++ object.
\end_layout

\begin_layout Standard
There are two methods to generating a newline character, utilising C++.
 You may either:
\end_layout

\begin_layout Enumerate
Output string 
\family typewriter

\begin_inset Quotes eld
\end_inset


\backslash
n
\begin_inset Quotes erd
\end_inset


\family default
, or
\end_layout

\begin_layout Enumerate
Output 
\family typewriter
std::endl
\family default
 .
\end_layout

\begin_layout Standard
The difference between the two methods, is that 
\begin_inset Quotes eld
\end_inset


\family typewriter
std::endl
\family default

\begin_inset Quotes erd
\end_inset

 will flush the output buffer to console, where 
\begin_inset Quotes eld
\end_inset


\family typewriter

\backslash
n
\family default

\begin_inset Quotes erd
\end_inset

 will not.
\end_layout

\begin_layout Standard
To control the precision of floating point numbers, you can use the 
\family typewriter
setprecision(
\shape italic
x
\shape default
)
\family default
 method as part of the output sequence.
 eg: 
\family typewriter
cout << setprecision(4) << (double)1.23456788 << endl
\family default
; will output 
\family typewriter
1.235
\family default
 to the console.
\end_layout

\begin_layout Paragraph
iostreams vs printf
\begin_inset CommandInset label
LatexCommand label
name "par:iostreams-vs-printf"

\end_inset


\end_layout

\begin_layout Standard
The other method to perform console output is the C function 
\family typewriter
printf()
\family default
.
 
\family typewriter
printf()
\family default
 offers the same features as the 
\family typewriter
cout
\family default
 iostream, and may be used when very fine control over output is required
 especially with floating point numbers.
 
\end_layout

\begin_layout Standard
The general format of the printf() function is:
\end_layout

\begin_layout Verse

\family typewriter
printf(const char *str, ...);
\end_layout

\begin_layout Standard

\family typewriter
str
\family default
 is a formatted string, that may contain 0 or more place holders for additional
 arguments.
 Placeholders in the formatted string are simply filled in order of additional
 arguments as specified in the function call, and the additional arguments
 must be of the same type as specified by the placeholder.
\end_layout

\begin_layout Standard
Formats for placeholders include:
\end_layout

\begin_layout Verse

\family typewriter
%d
\family default
 - decimal 
\family typewriter

\begin_inset Newline newline
\end_inset

%du
\family default
 - decimal unsigned
\begin_inset Newline newline
\end_inset


\family typewriter
%f
\family default
 - floating point
\begin_inset Newline newline
\end_inset


\family typewriter
%s
\family default
 - string (char*)
\begin_inset Newline newline
\end_inset


\family typewriter
%c
\family default
 - character
\begin_inset Newline newline
\end_inset


\family typewriter
%x
\family default
 - hexidecimal number
\begin_inset Newline newline
\end_inset


\family typewriter
%l
\family default
 - long 
\begin_inset Newline newline
\end_inset


\family typewriter
%lu
\family default
 - long unsigned
\end_layout

\begin_layout Standard
Additional fields may be added to the place holders to specify field width
 and/or precisions.
 For example:
\end_layout

\begin_layout Verse

\family typewriter
%.5f
\family default
 - will display a floating point number to 5 decimal places.
\begin_inset Newline newline
\end_inset


\family typewriter
%5s
\family default
 - will consume at exactly 5 character spaces for a string.
 
\end_layout

\begin_layout Standard
There are a few special reserved characters for the printf(), some of these
 include:
\end_layout

\begin_layout Verse

\family typewriter

\backslash
n
\family default
 - carriage return.
\begin_inset Newline newline
\end_inset


\family typewriter

\backslash
t
\family default
 - tab character.
\end_layout

\begin_layout Standard
There are has been some debate over the performance aspects of the two methods,
 often citing that there is no performance difference.
 Utilising the source code in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:C++,-cout-vs"

\end_inset

, I've found that in some cases there can be significant differences in
 performance, with 
\family typewriter
printf()
\family default
 being up to 250 times faster than the equivalent 
\family typewriter
cout
\family default
 function.
\end_layout

\begin_layout Standard
Based on average times for 5 runs of the test application in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:C++,-cout-vs"

\end_inset

, yeilds the following results:
\end_layout

\begin_layout Enumerate
cout time = 67240 msec
\end_layout

\begin_layout Enumerate
printf() time = 280 msec
\end_layout

\begin_layout Standard
It should be heavily stressed, that the above times are indicative of worst
 cases only, and in practice and real-word the difference is less pronounced.
 For example, enabling all compiler optimisations that enable SSE4 and auto-para
llelisation support reduces the difference to:
\end_layout

\begin_layout Enumerate
cout time = 700 msec
\end_layout

\begin_layout Enumerate
printf() time = 280 msec
\end_layout

\begin_layout Standard
Indicating a time penality of just over 2 times.
 While this penalty isn't as poor as earlier indicated, within the competition
 it may mean the difference between getting a 
\begin_inset Quotes eld
\end_inset

Yes
\begin_inset Quotes erd
\end_inset

 response and a 
\begin_inset Quotes eld
\end_inset

Time Overrrun
\begin_inset Quotes erd
\end_inset

 response.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={[ANSI]C++}"
inline false
status open

\begin_layout Plain Layout

#include <cstdlib>
\end_layout

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define LOOPCOUNT 1000000
\end_layout

\begin_layout Plain Layout

#define NUMBER1 31.0 
\end_layout

\begin_layout Plain Layout

#define NUMBER2 21
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    long count = LOOPCOUNT;
\end_layout

\begin_layout Plain Layout

    double dbl = NUMBER1;
\end_layout

\begin_layout Plain Layout

    int Int = NUMBER2;
\end_layout

\begin_layout Plain Layout

    char* str = (char*) &"hello";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    clock_t start = clock(); // Start timing
\end_layout

\begin_layout Plain Layout

    while (count--) {
\end_layout

\begin_layout Plain Layout

        cout << dbl << " " << Int++ << " " << str << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

        dbl = dbl * (double) Int / ((double) Int * 2.0);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    clock_t end = clock(); // End timing
\end_layout

\begin_layout Plain Layout

    cerr << "cout time = " << double(end - start)*1000.0/CLOCKS_PER_SEC 
\end_layout

\begin_layout Plain Layout

         << "msec " << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // reset start values
\end_layout

\begin_layout Plain Layout

    count = LOOPCOUNT;
\end_layout

\begin_layout Plain Layout

    dbl = NUMBER1;
\end_layout

\begin_layout Plain Layout

    Int = NUMBER2;
\end_layout

\begin_layout Plain Layout

    start = clock(); // Start timing
\end_layout

\begin_layout Plain Layout

    while (count--) {
\end_layout

\begin_layout Plain Layout

        printf("%f %d %s
\backslash
n", dbl, Int++, str);
\end_layout

\begin_layout Plain Layout

        dbl = dbl * (double) Int / ((double) Int * 2.0);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    end = clock(); // End timing
\end_layout

\begin_layout Plain Layout

    cerr << "printf time = " << double(end - start)*1000.0/CLOCKS_PER_SEC
\end_layout

\begin_layout Plain Layout

         << "msec" << endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption

\begin_layout Plain Layout
C++, cout vs printf()
\begin_inset CommandInset label
LatexCommand label
name "lis:C++,-cout-vs"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Java
\end_layout

\begin_layout Standard
Similar to C++, Java has a very capable set of support functions for handling
 console input and output.
 These are mainly archived through the 
\family typewriter
System.in 
\family default
and 
\family typewriter
System.out
\family default
 classes used in conjuction with the 
\family typewriter
Java.util.Scanner
\family default
 class provided with the default Java libraries.
\end_layout

\begin_layout Paragraph
Input
\end_layout

\begin_layout Standard
Java historically has had a large number of different methods for handling
 console input, with each new version of Java providing a more streamlined
 method of handling these functions.
\end_layout

\begin_layout Standard
The current prefered method for console input in Java is to use the 
\family typewriter
Java.util.Scanner
\family default
 class tied with the 
\family typewriter
System.in
\family default
 object to extract the required information from the console.
 An example of the 
\family typewriter
Scanner
\family default
 class can be found in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Java-Input-and"

\end_inset

 which solves the same problem as shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:CS-Input-Template"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

public class AddNumbers {
\end_layout

\begin_layout Plain Layout

   public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // get first line and check for end of test cases
\end_layout

\begin_layout Plain Layout

      String line = in.nextLine();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Continue until exit condition
\end_layout

\begin_layout Plain Layout

      while (!line.equals("0 0 0")) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

         // extract three ints
\end_layout

\begin_layout Plain Layout

         Scanner sc = new Scanner(line);
\end_layout

\begin_layout Plain Layout

         int a = sc.nextInt();
\end_layout

\begin_layout Plain Layout

         int b = sc.nextInt();
\end_layout

\begin_layout Plain Layout

         int c = sc.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

         System.out.printf("%d%n", (a + b + c));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

         // get next line
\end_layout

\begin_layout Plain Layout

         line = in.nextLine();
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption

\begin_layout Plain Layout
Java Input and Output Example
\begin_inset CommandInset label
LatexCommand label
name "lis:Java-Input-and"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Output
\end_layout

\begin_layout Standard
Output is easiest handled via the 
\family typewriter
System.out.printf()
\family default
 method, as it offers a good match between flexiblity and performance.
 The format for the method call is the same as the C++ 
\family typewriter
printf()
\family default
 function as described in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:iostreams-vs-printf"

\end_inset

.
 An example of the method call is also in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Java-Input-and"

\end_inset

.
\end_layout

\begin_layout Paragraph
Special Notes
\end_layout

\begin_layout Standard
In addition to primitive data types found in other languages such as 
\family typewriter
int
\family default
, 
\family typewriter
double
\family default
, 
\family typewriter
float
\family default
, 
\family typewriter
string
\family default
, Java also has a 
\family typewriter
BigInteger
\family default
 and 
\family typewriter
BigDecimal
\family default
 data types that is capable of dealing with numbers that 
\family typewriter
double
\family default
 and 
\family typewriter
long
\family default
 cannot deal with.
 The use of these two data types may allow some problems to be easily solved,
 that would otherwise necessitate complex code when dealing with numbers
 that cannot be represented by either 
\family typewriter
long
\family default
 or 
\family typewriter
double
\family default
.
\end_layout

\begin_layout Subsection
Program Structure
\end_layout

\begin_layout Standard
For all solutions to ACM and ANZAC problems, the entire solution must be
 written in one file.
 It is suggested for clarity during the competition that you name your programs
 simply.
 Problems will usually be associated with a letter (A – I) or a number (1
 – 9).
 Name your main class (if applicable) and therefore the source code file
 for the problem, something that represents the problem being presented.
\end_layout

\begin_layout Subsubsection
C# and Java
\begin_inset CommandInset label
LatexCommand label
name "sub:CS-and-Java"

\end_inset


\end_layout

\begin_layout Standard
For both Java and C#, due to the pure OOP paradigm being presented there
 are few recommendations
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
These are recommendations, not hard rules.
 Feel free to break them or ignore them completely as needed.
\end_layout

\end_inset

 that may assist in development of yout solutions.
\end_layout

\begin_layout Standard
The main class will naturally require a main method.
 It is suggested that you instantiate an object of this class and write
 a non-static method that can access any global instance variables you may
 need for multiple test cases.
 (An example is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Java-Program-Structure"

\end_inset

).
 Attempt to avoid writing all the methods as static methods, as this can
 lead to some complications if not done carefully.
\end_layout

\begin_layout Standard
There should be no need to use public or private modifiers for your instance
 variables.
 There is no need for the strict OO rules to be followed, just as long as
 you understand what side effects you are writing in to your methods.
\end_layout

\begin_layout Standard
If the problem requires you to define a class it needs to be in the same
 file.
 If you make it an inner class of the class you write for your main program,
 all instance variables of that inner class will not need to be declared
 public for accessibility.
\end_layout

\begin_layout Standard
If your program requires you to do specific output from this inner data
 class, make sure you use a 
\family typewriter
toString()
\family default
 (Java) or 
\family typewriter
ToString()
\family default
 (C#) method to format that output as required.
 Because the 
\family typewriter
toString()
\family default
 method would be overriding the 
\family typewriter
toString()
\family default
 method from the Object base class, it must have the public modifier.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// imports go first 
\end_layout

\begin_layout Plain Layout

public class PA { 
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    new PA().run()
\end_layout

\begin_layout Plain Layout

  } 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  public void run() { 
\end_layout

\begin_layout Plain Layout

    // start of solution goes here 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Java Program Structure
\begin_inset CommandInset label
LatexCommand label
name "lis:Java-Program-Structure"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
C++
\end_layout

\begin_layout Standard
Due to C++ being a language that allows both OOP and Structured Programming
 paradigms, there are no special considerations required.
 However some of the recommendations may be followed as those defined in
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:CS-and-Java"

\end_inset

 as needed.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Basic Algorithms
\end_layout

\begin_layout Subsection
Sorting
\end_layout

\begin_layout Standard
The majority of data structures that will be utilised within the competition
 all provide some form of inbuilt sorting algorithm, or through their design
 are naturally sorted as in the case of a Binary Search Tree.
\end_layout

\begin_layout Standard
It is highly recommended as far as competition submissions are concerned,
 that you utilise the built-in sort methods rather that attempting to implement
 your own sort method.
\end_layout

\begin_layout Standard
Typically, most data structures will utilise either quicksort or merge sort
 (depending on the underlying structure) as they both offer 
\series bold
O(
\shape italic
n
\shape default
 log 
\shape italic
n
\shape default
)
\series default
 performance in the average case.
 
\end_layout

\begin_layout Subsection
Searching
\end_layout

\begin_layout Standard
When given a linear array of data items, search algorithms find information
 about a particular data item in the list or find the location of the data
 item in the list.
 Two primary search algorithms are:
\end_layout

\begin_layout Enumerate
Linear Search
\end_layout

\begin_layout Enumerate
Binary Search
\end_layout

\begin_layout Subsubsection
Linear Search
\end_layout

\begin_layout Standard
Linear Search algorithms transverse through a list of data items in sequential
 order attempting to find the location of the data item.
 The list itself may or may not be sorted, and the underlying data structure
 may be a linear array or a linked list.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require Vector $S$, with $n$ elements, with search key $k$
\end_layout

\begin_layout Plain Layout


\backslash
Ensure if $k 
\backslash
in S$ return index of $k$, else return -1
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{LinearSearch}{$S,k$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$i$ = 0 to $n-1$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$S$[$i$] = $k$}
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return $i$
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return -1
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Linear Search
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
The linear search algorithm takes a vector (aka array) of elements, and
 simply searches all elements in order as stored.
 This can yeild slow performance with large vectors, as the worst case for
 linear search is 
\series bold
O(
\shape italic
n
\shape default
)
\series default
.
\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Linear-Search-Implementation-1"

\end_inset

 and Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Linear-Search-Implementation-1"

\end_inset

 show the linear search algorithm as implemented in Java and C++ respectively.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public int LinearSearch(E[] vector, E key){
\end_layout

\begin_layout Plain Layout

  for(int index = 0; index < vector.length; index++){
\end_layout

\begin_layout Plain Layout

    if(vector[index] == key){
\end_layout

\begin_layout Plain Layout

      return index;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return -1;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption

\begin_layout Plain Layout
Linear Search Implementation (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Linear-Search-Implementation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public int LinearSearch(E[] vector, int vsize, E key){
\end_layout

\begin_layout Plain Layout

  for(int index = 0; index < vsize; index++){
\end_layout

\begin_layout Plain Layout

    if(vector[index] == key){
\end_layout

\begin_layout Plain Layout

      return index;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return -1;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption

\begin_layout Plain Layout
Linear Search Implementation (C++)
\begin_inset CommandInset label
LatexCommand label
name "lis:Linear-Search-Implementation-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem - Linear Search 
\begin_inset CommandInset label
LatexCommand label
name "par:SP-Linear-Search"

\end_inset


\end_layout

\begin_layout Standard
Given a list of numbers (integers) in a line, determine if the first value
 on the line is present within the subsequent list of numbers.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
Input consists of one or more lines, with the first line being the number
 of cases to test.
\end_layout

\begin_layout Standard
Each line consists of one or more integers in the range of 0 to 32767.
 The first integer is the key value, followed by a list of up to 32 integers
 forming a vector of numbers.
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
3
\begin_inset Newline newline
\end_inset

10 12 327 0 10 
\begin_inset Newline newline
\end_inset

1 2 3 4 5 6 7 8
\begin_inset Newline newline
\end_inset

10 20 30 40 50 60 70 90 10
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
The output of each line should consist of a single integer being either
 the index of the key within the vector, being zero (0) offset, or the value
 -1 if the key is not present in the vector.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
3
\begin_inset Newline newline
\end_inset

-1
\begin_inset Newline newline
\end_inset

7
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Problem Solution
\end_layout

\begin_layout Standard
A solution to the above problem utilising a linear search can be seen in
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Linear"

\end_inset

.
 The solution included simply reads in a line of numbers, and attempts to
 find the first value in the list of other values in the line.
 It continues to do this, until the exit condition is reached.
\end_layout

\begin_layout Standard
Some of the test cases to handle include:
\end_layout

\begin_layout Enumerate
The case count being less or equal to 0.
\end_layout

\begin_layout Enumerate
The line itself contains a single integer, being the key, but provided with
 an empty vector to search.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class LinearSearch {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Perform linear search of array (vector) for item (key).
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param vector array of numbers
\end_layout

\begin_layout Plain Layout

   * @param key item to look for in array
\end_layout

\begin_layout Plain Layout

   * @return index of key in vector, or -1 is not present
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static int LinearSearch(int[] vector, int key) {
\end_layout

\begin_layout Plain Layout

    for (int index = 0; index < vector.length; index++) {
\end_layout

\begin_layout Plain Layout

      if (vector[index] == key) {
\end_layout

\begin_layout Plain Layout

        return index;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return -1;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // get first line and get the number of cases to test.
\end_layout

\begin_layout Plain Layout

    int caseCount = Integer.parseInt(in.nextLine());
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Keep reading each line while caseCount > 0
\end_layout

\begin_layout Plain Layout

    while (caseCount-- > 0) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // split by white space.
 so we have an array of numbers
\end_layout

\begin_layout Plain Layout

      String[] numStrs = in.nextLine().split("
\backslash

\backslash
s+");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // create an array to hold our numbers, and convet the array of strings
 to
\end_layout

\begin_layout Plain Layout

      // numbers.
 Note: numStrs[0] is the key value
\end_layout

\begin_layout Plain Layout

      int[] nums = new int[numStrs.length - 1];
\end_layout

\begin_layout Plain Layout

      for (int i = 1; i < nums.length; i++) {
\end_layout

\begin_layout Plain Layout

        nums[i - 1] = Integer.parseInt(numStrs[i]);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Output the index of the key in the vector
\end_layout

\begin_layout Plain Layout

      System.out.printf("%d%n", LinearSearch(nums, Integer.parseInt(numStrs[0]))));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

} 
\begin_inset Caption

\begin_layout Plain Layout
Solution to Linear Search (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Linear"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Binary Search
\end_layout

\begin_layout Standard
The binary search algorithm is a more efficient method of searching a vector,
 on provision that the vector is sorted and any element can be accessed
 in 
\series bold
O(1)
\series default
 time.
 Becuase of these two conditions, it can't with some storage data structures
 like linked lists (as elements can't be accessed in 
\series bold
O(1)
\series default
 time), nor is suitable for vectors that are unsorted.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require An ordered vector $S$, with $n$ elements, with search key $k$.
 Items $low$ and $high$ indicate current search space of vector $S$
\end_layout

\begin_layout Plain Layout


\backslash
Ensure if $k 
\backslash
in S$ return index of $k$, else return -1
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{BinarySearch}{$S, k, low, high$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$low$ > $high$}
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return -1
\end_layout

\begin_layout Plain Layout


\backslash
Else
\end_layout

\begin_layout Plain Layout


\backslash
State $mid 
\backslash
leftarrow 
\backslash
lfloor ( low + high ) / 2 
\backslash
rfloor$
\end_layout

\begin_layout Plain Layout


\backslash
If {$k = S[mid]$}
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return $mid$
\end_layout

\begin_layout Plain Layout


\backslash
ElsIf {$k < S[mid]$}
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return BinarySearch($S,k,low,mid-1$)
\end_layout

\begin_layout Plain Layout


\backslash
Else
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return BinarySearch($S,k,mid+1,high$)
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Binary Search
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
The binary search algorithm is a naturally recursive algorithm, in that
 it calls itself to continue searching the vector.
 
\end_layout

\begin_layout Standard
The algorithm starts with the entire space of the vector, and looks at the
 mid point between the 
\shape italic
low
\shape default
 and 
\shape italic
high
\shape default
 values.
 If this value is not the required key (
\shape italic
k
\shape default
), it will then determine if the key is less than or greater than the current
 value at 
\shape italic
mid
\shape default
.
 If the key is lower than mid, then it will redefine the search space to
 be that between 
\shape italic
low
\shape default
 and 
\shape italic
mid-1
\shape default
, otherwise redefine the search space between 
\shape italic
mid
\shape default
+1 and 
\shape italic
high
\shape default
.
 It then calls itself to perform another search.
 In the event that 
\shape italic
low
\shape default
 is greater than 
\shape italic
high
\shape default
, it determines that the key is not in 
\shape italic
S
\shape default
, and will return -1.
\end_layout

\begin_layout Standard
What the algorithm effectively does is split the entire search space of
 vector 
\shape italic
S
\shape default
 into 2 parts, if the key is not at 
\shape italic
mid
\shape default
.
 By virtue, if the value at 
\shape italic
mid
\shape default
 is less than the key, it understands that there is no justification to
 look at values located to the left of the current 
\shape italic
mid
\shape default
 point in the vector.
 With each iteration of the search it effectively reduces the search space
 by half.
\end_layout

\begin_layout Standard
By reduction of the search by half, the worst case performance of a binary
 search is 
\series bold
O(log
\shape italic
 n
\shape default
)
\series default
.
 As this is a vast improvement on a linear search, a binary search should
 be utilised when ever possible.
 However, this requires that the vector be sorted before a binary search
 can be performed.
\end_layout

\begin_layout Standard
Utilising a quicksort or merge sort, will add overhead (both of these typically
 yield 
\series bold
O(
\shape italic
n
\shape default
 log
\shape italic
 n
\shape default
)
\series default
 performance), so for very large vectors, the overhead of a sort prior to
 search is not that great, but for small size vectors, the overhead of a
 sort may not yield greater performance over the simple (and slow) linear
 search.
\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Binary-Search-(Java)"

\end_inset

 shows an implementation of the binary search in Java.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public int BinarySearch(E[] vector, E key, int low, int high){
\end_layout

\begin_layout Plain Layout

  if(low > high){
\end_layout

\begin_layout Plain Layout

    return -1;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  int mid = (low+high)/2;
\end_layout

\begin_layout Plain Layout

  if(vector[mid] == key){
\end_layout

\begin_layout Plain Layout

    return mid;
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    if(key < vector[mid]){
\end_layout

\begin_layout Plain Layout

      return BinarySearch(vector, key, low, (mid-1));
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      return BinarySearch(vector, key, (mid+1), high);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption

\begin_layout Plain Layout
Binary Search (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Binary-Search-(Java)"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem
\end_layout

\begin_layout Standard
For demonstration of the Binary Search algorithm, I will use the same problem
 as shown in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:SP-Linear-Search"

\end_inset

, Linear Search Problem.
 However, it is expected that the input of numbers (except for the key)
 will be in order from lowest to highest.
\end_layout

\begin_layout Paragraph
Problem Solution
\end_layout

\begin_layout Standard
A solution to the sample problem utilising a binary search can be seen in
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Binary"

\end_inset

.
 The solution included simply reads in a line of numbers, and attempts to
 find the first value in the list of other values in the line.
 It continues to do this, until the exit condition is reached.
\end_layout

\begin_layout Standard
Some of the test cases to handle include:
\end_layout

\begin_layout Enumerate
The case count being less or equal to 0.
\end_layout

\begin_layout Enumerate
The line itself contains a single integer, being the key, but provided with
 an empty vector to search.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class LinearSearch {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Perform binary search of array (vector) for item (key).
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param vector array of numbers
\end_layout

\begin_layout Plain Layout

   * @param key item to look for in array
\end_layout

\begin_layout Plain Layout

   * @param low start position of array to search
\end_layout

\begin_layout Plain Layout

   * @param high end position of array to search
\end_layout

\begin_layout Plain Layout

   * @return index of key in vector, or -1 is not present
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static int BinarySearch(int[] vector, int key, int low, int high){
\end_layout

\begin_layout Plain Layout

    if(low > high){
\end_layout

\begin_layout Plain Layout

      return -1;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    int mid = (low+high)/2;
\end_layout

\begin_layout Plain Layout

    if(vector[mid] == key){
\end_layout

\begin_layout Plain Layout

      return mid;
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      if(key < vector[mid]){
\end_layout

\begin_layout Plain Layout

        return BinarySearch(vector, key, low, (mid-1));
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        return BinarySearch(vector, key, (mid+1), high);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // get first line and get the number of cases to test.
\end_layout

\begin_layout Plain Layout

    int caseCount = Integer.parseInt(in.nextLine());
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Keep reading each line while caseCount > 0
\end_layout

\begin_layout Plain Layout

    while (caseCount-- > 0) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // split by white space.
 so we have an array of numbers
\end_layout

\begin_layout Plain Layout

      String[] numStrs = in.nextLine().split("
\backslash

\backslash
s+");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // create an array to hold our numbers, and convet the array of strings
 to
\end_layout

\begin_layout Plain Layout

      // numbers.
 Note: numStrs[0] is the key value
\end_layout

\begin_layout Plain Layout

      int[] nums = new int[numStrs.length - 1];
\end_layout

\begin_layout Plain Layout

      for (int i = 1; i < nums.length; i++) {
\end_layout

\begin_layout Plain Layout

        nums[i - 1] = Integer.parseInt(numStrs[i]);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Output the index of the key in the vector
\end_layout

\begin_layout Plain Layout

      System.out.printf("%d%n", 
\end_layout

\begin_layout Plain Layout

        BinarySearch(nums, Integer.parseInt(numStrs[0]), 0, nums.length-1));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

} 
\begin_inset Caption

\begin_layout Plain Layout
Solution to Binary Search Problem (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Binary"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Array Handling
\end_layout

\begin_layout Standard
When talking about arrays, we typical define one as a single string
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A string in many languages (notably low level langauges like assembler)
 does not define a String of letters, numbers and punctuation, but rather
 a linear memory region of bytes.
\end_layout

\end_inset

 or allocation of elements in a linear continous region.
 Ee can define an array of arrays to form a two dimensional array, or an
 array of arrays of arrays to form a three dimensional array, and continue
 to do so, allowing for infinite dimensional array.
 This section will typically discuss array operations on two dimensional
 arrays, such as rotation and mirroring that may support application of
 algorithms or may simply speed up implementions due to underlying hardware
 constraints.
\end_layout

\begin_layout Subsubsection
Array Performance
\begin_inset CommandInset label
LatexCommand label
name "sub:Array-Performance"

\end_inset


\end_layout

\begin_layout Standard
When most people are taught programming in either High School or early Universit
y level, performance constraints in regards to arrays is either neglected
 or very limited discussion is made without concrete examples.
 This section aims to give some insight to performance issues when dealing
 with arrays, primarily around performance bottlenecks.
\end_layout

\begin_layout Standard
The primary reason for poor performance when using arrays, is not based
 on a programming language or library issue, but is based on lack of understandi
ng the underlying hardware and how memory access works.
\end_layout

\begin_layout Standard
From a hardware achitectural viewpoint there are different classes of hardware
 memory:
\end_layout

\begin_layout Enumerate
Primary - The RAM that the CPU sees as the address space given to it.
\end_layout

\begin_layout Enumerate
Secondary - The Harddrive installed within the system, providing non-voliatile
 memory.
 
\end_layout

\begin_layout Enumerate
Teritiary - Removable non-voliatile memory such as DVD's, CD's, USB Flash
 Keys, etc.
\end_layout

\begin_layout Standard
What is typically not taught are the different levels of primary storage.
 Utilising a modern Intel x86 processor
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The size and access latencies described are taken from the Intel Core 2
 Quad Family Datasheet and Vol 3 of the Intel Architecture Manuals.
\end_layout

\end_inset

 as an example, the primary levels include:
\end_layout

\begin_layout Enumerate
CPU registers, internal to the CPU and these are where typically most operations
 are performed.
 These typically have a zero latency access.
\end_layout

\begin_layout Enumerate
Level 1 Data and Code caches, these hold the most recent code and data being
 accessed from the Level 2 cache.
 There are typically two Level 1 caches, each desginated for holding either
 code or data, and are typically 16kilobytes size in size
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Each CPU make/model can have different L1 cache sizes, for example the Intel
 E7 Xeon CPUs have 32KB for code and 32KB for data in it's L1 cache, and
 the AMD Opteron utilises 64KB L1 caches.
 
\end_layout

\end_inset

.
 The Level 1 cache will typically have a 1-2 CPU cycle access latency, and
 besides the CPU registers is the fastest memory available to the CPU.
\end_layout

\begin_layout Enumerate
Level 2 unified Code and Data cache will typically be in the size of anywhere
 from 256kilobytes up to 16megabytes in size depending on the CPU make and
 model.
 This acts a large cache between the main memory of the system, and the
 CPU and Level 1 caches.
 The Level 2 cache will typically have a 5-10 CPU cycle access latency,
 primarily due to restrictions of the size of the cache.
 (The larger the cache, the slower the access due to it's size
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is a very crude approximation, as there are many factors that determine
 the performance of the L2 cache.
\end_layout

\end_inset

).
\end_layout

\begin_layout Enumerate
Level 3 unified Code and Data caches are present in some CPUs and act as
 a third level between the CPU and main memory of the system.
 Level 3 caches are becoming more common with multi-core CPUs, as Level
 2 and Level 1 caches are being tied to a particular CPU core, where the
 Level 3 cache can act as a unified cache for all CPU cores.
 While Level 3 caches can be quite big, in some cases now approaching 32MB
 in size
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The Sun UltraSPARC IV+ utilises a 32MB L3 cache and the Intel Itanium 9300
 utilises a 24MB L3 cache.
\end_layout

\end_inset

, they are even slower that the Level 2 cache with access latency between
 15-35 CPU cycles.
\end_layout

\begin_layout Enumerate
Main Memory, is typically in the form of the DIMMs that get installed in
 the mainboard of the computer.
 While systems are approaching very large capacities (32GB can be found
 in home desktop systems, and up to 194GB in workstations), they are very
 slow compared to the CPU registers and even the Level 1,2 and 3 caches.
 Typical access latencies can be measured anywhere from hundreds to thousands
 of CPU cycles.
 That is, if the CPU needs some information that is not present in one of
 the caches, it can potentially stall for 100's, if not 1000's of CPU cycles
 doing nothing while it waits for the information
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
CPU vendors do a lot to avoid this, and even resort to techniques such as
 SMT (aka HyperThreading), or even offer CPU instructions that allow application
s to preload the caches with information to avoid these stalls.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Why is knowing all about the different level of cache's important in regards
 to arrays? Simply, if you try to access an array element that is not in
 one of the caches, your application will suffer a performance hit whilst
 waiting for the information from main memory.
 By ensuring that your next memory access will be in one of the CPUs cache,
 you can ensure the best possible performance for your applicaton when dealing
 with any sized array.
\end_layout

\begin_layout Standard
To quote Terje Mathisen (a well known programming optimization guru
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Terje, at one time worked for iD Software on the original Doom and Quake
 games and was able to get Quake running a full 3D environment utilising
 a software based graphics renderer on hardware such as the Intel Pentium
 60.
 (The Intel Pentium 60, ran at 60MHz, roughly 60-90 times slower than current
 CPUs).
\end_layout

\end_inset

): "All programming is an exercise in caching."
\end_layout

\begin_layout Standard
The problem with current programming languages, notably Java and C# is that
 they run on top of virtual machines or utilise some form of JIT compilation,
 negating any direct control of the CPU and cache management functions.
 Even C++ applications lack cache management functions (unless you utilise
 inline assembler in your application).
 The way to work with these languages is to exploit the nature of the CPU's
 cache management engine to your advantage.
\end_layout

\begin_layout Standard
The CPUs cache management engine works by loading the contents of most recently
 accessed memory address into the cache in either 32byte chunks for the
 level 1 cache, or 4kilobyte chunks for the level 2 and 3 caches.
 To ensure that the next memory address is located in the cache, ensure
 that the next array element to access is located very close of the last
 one accessed.
 When the CPU cache management engine sees your last access was on a border
 of a chunk it will load in the next chunk in a linear fashion based on
 the last accessed memory address.
\end_layout

\begin_layout Standard
Therefore the to gain the best possible performance when dealing with arrays,
 either utilise very small arrays that will fit into the level 1 cache,
 or only access arrays in a linear fashion row by row.
\end_layout

\begin_layout Standard
To illustrate these cache performance aspects, the application in Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Array-Access-Performance"

\end_inset

 yeilds the results show in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Array-Access-Performance"

\end_inset

.
 As can be seen, when dealing with a 16384 
\begin_inset Formula $\times$
\end_inset

 16384 sized array (consuming 256MB), accessing the array row by row takes
 1.35 seconds, however accessing it column by column takes just over 16 seconds.
 This clearly demonstrates the caches hits/misses taking place and confirms
 the latencies expected by the cache misses.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

#include <time.h>
\end_layout

\begin_layout Plain Layout

#include <stdio.h> 
\end_layout

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

char array1[1024][1204]; 
\end_layout

\begin_layout Plain Layout

char array2[2048][2048]; 
\end_layout

\begin_layout Plain Layout

char array3[4096][4096]; 
\end_layout

\begin_layout Plain Layout

char array4[8192][8192]; 
\end_layout

\begin_layout Plain Layout

char array5[16384][16384];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Row by row.
\end_layout

\begin_layout Plain Layout

  clock_t start = clock();
\end_layout

\begin_layout Plain Layout

  for (int y = 0; y < 1024; y++) {
\end_layout

\begin_layout Plain Layout

    for (int x = 0; x < 1023; x++) {
\end_layout

\begin_layout Plain Layout

      array1[y][x] = array1[y][x + 1];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  clock_t end = clock();
\end_layout

\begin_layout Plain Layout

  long elapsed = (long) (end - start) / (CLOCKS_PER_SEC / 1000);
\end_layout

\begin_layout Plain Layout

  printf("1MB row time = %dmsec
\backslash
n", elapsed);
\end_layout

\begin_layout Plain Layout

  // Column by Column
\end_layout

\begin_layout Plain Layout

  start = clock();
\end_layout

\begin_layout Plain Layout

  for (int x = 0; x < 1024; x++) {
\end_layout

\begin_layout Plain Layout

    for (int y = 0; y < 1023; y++) {
\end_layout

\begin_layout Plain Layout

      array1[y][x] = array1[y + 1][x];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  end = clock();
\end_layout

\begin_layout Plain Layout

  elapsed = (long) (end - start) / (CLOCKS_PER_SEC / 1000);
\end_layout

\begin_layout Plain Layout

  printf("1MB col time = %dmsec
\backslash
n", elapsed);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // ....
 <snip 4MB, 16MB and 64MB loops
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // 256MB Row by row.
\end_layout

\begin_layout Plain Layout

  start = clock();
\end_layout

\begin_layout Plain Layout

  for (int y = 0; y < 16384; y++) {
\end_layout

\begin_layout Plain Layout

    for (int x = 0; x < 16383; x++) {
\end_layout

\begin_layout Plain Layout

      array5[y][x] = array5[y][x + 1];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  end = clock();
\end_layout

\begin_layout Plain Layout

  elapsed = (long) (end - start) / (CLOCKS_PER_SEC / 1000);
\end_layout

\begin_layout Plain Layout

  printf("256MB row time = %dmsec
\backslash
n", elapsed);
\end_layout

\begin_layout Plain Layout

  // Column by Column
\end_layout

\begin_layout Plain Layout

  start = clock();
\end_layout

\begin_layout Plain Layout

  for (int x = 0; x < 16384; x++) {
\end_layout

\begin_layout Plain Layout

    for (int y = 0; y < 16383; y++) {
\end_layout

\begin_layout Plain Layout

      array5[y][x] = array5[y + 1][x];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  end = clock();
\end_layout

\begin_layout Plain Layout

  elapsed = (long) (end - start) / (CLOCKS_PER_SEC / 1000);
\end_layout

\begin_layout Plain Layout

  printf("256MB col time = %dmsec
\backslash
n", elapsed);
\end_layout

\begin_layout Plain Layout

  return 0;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption

\begin_layout Plain Layout
Array Access Performance (C++)
\begin_inset CommandInset label
LatexCommand label
name "lis:Array-Access-Performance"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Row x Row
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Column x Column
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1024 
\begin_inset Formula $\times$
\end_inset

 1024 (1MB)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
~0 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
10 msec
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2048 
\begin_inset Formula $\times$
\end_inset

 2048 (4MB)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
20 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
220 msec
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
4096 
\begin_inset Formula $\times$
\end_inset

 4096 (16MB)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
90 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
830 msec
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
8192 
\begin_inset Formula $\times$
\end_inset

 8192 (64MB)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
350 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
4150 msec
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
16384 
\begin_inset Formula $\times$
\end_inset

 16384 (256MB)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1350 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
16080 msec
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Array Access Performance
\begin_inset CommandInset label
LatexCommand label
name "tab:Array-Access-Performance"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Array Traversal Methods
\end_layout

\begin_layout Standard
Any 2-dimension array, can be accessing in a variety of ways, including
 column-wise, row-wise and starting from the top to bottom, bottom to top,
 left to right and right to left.
\end_layout

\begin_layout Standard
As seen in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Array-Access-Performance"

\end_inset

, row-wise and column-wise access methods where undertaken in a top to bottom,
 left to right fashion.
 Formalised algorithms for row-wise and column-wise access are shown in
 Algorithms 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Row-wise-Traversal-of"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Column-wise-Traversal-of"

\end_inset

 respectively.
\end_layout

\begin_layout Standard
To change from a left to right, to a right to left access pattern, simply
 count down from the width value to 0 for columns.
 To change from top to bottom, to a bottom to top access pattern, simply
 count down from the height value to 0 for rows.
\end_layout

\begin_layout Standard
The same applies to any 2+ dimensional array, to change the direction of
 travsel, either change from counting from 0 to width/height to counting
 down from the width/height to 0, and vice versa.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require A source matrix $S$, with $n$ by $m$ elements.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Prints value in element of matrix
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{MatrixRowWiseTraversal}{$S, n, m$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$row$ = 0 to $m-1$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$column$ = 0 to $n-1$}
\end_layout

\begin_layout Plain Layout


\backslash
State {print $S[row][column]$}
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Row-wise Traversal of an Array
\begin_inset CommandInset label
LatexCommand label
name "alg:Row-wise-Traversal-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require A source matrix $S$, with $n$ by $m$ elements.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Prints value in element of matrix
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{MatrixColumnWiseTraversal}{$S, n, m$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$column$ = 0 to $n-1$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$row$ = 0 to $m-1$}
\end_layout

\begin_layout Plain Layout


\backslash
State {print $S[row][column]$}
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Column-wise Traversal of an Array
\begin_inset CommandInset label
LatexCommand label
name "alg:Column-wise-Traversal-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Diagonal Traversal of an Array
\end_layout

\begin_layout Standard
Diagonal traversal of an array is used for many areas including image analysis,
 map scanning, simple path finding methods
\begin_inset Foot
status open

\begin_layout Plain Layout
There are more comprehensive path finding techniques that utilise graphs/network
s, so these methods are not commonly used.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The one issue with this form of travesal through an array, are the underlying
 performance penalities that will occur due to cache misses, as each subsequent
 access to the array is non-linear.
 Like other array travesal techniques, diagonal traverse is an 
\series bold
O(n
\begin_inset script superscript

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset

)
\series default
 operation.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require A source matrix $S$, with $n$ by $m$ elements.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Prints value in element of matrix
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{MatrixDiagonalTraversal}{$S, n, m$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$x 
\backslash
leftarrow 0$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$y 
\backslash
leftarrow 0$}
\end_layout

\begin_layout Plain Layout


\backslash
While {
\backslash
texttt{True}}
\end_layout

\begin_layout Plain Layout


\backslash
State {$v 
\backslash
leftarrow x$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$w 
\backslash
leftarrow y$}
\end_layout

\begin_layout Plain Layout


\backslash
While {$v 
\backslash
geq 0$ 
\backslash
textbf{and} $w < m$}
\end_layout

\begin_layout Plain Layout


\backslash
State {print $S[w][v]$} 
\backslash
Comment {$S$[row][column]}
\end_layout

\begin_layout Plain Layout


\backslash
State {$v 
\backslash
leftarrow v-1$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$w 
\backslash
leftarrow w+1$}
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
If {$x < n -1$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$x 
\backslash
leftarrow x+1$}
\end_layout

\begin_layout Plain Layout


\backslash
ElsIf {$y < m -1$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$y 
\backslash
leftarrow y+1$}
\end_layout

\begin_layout Plain Layout


\backslash
Else
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
textbf{return}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Diagonal Traversal of an Array
\begin_inset CommandInset label
LatexCommand label
name "alg:Diagonal-Traversal-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
As described in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Diagonal-Traversal-of"

\end_inset

, the algorithm utilises two loops, with the first loop (
\family typewriter
while(true)
\family default
) determines the start position of the traverse, and the second while loop
 traverses the actual slice, starting from the top and moving downwards
 and to the left, (as denoted by the 
\begin_inset ERT
status open

\begin_layout Plain Layout

$v 
\backslash
leftarrow v-1$
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

{$w 
\backslash
leftarrow w+1$}
\end_layout

\end_inset

 operations).
\end_layout

\begin_layout Standard
The 
\family typewriter
if-else-if-else
\family default
 statements recalculate the new start position for the next travesal, until
 the new start position exceeds the bounds of the array, in which case the
 algorithm exits.
\end_layout

\begin_layout Standard
The algorithm as described, starts in the top left corner, and moves towards
 the bottom right of the array.
 To modify the algorithm to scan from other origins to opposite corner,
 the line to be altered is the access function that prints the current element
 in the array.
 The start at the various origins and traverse to the opposite corner, the
 following forms are needed for the print function:
\end_layout

\begin_layout Itemize
Top-left origin to bottom-right traverse: 
\begin_inset ERT
status open

\begin_layout Plain Layout

print $S[w][v]$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Bottom-left origin to top-right traverse: 
\begin_inset ERT
status open

\begin_layout Plain Layout

print $S[m-w-1][v]$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Top-right origin to bottom-left traverse: 
\begin_inset ERT
status open

\begin_layout Plain Layout

print $S[w][n-v-1]$
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Bottom-right origin to top-left traverse: 
\begin_inset ERT
status open

\begin_layout Plain Layout

print $S[m-w-1][n-v-1]$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Diagonal-Traversal-of-1"

\end_inset

 demonstrates the top-left origin to bottom-right traversel on a 3 
\begin_inset Formula $\times$
\end_inset

 4 array, with each slice (or starting location) shown.
\end_layout

\begin_layout Standard
The order of traversel for the other origins would result in the following
 sequences based on the forms listed above:
\end_layout

\begin_layout Itemize
Top-left origin to bottom-right traverse: 
\family typewriter
a, b, d, c, e, g, f, h, j, i, k, l
\end_layout

\begin_layout Itemize
Bottom-left origin to top-right traverse: 
\family typewriter
j, k, g, l, h, d, i, e, a, f, b, c
\end_layout

\begin_layout Itemize
Top-right origin to bottom-left traverse: 
\family typewriter
c, b, f, a, e, i, d, h, l, g, k, j
\end_layout

\begin_layout Itemize
Bottom-right origin to top-left traverse: 
\family typewriter
l, k, i, j, h, f, g, e, c, d, b, a
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Array Diagonal.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Diagonal Traversal of an Array with a Top-Left Origin
\begin_inset CommandInset label
LatexCommand label
name "fig:Diagonal-Traversal-of-1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Diagonal-Traversal-of"

\end_inset

 demonstrates the implementation of the algorithm as described.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static void ArrayDiagonalTraverse(int[][] matrix, int width, int
 height){
\end_layout

\begin_layout Plain Layout

  int start_x = 0;
\end_layout

\begin_layout Plain Layout

  int start_y = 0;
\end_layout

\begin_layout Plain Layout

  int column;
\end_layout

\begin_layout Plain Layout

  int row;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Keep looping until exit condition.
\end_layout

\begin_layout Plain Layout

  while (true) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   // Initialise the starting location in the matrix for the current slice.
\end_layout

\begin_layout Plain Layout

   column = start_x;
\end_layout

\begin_layout Plain Layout

   row = start_y;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   // Traverse the current slice.
\end_layout

\begin_layout Plain Layout

   while (column >= 0 && row < height) {
\end_layout

\begin_layout Plain Layout

     System.out.printf("%d ", matrix[row][column]);
\end_layout

\begin_layout Plain Layout

     column--;
\end_layout

\begin_layout Plain Layout

     row++;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   // Update the start location for the next slice.
\end_layout

\begin_layout Plain Layout

   if (start_x < width - 1) {
\end_layout

\begin_layout Plain Layout

     start_x++;
\end_layout

\begin_layout Plain Layout

   } else if (start_y < height - 1) {
\end_layout

\begin_layout Plain Layout

     start_y++;
\end_layout

\begin_layout Plain Layout

   } else {
\end_layout

\begin_layout Plain Layout

     // Exit the method, as start locations are now out of matrix bounds.
\end_layout

\begin_layout Plain Layout

     break;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption

\begin_layout Plain Layout
Diagonal Traversal of an Array (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Diagonal-Traversal-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Array Rotation
\end_layout

\begin_layout Standard
As shown in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Array-Performance"

\end_inset

, the way that an array is accessed can effect the performance of your applicati
on.
 Methods to ensure that you can access an array row by row may require rotation
 of an array, or alternatively rotation of an array may be needed to utilise
 an algorithm or math function.
\end_layout

\begin_layout Standard
Any array rotation or mirroring function requires two copies of the array
 to be present at one time, the source array and target array.
 This must be considered in relation to the amount of memory required, as
 you effectively need double the memory requirement for either operation.
\end_layout

\begin_layout Standard
Both rotation and mirroring functions are 
\series bold
O(n
\begin_inset script superscript

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset

)
\series default
 operations, due to all array members must be accessed to complete the opeation
 successfully.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require A source matrix $S$, with $n$ by $m$ elements, with target matrix
 $T$, with $m$ by $n$ elements.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Matrix $T$ represents matrix $S$ rotated 90
\backslash
textdegree  clockwise.
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{RotateMatrixClockwise}{$S, T, n, m$}
\end_layout

\begin_layout Plain Layout


\backslash
State $f 
\backslash
leftarrow m-1$
\end_layout

\begin_layout Plain Layout


\backslash
For {$y$ = 0 to $m-1$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$x$ = 0 to $n-1$}
\end_layout

\begin_layout Plain Layout


\backslash
State $T[x][(f-y)] 
\backslash
leftarrow S[y][x]$ 
\backslash
Comment{$S$[row][column]}
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Array Rotation Clockwise
\begin_inset CommandInset label
LatexCommand label
name "alg:Array-Rotation-Clockwise"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require A source matrix $S$, with $n$ by $m$ elements, with target matrix
 $T$, with $m$ by $n$ elements.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Matrix $T$ represents matrix $S$ rotated 90
\backslash
textdegree  anti-clockwise.
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{RotateMatrixAntiClockwise}{$S, T, n, m$}
\end_layout

\begin_layout Plain Layout


\backslash
State $f 
\backslash
leftarrow n-1$
\end_layout

\begin_layout Plain Layout


\backslash
For {$x$ = 0 to $n-1$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$y$ = 0 to $m-1$}
\end_layout

\begin_layout Plain Layout


\backslash
State $T[(f-x)][y] 
\backslash
leftarrow S[y][x]$
\backslash
Comment{$S$[row][column]}
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Array Rotation AntiClockwise
\begin_inset CommandInset label
LatexCommand label
name "alg:Array-Rotation-AntiClockwise"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
Algoritms 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Array-Rotation-Clockwise"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Array-Rotation-AntiClockwise"

\end_inset

 depict both clockwise and anti-clock array rotation respectively.
 Simply, both perform substitution of x and y values for the target array.
 An additional variable is needed to hold an offset, so that the new array
 offsets may be calculated correctly
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
While this is not necessary, it make for slightly cleaner code.
\end_layout

\end_inset

.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Array-Rotation-Diagram"

\end_inset

 shows the clockwise rotation operation in effect.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Array Rotation.eps
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Array Rotation
\begin_inset CommandInset label
LatexCommand label
name "fig:Array-Rotation-Diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Array-Clockwise-Rotation"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Array-Anti-Clockwise-Rotation"

\end_inset

 show implementations of clockwise and anticlockwise rotation respectively.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

public void ArrayRotateClockWise(E[][] source, E[][] target, int width,
 int height){
\end_layout

\begin_layout Plain Layout

  int factor = height-1;
\end_layout

\begin_layout Plain Layout

  for (int y = 0; y < height; y++) {
\end_layout

\begin_layout Plain Layout

    for (int x = 0; x < width; x++) {
\end_layout

\begin_layout Plain Layout

      target[x][(factor-y)] = source[y][x];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption

\begin_layout Plain Layout
Array Clockwise Rotation (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Array-Clockwise-Rotation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

public void ArrayAntiRotateClockWise(E[][] source, E[][] target, int width,
 int height){
\end_layout

\begin_layout Plain Layout

  int factor = width-1;
\end_layout

\begin_layout Plain Layout

  for (int x = 0; x < width; x++) {
\end_layout

\begin_layout Plain Layout

    for (int y = 0; y < height; y++) {
\end_layout

\begin_layout Plain Layout

      target[(factor-x)][y] = source[y][x];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption

\begin_layout Plain Layout
Array Anti-Clockwise Rotation (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Array-Anti-Clockwise-Rotation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Performance of both of these implementations will suffer due to access not
 being performed in a row by row fashion, which limits the viability of
 the above algorithms.
 However they should still be considered and used, when the many operations
 are performed on the resulting array, rather than single use post rotation.
\end_layout

\begin_layout Paragraph
Sample Problem- Matrix Rotation 
\begin_inset CommandInset label
LatexCommand label
name "par:SP-Linear-Search-1"

\end_inset


\end_layout

\begin_layout Standard
Given a two dimension matrix measuring n 
\begin_inset Formula $\times$
\end_inset

 m, rotate the matrix in a clockwise direction.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
Input consists of one or more lines, with the first line being the size
 of the matrix to rotate in width and height.
 The width and height will be in a range between 0 and 79.
 The application should exit when the size given is 
\begin_inset Quotes eld
\end_inset

0 0
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The following lines denote the matrix to be rotated, with each element being
 a 1 or 0, separated by a space.
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
3 3
\begin_inset Newline newline
\end_inset

1 0 1
\begin_inset Newline newline
\end_inset

0 0 0
\begin_inset Newline newline
\end_inset

1 0 0
\begin_inset Newline newline
\end_inset

2 2
\begin_inset Newline newline
\end_inset

1 0
\begin_inset Newline newline
\end_inset

0 1
\begin_inset Newline newline
\end_inset

0 0 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
The output of each rotation should be the resultant matrix, without spaces
 between each column in the matrix.
 There must a blank line separating each resultant matrix.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
101
\begin_inset Newline newline
\end_inset

000
\begin_inset Newline newline
\end_inset

001
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

00
\begin_inset Newline newline
\end_inset

01
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Solution
\end_layout

\begin_layout Standard
A solution to the sample problem utilising an array rotation can be seen
 in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Array-Flip"

\end_inset

.
 The solution performs the following:
\end_layout

\begin_layout Enumerate
Reads in the width and height values.
 If these are not 0 and 0, continue the main loop body, otherwise exit.
\end_layout

\begin_layout Enumerate
If either of the values is 0, (indicating a 0 width or height), skip attempting
 to read in a matrix, and go back to step 1.
\end_layout

\begin_layout Enumerate
Create a new array of size width, height to hold integers.
 Read in the values from stdin, and fill in these values into the respective
 position within the array.
\end_layout

\begin_layout Enumerate
Create a new array to hold the result of the rotation.
 Rotate the array, and print the results.
 Goto step 1.
\end_layout

\begin_layout Standard
As this challenge is very simple, the only issue to account for is if either
 the width or height is given as 0 (zero), in which case a blank line should
 be returned.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

public class ArrayRotation {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Rotate an Array in a clockwise direction
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param source The source array
\end_layout

\begin_layout Plain Layout

   * @param target The target array
\end_layout

\begin_layout Plain Layout

   * @param width The width of the source array
\end_layout

\begin_layout Plain Layout

   * @param height The height of the target array
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void ArrayRotateClockWise(int[][] source, int[][] target,
 
\end_layout

\begin_layout Plain Layout

                                          int width, int height) {
\end_layout

\begin_layout Plain Layout

    int factor = height - 1;
\end_layout

\begin_layout Plain Layout

    for (int y = 0; y < height; y++) {
\end_layout

\begin_layout Plain Layout

      for (int x = 0; x < width; x++) {
\end_layout

\begin_layout Plain Layout

        target[x][(factor - y)] = source[y][x];
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // get the size of the matrix to rotate.
\end_layout

\begin_layout Plain Layout

    String matrixSizeLine = in.nextLine();
\end_layout

\begin_layout Plain Layout

    Scanner matrixSize = new Scanner(matrixSizeLine);
\end_layout

\begin_layout Plain Layout

    int width = matrixSize.nextInt();
\end_layout

\begin_layout Plain Layout

    int height = matrixSize.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Keep reading in a matrix until exit condition 
\end_layout

\begin_layout Plain Layout

   while (!((width == 0) && (height == 0))) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Ignore the line if either width or height = 0.
\end_layout

\begin_layout Plain Layout

      if (!((width == 0) || (height == 0))) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Read in our matrix.
\end_layout

\begin_layout Plain Layout

        int[][] matrix = new int[height][width];
\end_layout

\begin_layout Plain Layout

        for (int count = 0; count < height; count++) {
\end_layout

\begin_layout Plain Layout

          String[] matrixLine = in.nextLine().split("
\backslash

\backslash
s+");
\end_layout

\begin_layout Plain Layout

          for (int element = 0; element < matrixLine.length; element++) {
\end_layout

\begin_layout Plain Layout

            matrix[count][element] = Integer.parseInt(matrixLine[element]);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Rotate the matrix and print.
\end_layout

\begin_layout Plain Layout

        int[][] target = new int[width][height];
\end_layout

\begin_layout Plain Layout

        ArrayRotateClockWise(matrix, target, width, height);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Print the resultant matrix.
\end_layout

\begin_layout Plain Layout

        for (int row = 0; row < width; row++) {
\end_layout

\begin_layout Plain Layout

          for (int column = 0; column < height; column++) {
\end_layout

\begin_layout Plain Layout

            System.out.print(target[row][column]);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          System.out.println();
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Print line between each matrix output
\end_layout

\begin_layout Plain Layout

        System.out.println();
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      // get the size of the matrix to rotate.
\end_layout

\begin_layout Plain Layout

      matrixSizeLine = in.nextLine();
\end_layout

\begin_layout Plain Layout

      matrixSize = new Scanner(matrixSizeLine);
\end_layout

\begin_layout Plain Layout

      width = matrixSize.nextInt();
\end_layout

\begin_layout Plain Layout

      height = matrixSize.nextInt();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

} 
\begin_inset Caption

\begin_layout Plain Layout
Solution to Array Rotation Problem (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Array"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Array Mirroring or Flipping
\end_layout

\begin_layout Standard
Array mirroring or flipping is a very simple technique, that simply requires
 a offset to be calculated from the current height or width value.
 Typically, to calculate the mirror location, we simple subtract the current
 source column (or row) value from the width (or height) size to calculate
 the target location.
 Algorithms 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Array-Mirror-Vertical"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Array-Mirror-Horizon"

\end_inset

 depict mirroring along the vertical axis and horizontal axis respectively.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require A source matrix $S$, with $n$ by $m$ elements, with target matrix
 $T$, with $n$ by $m$ elements.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Matrix $T$ represents matrix $S$ mirrored along a vertical axis
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{MirrorMatrixVeritcal}{$S, T, n, m$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$y$ = 0 to $m-1$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$x$ = 0 to $n-1$}
\end_layout

\begin_layout Plain Layout


\backslash
State $T[m-y-1][x] 
\backslash
leftarrow S[y][x]$ 
\backslash
Comment{$S$[row][column]}
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Mirror Array Along Vertical Axis
\begin_inset CommandInset label
LatexCommand label
name "alg:Array-Mirror-Vertical"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic} 
\end_layout

\begin_layout Plain Layout


\backslash
Require A source matrix $S$, with $n$ by $m$ elements, with target matrix
 $T$, with $n$ by $m$ elements.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Matrix $T$ represents matrix $S$ mirrored along a horizontal axis
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{MirrorMatrixHorizontal}{$S, T, n, m$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$y$ = 0 to $m-1$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$x$ = 0 to $n-1$}
\end_layout

\begin_layout Plain Layout


\backslash
State $T[y][n-x-1] 
\backslash
leftarrow S[y][x]$ 
\backslash
Comment{$S$[row][column]}
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Mirror Array Along Horizontal Axis
\begin_inset CommandInset label
LatexCommand label
name "alg:Array-Mirror-Horizon"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As both of these algorithms access both the source and target arrays row
 by row, there should be no (or few) performance penalities due to cache
 misses.
\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
Algoritms 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Array-Mirror-Vertical"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Array-Mirror-Horizon"

\end_inset

 depict both vertical and horizontal flipping respectively.
 Simply, both perform substitution of x and y values for the target array.
 Figure shows the clockwise rotation operation in effect.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Array Flip.eps
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Array Flipping
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Mirror-Array-Along-1"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Mirror-Array-Along"

\end_inset

 show implementations of vertical and horizontal mirroing respectively.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

public void ArrayVerticalFlip(E[][] source, E[][] target, int width, int
 height){
\end_layout

\begin_layout Plain Layout

  for (int y = 0; y < height; y++) {
\end_layout

\begin_layout Plain Layout

    for (int x = 0; x < width; x++) {
\end_layout

\begin_layout Plain Layout

      target[(height-y-1)][x] = source[y][x];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption

\begin_layout Plain Layout
Mirror Array Along Vertical Axis(Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Mirror-Array-Along-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

public void ArrayHorizontalFlip(E[][] source, E[][] target, int width, int
 height){
\end_layout

\begin_layout Plain Layout

  for (int y = 0; y < height; y++) {
\end_layout

\begin_layout Plain Layout

    for (int x = 0; x < width; x++) {
\end_layout

\begin_layout Plain Layout

      target[y][(width-x-1)] = source[y][x];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption

\begin_layout Plain Layout
Mirror Array Along Horizontal Axis(Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Mirror-Array-Along"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem- Matrix Flipping
\end_layout

\begin_layout Standard
Given a two dimension matrix measuring n 
\begin_inset Formula $\times$
\end_inset

 m, flip the matrix in a vertical direction, followed by a horizontal direction.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
Input consists of one or more lines, with the first line being the size
 of the matrix to flip in width and height.
 The width and height will be in a range between 0 and 79.
 The application should exit when the size given is 
\begin_inset Quotes eld
\end_inset

0 0
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The following lines denote the matrix to be flipped, with each element being
 a 1 or 0, separated by a space.
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
3 3
\begin_inset Newline newline
\end_inset

1 0 1
\begin_inset Newline newline
\end_inset

0 0 0
\begin_inset Newline newline
\end_inset

1 0 0
\begin_inset Newline newline
\end_inset

2 2
\begin_inset Newline newline
\end_inset

1 0
\begin_inset Newline newline
\end_inset

0 1
\begin_inset Newline newline
\end_inset

0 0 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
The output of each flip operation should be the resultant matrix, without
 spaces between each column in the matrix.
 There must a blank line separating each resultant matrix.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
001
\begin_inset Newline newline
\end_inset

000
\begin_inset Newline newline
\end_inset

101
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

00
\begin_inset Newline newline
\end_inset

10
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Solution
\end_layout

\begin_layout Standard
A solution to the sample problem utilising an array rotation can be seen
 in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Array-Flip"

\end_inset

.
 The solution performs the following:
\end_layout

\begin_layout Enumerate
Reads in the width and height values.
 If these are not 0 and 0, continue the main loop body, otherwise exit.
\end_layout

\begin_layout Enumerate
If either of the values is 0, (indicating a 0 width or height), skip attempting
 to read in a matrix, and go back to step 1.
\end_layout

\begin_layout Enumerate
Create a new array of size width, height to hold integers.
 Read in the values from stdin, and fill in these values into the respective
 position within the array.
\end_layout

\begin_layout Enumerate
Create a new array to hold the result of the flip.
 Flip the array vertically, then horizontally, and print the results.
 Goto step 1.
\end_layout

\begin_layout Standard
As this challenge is very simple, the only issue to account for is if either
 the width or height is given as 0 (zero), in which case a blank line should
 be returned.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class ArrayFlip {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Flip an Array in a vertical direction
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param source The source array
\end_layout

\begin_layout Plain Layout

   * @param target The target array
\end_layout

\begin_layout Plain Layout

   * @param width The width of the source array
\end_layout

\begin_layout Plain Layout

   * @param height The height of the source array
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void ArrayVerticalFlip(int[][] source, int[][] target, int
 width, 
\end_layout

\begin_layout Plain Layout

                                       int height) {
\end_layout

\begin_layout Plain Layout

    for (int y = 0; y < height; y++) {
\end_layout

\begin_layout Plain Layout

      for (int x = 0; x < width; x++) {
\end_layout

\begin_layout Plain Layout

        target[(height - y - 1 )][x] = source[y][x];
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Flip an Array in a horizontal direction
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param source The source array
\end_layout

\begin_layout Plain Layout

   * @param target The target array
\end_layout

\begin_layout Plain Layout

   * @param width The width of the source array
\end_layout

\begin_layout Plain Layout

   * @param height The height of the source array
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void ArrayHorizontalFlip(int[][] source, int[][] target,
 int width, 
\end_layout

\begin_layout Plain Layout

                                         int height) {
\end_layout

\begin_layout Plain Layout

    for (int y = 0; y < height; y++) {
\end_layout

\begin_layout Plain Layout

      for (int x = 0; x < width; x++) {
\end_layout

\begin_layout Plain Layout

        target[y][(width - x - 1)] = source[y][x];
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // get the size of the matrix to rotate.
\end_layout

\begin_layout Plain Layout

    String matrixSizeLine = in.nextLine();
\end_layout

\begin_layout Plain Layout

    Scanner matrixSize = new Scanner(matrixSizeLine);
\end_layout

\begin_layout Plain Layout

    int width = matrixSize.nextInt();
\end_layout

\begin_layout Plain Layout

    int height = matrixSize.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Keep reading in a matrix until exit condition
\end_layout

\begin_layout Plain Layout

    while (!((width == 0) && (height == 0))) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Ignore the line if either width or height = 0.
\end_layout

\begin_layout Plain Layout

      if (!((width == 0) || (height == 0))) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Read in our matrix.
\end_layout

\begin_layout Plain Layout

        int[][] matrix = new int[height][width];
\end_layout

\begin_layout Plain Layout

        for (int count = 0; count < height; count++) {
\end_layout

\begin_layout Plain Layout

          String[] matrixLine = in.nextLine().split("
\backslash

\backslash
s+");
\end_layout

\begin_layout Plain Layout

          for (int element = 0; element < matrixLine.length; element++) {
\end_layout

\begin_layout Plain Layout

            matrix[count][element] = Integer.parseInt(matrixLine[element]);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Flip the matrix and print.
\end_layout

\begin_layout Plain Layout

        int[][] target = new int[height][width];
\end_layout

\begin_layout Plain Layout

        ArrayVerticalFlip(matrix, target, width, height);
\end_layout

\begin_layout Plain Layout

        ArrayHorizontalFlip(target, matrix, width, height);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Print the resultant matrix.
\end_layout

\begin_layout Plain Layout

        for (int row = 0; row < width; row++) {
\end_layout

\begin_layout Plain Layout

          for (int column = 0; column < height; column++) {
\end_layout

\begin_layout Plain Layout

            System.out.print(matrix[row][column]);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          System.out.println();
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Print line between each matrix output
\end_layout

\begin_layout Plain Layout

        System.out.println();
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // get the size of the matrix to rotate.
\end_layout

\begin_layout Plain Layout

      matrixSizeLine = in.nextLine();
\end_layout

\begin_layout Plain Layout

      matrixSize = new Scanner(matrixSizeLine);
\end_layout

\begin_layout Plain Layout

      width = matrixSize.nextInt();
\end_layout

\begin_layout Plain Layout

      height = matrixSize.nextInt();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

} 
\begin_inset Caption

\begin_layout Plain Layout
Solution to Array Flipping Problem (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Array-Flip"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Advanced Algorithms
\end_layout

\begin_layout Subsection
Simple Maths
\end_layout

\begin_layout Subsubsection
Greatest common divisor
\end_layout

\begin_layout Standard
The Greatest Common Divisor or Eucilidean algorithm was originally developed
 by Euclid of Alexandria in 3
\begin_inset script superscript

\begin_layout Plain Layout
rd
\end_layout

\end_inset

 BC, and computes the greatest common divisor of two non-negative, not-both-zero
 integers 
\family typewriter
m
\family default
 and 
\family typewriter
n
\family default
, that is the largest integer that divides both 
\family typewriter
m
\family default
 and 
\family typewriter
n
\family default
 
\shape italic
evenly
\shape default
.
\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
The Euclidean algorithm is based on the principle that the greatest common
 divisor of two numbers does not change if the smaller number is subtracted
 from the larger number.
 For if k, m, and n are integers, and k is a common factor of two integers
 A and B, then A=(n×k) and B=(m×k) implies A-B=(n-m)×k, therefore k is also
 a common factor of the difference.
 That k may also represent the greatest common divisor is proven below.
 For example, 21 is the GCD of 252 and 105 (252 = 12 × 21; 105 = 5 × 21);
 since 252 − 105 = (12 - 5) × 21 = 147, the GCD of 147 and 105 is also 21.
\end_layout

\begin_layout Standard
Since the larger of the two numbers is reduced, repeating this process gives
 successively smaller numbers until one of them is zero.
 When that occurs, the GCD is the remaining nonzero number.
 By reversing the steps in the Euclidean algorithm, the GCD can be expressed
 as a sum of the two original numbers each multiplied by a positive or negative
 integer, e.g., 21 = [5 × 105] + [(−2) × 252].
\end_layout

\begin_layout Standard
Iterative and recursive implementations of the algorithm are shown in Algorithms
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Euclidean-Algorithm-Iterative"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Euclidean-Algorithm-Recursive"

\end_inset

 respectively.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require Positives integers $m$ and $n$ which may share a common divisor
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Greatest Common Divisor, being $n 
\backslash
geq 1$
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Euclid}{$m,n$}
\end_layout

\begin_layout Plain Layout


\backslash
While{$n
\backslash
not=0$}
\backslash
Comment{We have the answer if n is 0} 
\end_layout

\begin_layout Plain Layout


\backslash
State $r
\backslash
gets m
\backslash
bmod n$ 
\end_layout

\begin_layout Plain Layout


\backslash
State $m
\backslash
gets n$ 
\end_layout

\begin_layout Plain Layout


\backslash
State $n
\backslash
gets r$ 
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
textbf{return} $m$
\backslash
Comment{The gcd is m} 
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure 
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Euclidean Algorithm (Iterative)
\begin_inset CommandInset label
LatexCommand label
name "alg:Euclidean-Algorithm-Iterative"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Euclid}{$m,n$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$n = 0$}
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
textbf{return} $m$
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
textbf{return} gcd($n, m
\backslash
bmod n$)
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Euclidean Algorithm (Recursive)
\begin_inset CommandInset label
LatexCommand label
name "alg:Euclidean-Algorithm-Recursive"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
An implementation of the iterative form of the algorithm can be found in
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Euclidean-Algorithm-(Java)"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

public static int gcd(int m, int n) {
\end_layout

\begin_layout Plain Layout

  int r;
\end_layout

\begin_layout Plain Layout

  while (n != 0) {
\end_layout

\begin_layout Plain Layout

    r = m % n;
\end_layout

\begin_layout Plain Layout

    m = n;
\end_layout

\begin_layout Plain Layout

    n = r;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return m;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption

\begin_layout Plain Layout
Euclidean Algorithm (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Euclidean-Algorithm-(Java)"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem - GCD
\end_layout

\begin_layout Standard
Calculate the GCD of two integers.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
The first line of input will be 
\shape italic
N
\shape default
 (1 <= 
\shape italic
N
\shape default
 <= 1000), the number of test cases to run.
 On each of the next 
\shape italic
N
\shape default
 lines will be two integers m and n (0 <= 
\shape italic
m, n 
\shape default
<= 2
\begin_inset script superscript

\begin_layout Plain Layout
31
\end_layout

\end_inset

 - 1).
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
3 
\begin_inset Newline newline
\end_inset

12 60
\begin_inset Newline newline
\end_inset

60 24
\begin_inset Newline newline
\end_inset

3 5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
Output the greatest common denominator of 
\shape italic
m
\shape default
 and 
\shape italic
n
\shape default
, one value on each line.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
12
\begin_inset Newline newline
\end_inset

12
\begin_inset Newline newline
\end_inset

1
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Solution
\end_layout

\begin_layout Standard
The solution to this problem utilising Euclid's GCD algorithm can be seen
 in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-GCD"

\end_inset

.
\end_layout

\begin_layout Standard
Whilst this solution/challenge is rather simple, the following test cases
 must be considered:
\end_layout

\begin_layout Enumerate
One or both values are 0 (zero).
\end_layout

\begin_layout Enumerate
There will be longer run times if one or both numbers are primes.
 (The GCD is 1 in this case).
\end_layout

\begin_layout Enumerate
The input range is 
\begin_inset Formula $0<m<2^{31}-1$
\end_inset

, which requires the use of at least a signed 32bit number (typically 
\family typewriter
int
\family default
 on all platforms).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

public class GCD {
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Compute the Greatest Common Divisor
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param m number 1, greater or equal to 0.
\end_layout

\begin_layout Plain Layout

   * @param n number 2, greater or equal to 0.
\end_layout

\begin_layout Plain Layout

   * @return the GCD
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static int EuclidGCD(int m, int n) {
\end_layout

\begin_layout Plain Layout

    int r;
\end_layout

\begin_layout Plain Layout

    while (n != 0) {
\end_layout

\begin_layout Plain Layout

      r = m % n;
\end_layout

\begin_layout Plain Layout

      m = n;
\end_layout

\begin_layout Plain Layout

      n = r;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return m;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // get first line and get the number of cases to test.
\end_layout

\begin_layout Plain Layout

    int caseCount = Integer.parseInt(in.nextLine());
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Keep reading each line while caseCount > 0
\end_layout

\begin_layout Plain Layout

    while (caseCount-- > 0) {
\end_layout

\begin_layout Plain Layout

      String line = in.nextLine();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // extract numbers ints
\end_layout

\begin_layout Plain Layout

      Scanner sc = new Scanner(line);
\end_layout

\begin_layout Plain Layout

      int a = sc.nextInt();
\end_layout

\begin_layout Plain Layout

      int b = sc.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Output the gcd for the two given numbers.
\end_layout

\begin_layout Plain Layout

      System.out.printf("%d%n", EuclidGCD(a,b));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

} 
\begin_inset Caption

\begin_layout Plain Layout
Solution to GCD Problem (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-GCD"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Sieve of Eratosthenes (prime number generation)
\end_layout

\begin_layout Standard
The brute force method of finding prime numbers to limit N, can be found
 by checking for divisibility of all numbers between 2 and 
\shape italic
N
\shape default
-1.
 There are however more efficient methods for finding prime numbers, including
 the use of Sieve's, in particulator the Sieve of Erathosthenes.
\end_layout

\begin_layout Standard
The Sieve of Erathosthenes, is a relatively simple algorithm, that performs
 prime number generation through iteration of composites based on the last
 prime found.
 This is done by maintaining an array of all numbers between 2 and 
\shape italic
N
\shape default
, and uses flags in each array slot to indicate if it's a prime, composite
 or unknown.
 
\end_layout

\begin_layout Standard
The Sieve of Erathosthenes is considered a 
\series bold
O(n log log n)
\series default
 operation, with a
\series bold
 O(n)
\series default
 memory requirement.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require Positives integer $n$ denoting upper limit for prime number search,
 and vector $S$ for list of prime numbers.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure All prime number $
\backslash
leq n$ stored in vector $S$.
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{Eratosthenes}{$n,S$}
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
textbf{define} vector $A$ of size $n$
\end_layout

\begin_layout Plain Layout


\backslash
For {$p 
\backslash
gets 2$ to $n$}
\end_layout

\begin_layout Plain Layout


\backslash
State $A[p] 
\backslash
gets p$
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
For {$p 
\backslash
gets 2$ to $
\backslash
lfloor 
\backslash
sqrt{n} 
\backslash
rfloor$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$A[p] 
\backslash
neq 0$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$j 
\backslash
gets p^{2}$}
\end_layout

\begin_layout Plain Layout


\backslash
While {$j 
\backslash
leq n$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$A[j] 
\backslash
gets 0$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$j 
\backslash
gets j + p$}
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
State {}
\end_layout

\begin_layout Plain Layout


\backslash
State {$i 
\backslash
gets 0$} 
\backslash
Comment {Copy list of primes from $A$ to $S$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$p 
\backslash
gets 2$ to $n$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$A[p] 
\backslash
neq 0$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$S[i] 
\backslash
gets A[p]$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$i 
\backslash
gets i + 1$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sieve of Eratosthenes
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
The algorithm utilises two arrays of numbers, one array that holds all numbers
 from 2 to 
\shape italic
N
\shape default
, and a second array that holds just the prime numbers from 2 to 
\shape italic
N
\shape default
.
\end_layout

\begin_layout Standard
The algorithm counts from 2 to 
\begin_inset Formula $\left\lfloor \sqrt{N}\right\rfloor $
\end_inset

, working on the array of all numbers from 2 to 
\shape italic
N
\shape default
.
 If the current field of the array is not 0 (that is, it's a known composite),
 it marks off all composites of the current number forward of the current
 position in the array of all numbers from 2 to 
\shape italic
N
\shape default
.
 During the main loop, we set the next composite value to be 
\begin_inset Formula $index^{2}$
\end_inset

, as all lower multiple of 
\begin_inset Formula $index$
\end_inset

, have already been flagged as being known.
 Once it has cycled through the array, all the numbers that are left are
 primes.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Demonstration-of-Sieve"

\end_inset

 demonstrates this on a list of numbers from 1 to 30.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout

\size small
First generate a list of integers from 2 to 30:
\end_layout

\begin_layout Plain Layout

\family typewriter
\size small
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align center

\family typewriter
\size small
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28
 29 30
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Plain Layout

\size small
First number in the list is 2; cross out every 2nd number in the list after
 it (by counting up in increments of 2), i.e.
 all the multiples of 2:
\end_layout

\begin_layout Plain Layout

\family typewriter
\size small
\strikeout on
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align center

\family typewriter
\size small
2 3 
\strikeout on
4
\strikeout default
 5 
\strikeout on
6
\strikeout default
 7 
\strikeout on
8
\strikeout default
 9 
\strikeout on
10
\strikeout default
 11 
\strikeout on
12
\strikeout default
 13 
\strikeout on
14
\strikeout default
 15 
\strikeout on
16
\strikeout default
 17 
\strikeout on
18
\strikeout default
 19 
\strikeout on
20
\strikeout default
 21 
\strikeout on
22
\strikeout default
 23 
\strikeout on
24
\strikeout default
 25 
\strikeout on
26
\strikeout default
 27 
\strikeout on
28
\strikeout default
 29 
\strikeout on
30
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Plain Layout

\size small
Next number in the list after 2 is 3; cross out every 3rd number in the
 list after it (by counting up in increments of 3), i.e.
 all the multiples of 3:
\end_layout

\begin_layout Plain Layout

\family typewriter
\size small
\strikeout on
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align center

\family typewriter
\size small
2 3 
\strikeout on
4
\strikeout default
 5 
\strikeout on
6
\strikeout default
 7 
\strikeout on
8
\strikeout default
 
\strikeout on
9
\strikeout default
 
\strikeout on
10
\strikeout default
 11 
\strikeout on
12
\strikeout default
 13 
\strikeout on
14
\strikeout default
 
\strikeout on
15
\strikeout default
 
\strikeout on
16
\strikeout default
 17 
\strikeout on
18
\strikeout default
 19 
\strikeout on
20
\strikeout default
 
\strikeout on
21
\strikeout default
 
\strikeout on
22
\strikeout default
 23 
\strikeout on
24
\strikeout default
 25 
\strikeout on
26
\strikeout default
 
\strikeout on
27
\strikeout default
 
\strikeout on
28
\strikeout default
 29 
\strikeout on
30
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Plain Layout

\size small
Next number not yet crossed out in the list after 3 is 5; cross out every
 5th number in the list after it (by counting up in increments of 5), i.e.
 all the multiples of 5:
\end_layout

\begin_layout Plain Layout

\family typewriter
\size small
\strikeout on
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align center

\family typewriter
\size small
2 3 
\strikeout on
4
\strikeout default
 5 
\strikeout on
6
\strikeout default
 7 
\strikeout on
8
\strikeout default
 
\strikeout on
9
\strikeout default
 
\strikeout on
10
\strikeout default
 11 
\strikeout on
12
\strikeout default
 13 
\strikeout on
14
\strikeout default
 
\strikeout on
15
\strikeout default
 
\strikeout on
16
\strikeout default
 17 
\strikeout on
18
\strikeout default
 19 
\strikeout on
20
\strikeout default
 
\strikeout on
21
\strikeout default
 
\strikeout on
22
\strikeout default
 23 
\strikeout on
24
\strikeout default
 
\strikeout on
25
\strikeout default
 
\strikeout on
26
\strikeout default
 
\strikeout on
27
\strikeout default
 
\strikeout on
28
\strikeout default
 29 
\strikeout on
30
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Plain Layout

\size small
Next number not yet crossed out in the list after 5 is 7; the next step
 would be to cross out every 7th number in the list after it, but they are
 all already crossed out at this point, as these numbers (14, 21, 28) are
 also multiples of smaller primes because 7*7 is greater than 30.
 The numbers left not crossed out in the list at this point are all the
 prime numbers below 30:
\end_layout

\begin_layout Plain Layout

\family typewriter
\size small
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align center

\family typewriter
\size small
2 3 4 5 7 11 13 17 19 23 29
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Demonstration of Sieve of Eratosthenes
\begin_inset CommandInset label
LatexCommand label
name "fig:Demonstration-of-Sieve"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
An implementation of the Sieve of Eratosthenes can be found in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Sieve-of-Eratosthenes"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static int[] Eratosthenes(int maxPrimeNumber){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Define new vector A with all numbers from 2 to N
\end_layout

\begin_layout Plain Layout

  int[] vectorA = new int[maxPrimeNumber+1];
\end_layout

\begin_layout Plain Layout

  for(int index = 2; index <= maxPrimeNumber; index++){
\end_layout

\begin_layout Plain Layout

    vectorA[index] = index;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  int nonPrimeCount = 0;
\end_layout

\begin_layout Plain Layout

  // Flag all non-primes in vector A.
\end_layout

\begin_layout Plain Layout

  int sqrtMaxPrime = (int)Math.sqrt(maxPrimeNumber);
\end_layout

\begin_layout Plain Layout

  for(int index = 2; index < sqrtMaxPrime; index++){
\end_layout

\begin_layout Plain Layout

    // Skip this number if known composite
\end_layout

\begin_layout Plain Layout

    if(vectorA[index] != 0){
\end_layout

\begin_layout Plain Layout

      int composite = index * index;
\end_layout

\begin_layout Plain Layout

      // Flag all composites of this number as non-prime
\end_layout

\begin_layout Plain Layout

      while(composite <= maxPrimeNumber){
\end_layout

\begin_layout Plain Layout

        if(vectorA[composite] != 0){
\end_layout

\begin_layout Plain Layout

          vectorA[composite] = 0;
\end_layout

\begin_layout Plain Layout

          nonPrimeCount++;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        composite = composite + index;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

  // Create new array from A, filled with just primes.
\end_layout

\begin_layout Plain Layout

  int resultIndex = 0;
\end_layout

\begin_layout Plain Layout

  int[] primes = new int[maxPrimeNumber-nonPrimeCount-1];
\end_layout

\begin_layout Plain Layout

  for(int index = 2; index <= maxPrimeNumber; index++){
\end_layout

\begin_layout Plain Layout

    if(vectorA[index] != 0){
\end_layout

\begin_layout Plain Layout

      primes[resultIndex++] = vectorA[index];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return primes;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption

\begin_layout Plain Layout
Sieve of Eratosthenes Algorithm (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Sieve-of-Eratosthenes"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem - Primes for Hashtable
\end_layout

\begin_layout Standard
Student Programmer Joe is developing a dynamic hash table class in Java,
 and from his textbooks knows that prime numbers make the best values to
 use within the hashing function.
 He would like a program to tell him if the number he is using is a prime,
 and if not what's the closest prime to but below to the number he has given
 the program.
 
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
The input will be an integer indicating the number Joe inputs to be tested
 for being a prime, which is within the range of 
\begin_inset Formula $0\leq N\leq2^{16}-1$
\end_inset

.
 A zero indicates the end of input.
 You should not process this input.
 
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
3
\begin_inset Newline newline
\end_inset

6243
\begin_inset Newline newline
\end_inset

8191
\begin_inset Newline newline
\end_inset

10
\begin_inset Newline newline
\end_inset

0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
Output "
\family typewriter
prime
\family default
" if a prime number, otherwise the closest prime below the number given.
 
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
prime
\begin_inset Newline newline
\end_inset

6421
\begin_inset Newline newline
\end_inset

prime
\begin_inset Newline newline
\end_inset

7 
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Solution
\end_layout

\begin_layout Standard
A sample solution for the Primes of Hash Table problem can be found in Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Primes"

\end_inset

.
 There are 6542 prime numbers in the specified number space.
\end_layout

\begin_layout Standard
There are a number of methods to solve this problem, including:
\end_layout

\begin_layout Enumerate
Testing each number input as a prime using the divisibility test, and if
 not a prime decrementing the number by 1 and retesting until a prime is
 found.
\end_layout

\begin_layout Enumerate
Create a list of all numbers within the test space in an array and set all
 array elements that respresent composites to 0.
 To test each number given, we simple look up the slot for that number in
 the array, and determine if it's a prime or not
\begin_inset Foot
status open

\begin_layout Plain Layout
This allows the search for prime to become a lookup operation rather than
 a calculation operation improving performance.
\end_layout

\end_inset

.
 If it's not a prime, we use a reverse linear search through the array until
 a prime is found, and return the found prime.
\begin_inset Newline newline
\end_inset

This offers, 
\series bold
O(1)
\series default
 performance for testing if a number is a prime within the array, but up
 to 
\series bold
O(71)
\series default
 if the number supplied is not a prime.
 The 
\series bold
O(71)
\series default
 is determined by the largest gap between prime numbers in the number space
 (being 71), and would be the worst case for a linear search operation if
 needed.
\end_layout

\begin_layout Enumerate
Create a list of all prime numbers in the test space, and store only these
 in an array
\begin_inset script superscript

\begin_layout Plain Layout
17
\end_layout

\end_inset

.
 Utilising a binary search to search for the number in the list, we can
 determine if the number is prime based on 
\series bold
O(log
\begin_inset script subscript

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset

n)
\series default
 performance.
 With a slight modification to the binary search method, instead of returning
 -1 if not found, we can return the index of the last tested value, which
 incidently will the next prime below the number being tested.
 Therefore we can assume
\series bold
 O(log
\begin_inset script subscript

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset

n)
\series default
 performance in the worst case for each number test.
 (With 6542 primes, this would result in 
\series bold
O(13) 
\series default
in the worst case).
\end_layout

\begin_layout Standard
For this problem, I utilised the third option listed above for three main
 reasons:
\end_layout

\begin_layout Enumerate
The memory space requirement is reduced after the lists of primes has been
 calculated
\begin_inset Foot
status open

\begin_layout Plain Layout
Whilst during the creation of the list of primes, large amounts of memory
 is needed, once the list has been created, the needed space to hld the
 results is vastly smaller.
\end_layout

\end_inset

, allowing more of the list of numbers to fit into CPU cache.
 (Option 2 will utilise 256KB of RAM vs Option 3 with 26KB of RAM).
 While 256KB vs 26KB may not seem a lot, 26KB will fit or mostly fit into
 the Level 1 cache on most CPUs thereby increasing performance.
 If we expand the address space to the maximum value being 2
\begin_inset script superscript

\begin_layout Plain Layout
31
\end_layout

\end_inset

-1, Option 2 will utilise 8GB of RAM, whilst Option 3 will utilise 420MB
 of RAM once the lists have been created.
\end_layout

\begin_layout Enumerate
The time needed for determining if a prime is excellent with Option 2, but
 suffers some performance penalty if a linear search is needed to find the
 next lower prime.
 The largest gap in the required test space is 71 numbers, which may negatively
 effect performance.
 If we expand the address space to the maximum value being 2
\begin_inset script superscript

\begin_layout Plain Layout
31
\end_layout

\end_inset

-1, in Option 2 the largest gap between primes becomes 354 numbers, therefore
 requiring up to 354 operations for the linear search.
 Option 3 suffers little performance penalty, as the search remains at 
\series bold
O(log
\begin_inset script subscript

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset

n)
\series default
, where n = 105,097,565, or 
\series bold
O(26)
\series default
 to determine if a prime or the next lower prime.
\end_layout

\begin_layout Enumerate
Utilising the Sieve of Eratosthenes, the resulting list of primes is naturally
 sorted allowing the use of a binary search to find the prime number, without
 additional work.
\end_layout

\begin_layout Standard
Option 1 was not considered due to the lack of CPU efficiency within the
 proposed solution.
\end_layout

\begin_layout Standard
The implemented solution performs the following steps:
\end_layout

\begin_layout Enumerate
Create a list of primes in an array utilising the Sieve of Eratosthenes
 algorithm.
 (If a complete array can not fit into memory, an alternate Segmented Sieve
 of Eratosthenes may be used to build the list of primes).
 
\end_layout

\begin_layout Enumerate
Reads in the next number to be tested.
 (If '0', exit).
\end_layout

\begin_layout Enumerate
Utilise a binary search to find the index of the number in the list of primes,
 and test the value stored against the number to determine if prime or not.
 If it is not a prime, the index points to the next prime lower than the
 number entered.
\end_layout

\begin_layout Standard
To test the implementation, a range of number were randomly selected to
 test the basic operation.
 To ensure that the implementation was robust, the following numbers were
 also tested:
\end_layout

\begin_layout Itemize
Number 1.
 Number 1 is neither a prime, nor composite.
 In this case, I return 1 due to 1 being non-prime.
\end_layout

\begin_layout Itemize
Number 2.
\end_layout

\begin_layout Itemize
Less than 0, which returns 2.
 (Less than 0, is invalid input, so can't be considering incorrect).
\end_layout

\begin_layout Itemize
More than 2
\begin_inset script superscript

\begin_layout Plain Layout
16
\end_layout

\end_inset

, which the first prime less than 2
\begin_inset script superscript

\begin_layout Plain Layout
16
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Since a binary search was used, I had to pay little attention to values
 outside the input space, as the results of the binary search would always
 return an index that was within the address space.
 The exception to this was the number 1, in which a special case is used.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

public class PrimesForHashtable {
\end_layout

\begin_layout Plain Layout

  /* Largest value with input space */
\end_layout

\begin_layout Plain Layout

  final static int PRIME_SPACE = (int) Math.pow(2, 16);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Utilise Sieve of Eratosthenes to create an array of prime numbers
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static int[] Eratosthenes(int maxPrimeNumber) {
\end_layout

\begin_layout Plain Layout

    // Define new vector A with all numbers from 2 to N
\end_layout

\begin_layout Plain Layout

    int[] vectorA = new int[maxPrimeNumber + 1];
\end_layout

\begin_layout Plain Layout

    for (int index = 2; index <= maxPrimeNumber; index++) {
\end_layout

\begin_layout Plain Layout

      vectorA[index] = index;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    int nonPrimeCount = 0;
\end_layout

\begin_layout Plain Layout

    // Flag all non-primes in vector A.
\end_layout

\begin_layout Plain Layout

    int sqrtMaxPrime = (int) Math.sqrt(maxPrimeNumber);
\end_layout

\begin_layout Plain Layout

    for (int index = 2; index < sqrtMaxPrime; index++) {
\end_layout

\begin_layout Plain Layout

      // Skip this number if known composite
\end_layout

\begin_layout Plain Layout

      if (vectorA[index] != 0) {
\end_layout

\begin_layout Plain Layout

        int composite = index * index;
\end_layout

\begin_layout Plain Layout

        // Flag all composites of this number as non-prime
\end_layout

\begin_layout Plain Layout

        while (composite <= maxPrimeNumber) {
\end_layout

\begin_layout Plain Layout

          if (vectorA[composite] != 0) {
\end_layout

\begin_layout Plain Layout

            vectorA[composite] = 0;
\end_layout

\begin_layout Plain Layout

            nonPrimeCount++;
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          composite = composite + index;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    // Create new array from A, filled with just primes.
\end_layout

\begin_layout Plain Layout

    int resultIndex = 0;
\end_layout

\begin_layout Plain Layout

    int[] primes = new int[maxPrimeNumber - nonPrimeCount-1];
\end_layout

\begin_layout Plain Layout

    for (int index = 2; index <= maxPrimeNumber; index++) {
\end_layout

\begin_layout Plain Layout

      if (vectorA[index] != 0) {
\end_layout

\begin_layout Plain Layout

        primes[resultIndex++] = vectorA[index];
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return primes;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Perform binary search of array to locate prime number.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static int BinarySearch(int[] vector, int key, int low, int high)
 {
\end_layout

\begin_layout Plain Layout

    if (low > high) {
\end_layout

\begin_layout Plain Layout

      return (high >= 0 ? high : 0); 
\end_layout

\begin_layout Plain Layout

            // Return the index of the current high value, as this
\end_layout

\begin_layout Plain Layout

            // points to 1 below the key, if not found
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    int mid = (low + high) / 2;
\end_layout

\begin_layout Plain Layout

    if (vector[mid] == key) {
\end_layout

\begin_layout Plain Layout

      return mid;
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      if (vector[mid] > key) {
\end_layout

\begin_layout Plain Layout

        return BinarySearch(vector, key, low, (mid - 1));
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        return BinarySearch(vector, key, (mid + 1), high);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Returns a prime equal to or below to the number given.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static int LookUpPrime(int[] primes, int number) {
\end_layout

\begin_layout Plain Layout

    return primes[BinarySearch(primes, number, 0, primes.length-1)];
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Create a list of primes for the given input space.
\end_layout

\begin_layout Plain Layout

    int[] primes = Eratosthenes(PRIME_SPACE);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

    String line = in.nextLine();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Keep processing input until 0.
\end_layout

\begin_layout Plain Layout

    while (!line.equals("0")) {
\end_layout

\begin_layout Plain Layout

      // Get our number, and it's closest prime.
\end_layout

\begin_layout Plain Layout

      int number = Integer.parseInt(line);
\end_layout

\begin_layout Plain Layout

      // Handle special case of number 1.
\end_layout

\begin_layout Plain Layout

      if (number != 1) {
\end_layout

\begin_layout Plain Layout

        int prime = LookUpPrime(primes, number);
\end_layout

\begin_layout Plain Layout

        // Display if it's a prime, or closet prime.
\end_layout

\begin_layout Plain Layout

        if (prime == number) {
\end_layout

\begin_layout Plain Layout

          System.out.println("prime");
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          System.out.println(prime);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        System.out.println("1");
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      line = in.nextLine();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

} 
\begin_inset Caption

\begin_layout Plain Layout
Solution to Primes for Hashtable (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Primes"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
String based algorithms and data structures
\end_layout

\begin_layout Standard
String are a fundamental data type with a high importance in the following
 areas:
\end_layout

\begin_layout Itemize
Web crawlers utilised by search engines classify billions of text documents
 each day.
\end_layout

\begin_layout Itemize
Bioinformatics Research, particularly arounfg genome based research.
 
\end_layout

\begin_layout Standard
Strings are effectively a collection of characters, with each character
 being defined as part of an alphabet.
 This alphabet, may consist of only a single character, a small number of
 characters, (eg ASCII with 127 characters), a large number of characters
 (eg Unicode with 1,114,112 characters), or all possible values represented
 by either a byte (256 characters), word (65536 characters) or double-word(2
\begin_inset script superscript

\begin_layout Plain Layout
32
\end_layout

\end_inset

 characters).
 One common misconseption is that a string may only represent those letters
 and figures as defined in a human langauge, but from a Computers viewpoint
 any value that can be defined may be included (or even excluded) from the
 alphabet that defines a string.
\end_layout

\begin_layout Standard
Typically, we allow 
\shape italic
A
\shape default
 to be an alphabet (finite set), with:
\end_layout

\begin_layout Itemize

\shape italic
pattern
\shape default
 and 
\shape italic
text
\shape default
 are vectors of elements of 
\shape italic
A
\shape default
.
\end_layout

\begin_layout Itemize

\shape italic
A
\shape default
 may be:
\end_layout

\begin_deeper
\begin_layout Itemize
usual human alphabet
\end_layout

\begin_layout Itemize
binary alphabet = 
\shape italic
A
\shape default
 = {0,1}
\end_layout

\begin_layout Itemize
DNA alphabet = 
\shape italic
A 
\shape default
= {A, C, G, T}
\end_layout

\begin_layout Itemize
etc.
\end_layout

\end_deeper
\begin_layout Standard
When dealing with strings in different languages, the meaning and implementation
 may vary.
\end_layout

\begin_layout Itemize
C99 - A string is defined as a vector of char (or byte), utilising ASCII
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Other non-PC systems may utilise alternate encoding systems such as EBCIDC
 in place of ASCII encoding.
\end_layout

\end_inset

 or UTF-8
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Modern UNIX implementations like FreeBSD, Solaris and GNU/Linux use UTF-8.
\end_layout

\end_inset

 encoding terminated by the character 
\shape italic
NUL
\shape default
 (0).
\end_layout

\begin_layout Itemize
C++ - A string may be that as C99, or of an object wrapped around a C99
 string.
 Some operating systems like Windows allow a Wide-Character (16bits) to
 be utilised in place of single byte characters.
\end_layout

\begin_layout Itemize
Java - A string is a vector of UTF-16 encoded characters, represented as
 an object, and is immutable.
\end_layout

\begin_layout Itemize
C# (with .NET) - A string is a vector of UTF-16 encoded characters, represented
 as an object, and is immutable.
\end_layout

\begin_layout Standard
There are numberous algorithms that perform string matching, including Brute
 Force, Rabin-Karp, Knuth-Morris-Pratt, Boyer-Moore, and Horspool.
 Regular Expressions are also considered a form of pattern matching, with
 the advantage that they allow an infinite number of patterns to be matched.
\end_layout

\begin_layout Standard
This guide will discuss the Brute Force and Knuth-Morris-Pratt algorithms.
\end_layout

\begin_layout Subsubsection
Brute Force Substring Search
\end_layout

\begin_layout Standard
Brute Force Substring search is considered a naive based algorithm that
 utilises a very simple method to determine string or pattern matching.
\end_layout

\begin_layout Standard
The algorithm walks through the vector of text, attempting to match the
 pattern in sequence.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require A Vector $T$ of $n$ characters representing a text, and vector $P$
 of $m$ characters representing a pattern to find in $T$.
 
\end_layout

\begin_layout Plain Layout


\backslash
Ensure The index of the first character of $P$ when a complete match is
 found in $T$, otherwise -1 if search was unsuccessful.
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{BruteForceStringMatch}{$T, P$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$i 
\backslash
gets 0$ to $n-m$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$j 
\backslash
gets 0$}
\end_layout

\begin_layout Plain Layout


\backslash
While {$j < m$ 
\backslash
textbf{and} $P[j]=T[i+j]$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$j 
\backslash
gets j + 1$}
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
If {$j = m$}
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{return} $i$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{return} $-1$}
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Brute Force String Matching
\begin_inset CommandInset label
LatexCommand label
name "alg:Brute-Force-String"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
The Brute Force String Matching algorithm is a very simple algorithm that
 performs the following steps:
\end_layout

\begin_layout Enumerate
Align patternw at the beginning of the text.
\end_layout

\begin_layout Enumerate
Moving from left to right, compare each character of the pattern to the
 corresponding character in the text until:
\end_layout

\begin_deeper
\begin_layout Enumerate
All characters are found to match; or
\end_layout

\begin_layout Enumerate
A mismatch is detected.
\end_layout

\end_deeper
\begin_layout Enumerate
While pattern is not found, and the text is not exhausted, relaign pattern
 one position to the right and repeat step 2.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Example-of-Brute"

\end_inset

 has an example of Brute Force matching.
 (The pattern's characters that are compare with their text counterparts
 are in bold type).
\end_layout

\begin_layout Standard
Brute Force String Matching is considered a 
\series bold
O(n
\begin_inset script superscript

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset

)
\series default
 operation, however may offer worse performance if many clost matches are
 present within the text.
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="18">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
T
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
gets$
\end_layout

\end_inset

(Match Found)
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Example of Brute Force String Matching
\begin_inset CommandInset label
LatexCommand label
name "fig:Example-of-Brute"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
An implementation of the Brute Force String Matching can be found in Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Brute-Force-String"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={[ANSI]C++}"
inline false
status open

\begin_layout Plain Layout

int BruteForceStringMatch(char* text, int textLength, 
\end_layout

\begin_layout Plain Layout

                          char* pattern, int patternLength){
\end_layout

\begin_layout Plain Layout

  int patternIndex = 0;
\end_layout

\begin_layout Plain Layout

  // Scan the text looking for the pattern
\end_layout

\begin_layout Plain Layout

  for(int textIndex = 0; textIndex <= textLength-patternLength; textIndex++){
\end_layout

\begin_layout Plain Layout

    patternIndex = 0; // Reset index into pattern
\end_layout

\begin_layout Plain Layout

    // While the current text position matches the pattern, keep scanning
 it.
\end_layout

\begin_layout Plain Layout

    while((patternIndex < patternLength)
\end_layout

\begin_layout Plain Layout

             &&(pattern[patternIndex] == text[textIndex+patternIndex])){
\end_layout

\begin_layout Plain Layout

      patternIndex++;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    // If the patternIndex is equal to patternLength, we have found the
 pattern!
\end_layout

\begin_layout Plain Layout

    if(patternIndex == patternLength){
\end_layout

\begin_layout Plain Layout

      return textIndex;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  // Pattern not found, so return -1.
\end_layout

\begin_layout Plain Layout

  return -1; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Brute Force String Matching (C++)
\begin_inset CommandInset label
LatexCommand label
name "lis:Brute-Force-String"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem - Where's Waldorf
\end_layout

\begin_layout Standard
Given a 
\begin_inset Formula $m$
\end_inset

 by 
\begin_inset Formula $n$
\end_inset

 grid of letters, (
\begin_inset Formula $1\leq m,n\leq50$
\end_inset

), and a list of words, find the location in the grid at which the word
 can be found.
 A word matches a straight, uninterrupted line of letters in the grid.
 A word can match the letters in the grid regardless of case (i.e.
 upper and lower case letters are to be treated as the same).
 The matching can be done in any of the eight directions either horizontally,
 vertically or diagonally through the grid.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
The input begins with a single positive integer on a line by itself indicating
 the number of the cases following, each of them as described below.
 This line is followed by a blank line, and there is also a blank line between
 two consecutive inputs.
 
\end_layout

\begin_layout Standard
The input begins with a pair of integers, 
\begin_inset Formula $m$
\end_inset

 followed by 
\begin_inset Formula $n,1\leq m,n\leq50$
\end_inset

 in decimal notation on a single line.
 The next 
\begin_inset Formula $m$
\end_inset

 lines contain 
\begin_inset Formula $n$
\end_inset

 letters each; this is the grid of letters in which the words of the list
 must be found.
 The letters in the grid may be in upper or lower case.
 
\end_layout

\begin_layout Standard
Following the grid of letters, another integer 
\begin_inset Formula $k$
\end_inset

 appears on a line by itself (
\begin_inset Formula $1\leq k\leq20$
\end_inset

 ).
 The next 
\begin_inset Formula $k$
\end_inset

 lines of input contain the list of words to search for, one word per line.
 These words may contain upper and lower case letters only (no spaces, hyphens
 or other non-alphabetic characters).
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
1
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

8 11
\begin_inset Newline newline
\end_inset

abcDEFGhigg
\begin_inset Newline newline
\end_inset

hEbkWalDork
\begin_inset Newline newline
\end_inset

FtyAwaldORm
\begin_inset Newline newline
\end_inset

FtsimrLqsrc
\begin_inset Newline newline
\end_inset

byoArBeDeyv
\begin_inset Newline newline
\end_inset

Klcbqwikomk
\begin_inset Newline newline
\end_inset

strEBGadhrb
\begin_inset Newline newline
\end_inset

yUiqlxcnBjf
\begin_inset Newline newline
\end_inset

4
\begin_inset Newline newline
\end_inset

Waldorf
\begin_inset Newline newline
\end_inset

Bambi
\begin_inset Newline newline
\end_inset

Betty
\begin_inset Newline newline
\end_inset

Dagbert
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
For each test case, the output must follow the description below.
 The outputs of two consecutive cases will be separated by a blank line.
 
\end_layout

\begin_layout Standard
For each word in the word list, a pair of integers representing the location
 of the corresponding word in the grid must be output.
 The integers must be separated by a single space.
 The first integer is the line in the grid where the first letter of the
 given word can be found (1 represents the topmost line in the grid, and
 
\begin_inset Formula $m$
\end_inset

 represents the bottommost line).
 The second integer is the column in the grid where the first letter of
 the given word can be found (1 represents the leftmost column in the grid,
 and 
\begin_inset Formula $n$
\end_inset

 represents the rightmost column in the grid).
 If a word can be found more than once in the grid, then the location which
 is output should correspond to the uppermost occurence of the word (i.e.
 the occurence which places the first letter of the word closest to the
 top of the grid).
 If two or more words are uppermost, the output should correspond to the
 leftmost of these occurences.
 All words can be found at least once in the grid.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
2 5
\begin_inset Newline newline
\end_inset

2 3
\begin_inset Newline newline
\end_inset

1 2
\begin_inset Newline newline
\end_inset

7 8
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Solution
\end_layout

\begin_layout Standard
A sample solution to the Where's Waldorf problem can be found in Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Where's"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language={[ANSI]C++}"
inline false
status open

\begin_layout Plain Layout

#include <cstdlib>
\end_layout

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include <cctype>
\end_layout

\begin_layout Plain Layout

#include <cstring>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

char** wordmap;
\end_layout

\begin_layout Plain Layout

int testCases = 0;
\end_layout

\begin_layout Plain Layout

int wordmapWidth = 0;
\end_layout

\begin_layout Plain Layout

int wordmapHeight = 0;
\end_layout

\begin_layout Plain Layout

char blankline[256];
\end_layout

\begin_layout Plain Layout

int wordSearches = 0;
\end_layout

\begin_layout Plain Layout

char* pattern = NULL;
\end_layout

\begin_layout Plain Layout

int patternLength = 0;
\end_layout

\begin_layout Plain Layout

char* text = NULL;
\end_layout

\begin_layout Plain Layout

int location = -1;
\end_layout

\begin_layout Plain Layout

int currentRow = 0;
\end_layout

\begin_layout Plain Layout

int currentCol = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Attempt to find a pattern contained within the text.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

int BruteForceStringMatch(char* text, int textLength, char* pattern, int
 patternLength) {
\end_layout

\begin_layout Plain Layout

  int patternIndex = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Ensure the text is big enough to hold our pattern!
\end_layout

\begin_layout Plain Layout

  if (patternLength > textLength) {
\end_layout

\begin_layout Plain Layout

    return -1;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Scan the text looking for the pattern
\end_layout

\begin_layout Plain Layout

  for (int textIndex = 0; textIndex <= textLength - patternLength; textIndex++)
 {
\end_layout

\begin_layout Plain Layout

    patternIndex = 0;
\end_layout

\begin_layout Plain Layout

    // While the current text position matches the pattern, keep scanning
 it.
\end_layout

\begin_layout Plain Layout

    while ((patternIndex < patternLength) && (pattern[patternIndex] == 
\end_layout

\begin_layout Plain Layout

                                              text[textIndex + patternIndex]))
 {
\end_layout

\begin_layout Plain Layout

      patternIndex++;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    // If the patternIndex is equal to the patternLength, we have found
 the pattern!
\end_layout

\begin_layout Plain Layout

    if (patternIndex == patternLength) {
\end_layout

\begin_layout Plain Layout

      return textIndex;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  // Pattern not found, so return -1.
\end_layout

\begin_layout Plain Layout

  return -1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Create a search pattern of length, from the word map.
\end_layout

\begin_layout Plain Layout

 * @param col starting position in the word map (0 offset)
\end_layout

\begin_layout Plain Layout

 * @param row starting position in the word map (0 offset)
\end_layout

\begin_layout Plain Layout

 * @param length length of required string.
\end_layout

\begin_layout Plain Layout

 * @param colOffset direction to move column index for each letter.
\end_layout

\begin_layout Plain Layout

 * @param rowOffset direction to move row index for each letter.
\end_layout

\begin_layout Plain Layout

 * @return Index of found string.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

char* buildTextString(int col, int row, int length, int colOffset, int rowOffset
) {
\end_layout

\begin_layout Plain Layout

  char* newString = new char[length + 1];
\end_layout

\begin_layout Plain Layout

  int index = 0;
\end_layout

\begin_layout Plain Layout

  while (length--) {
\end_layout

\begin_layout Plain Layout

    newString[index++] = wordmap[row][col];
\end_layout

\begin_layout Plain Layout

    row += rowOffset;
\end_layout

\begin_layout Plain Layout

    col += colOffset;
\end_layout

\begin_layout Plain Layout

    // Ensure we are not going outside map boundary
\end_layout

\begin_layout Plain Layout

    if ((row < 0) || (row >= wordmapHeight) || (col < 0) || (col >= wordmapWidth
)) {
\end_layout

\begin_layout Plain Layout

      newString[index] = NULL;
\end_layout

\begin_layout Plain Layout

      return newString;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  newString[index] = NULL;
\end_layout

\begin_layout Plain Layout

  return newString;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Convert string to lower case, and store in place
\end_layout

\begin_layout Plain Layout

 * @param str ASCIIZ string to convert.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

void strToLower(char* str) {
\end_layout

\begin_layout Plain Layout

  int i = 0;
\end_layout

\begin_layout Plain Layout

  while (str[i]) {
\end_layout

\begin_layout Plain Layout

    str[i] = (char) tolower(str[i]);
\end_layout

\begin_layout Plain Layout

    i++;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Update the best found location, based on current row/col positions
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

void UpdateFind(int row, int col, int rowOffset, int colOffset, int location)
 {
\end_layout

\begin_layout Plain Layout

  if (currentRow > row + (rowOffset * location)) {
\end_layout

\begin_layout Plain Layout

    currentRow = row + (rowOffset * location);
\end_layout

\begin_layout Plain Layout

    currentCol = col + (colOffset * location);
\end_layout

\begin_layout Plain Layout

  } else if (currentRow == row + (rowOffset * location)) {
\end_layout

\begin_layout Plain Layout

    if (currentCol > col + (colOffset * location)) {
\end_layout

\begin_layout Plain Layout

      currentRow = row + (rowOffset * location);
\end_layout

\begin_layout Plain Layout

      currentCol = col + (colOffset * location);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Main 
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

  scanf("%d", &testCases);
\end_layout

\begin_layout Plain Layout

  while (testCases--) {
\end_layout

\begin_layout Plain Layout

    gets(blankline);
\end_layout

\begin_layout Plain Layout

    // Read in the wordmap, and ensure in lower case.
\end_layout

\begin_layout Plain Layout

    scanf("%d %d", &wordmapHeight, &wordmapWidth);
\end_layout

\begin_layout Plain Layout

    wordmap = new char*[wordmapHeight];
\end_layout

\begin_layout Plain Layout

    for (int row = 0; row < wordmapHeight; row++) {
\end_layout

\begin_layout Plain Layout

      wordmap[row] = new char[wordmapWidth + 1];
\end_layout

\begin_layout Plain Layout

      scanf("%s", wordmap[row]);
\end_layout

\begin_layout Plain Layout

      strToLower(wordmap[row]);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Read in the number of words to search for.
\end_layout

\begin_layout Plain Layout

    scanf("%d", &wordSearches);
\end_layout

\begin_layout Plain Layout

    while (wordSearches--) {
\end_layout

\begin_layout Plain Layout

      // Read in a single word.
\end_layout

\begin_layout Plain Layout

      pattern = new char[wordmapWidth + 1];
\end_layout

\begin_layout Plain Layout

      scanf("%s", pattern);
\end_layout

\begin_layout Plain Layout

      strToLower(pattern);
\end_layout

\begin_layout Plain Layout

      patternLength = strlen(pattern);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      currentRow = wordmapHeight;
\end_layout

\begin_layout Plain Layout

      currentCol = wordmapWidth;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      //Attempt to scan for word, along the top of the grid.
\end_layout

\begin_layout Plain Layout

      for (int col = 0; col < wordmapWidth; col++) {
\end_layout

\begin_layout Plain Layout

        int row = 0;
\end_layout

\begin_layout Plain Layout

        int rowOffset = 1;
\end_layout

\begin_layout Plain Layout

        for (int colOffset = -1; colOffset < 2; colOffset++) {
\end_layout

\begin_layout Plain Layout

          // Get our next text string, and attempt to match!
\end_layout

\begin_layout Plain Layout

          text = buildTextString(col, row, 50, colOffset, rowOffset);
\end_layout

\begin_layout Plain Layout

          location = BruteForceStringMatch(text, strlen(text), pattern,
 patternLength);
\end_layout

\begin_layout Plain Layout

          if (location >= 0) {
\end_layout

\begin_layout Plain Layout

            UpdateFind(row, col, rowOffset, colOffset, location);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          delete(text);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      //Attempt to scan for word, along the bottom of the grid.
\end_layout

\begin_layout Plain Layout

      for (int col = 0; col < wordmapWidth; col++) {
\end_layout

\begin_layout Plain Layout

        int row = wordmapHeight - 1;
\end_layout

\begin_layout Plain Layout

        int rowOffset = -1;
\end_layout

\begin_layout Plain Layout

        for (int colOffset = -1; colOffset < 2; colOffset++) {
\end_layout

\begin_layout Plain Layout

          // Get our next text string, and attempt to match!
\end_layout

\begin_layout Plain Layout

          text = buildTextString(col, row, 50, colOffset, rowOffset);
\end_layout

\begin_layout Plain Layout

          location = BruteForceStringMatch(text, strlen(text), pattern,
 patternLength);
\end_layout

\begin_layout Plain Layout

          if (location >= 0) {
\end_layout

\begin_layout Plain Layout

            UpdateFind(row, col, rowOffset, colOffset, location);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          delete(text);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      //Attempt to scan for word, along the left of the grid.
\end_layout

\begin_layout Plain Layout

      for (int row = 0; row < wordmapHeight; row++) {
\end_layout

\begin_layout Plain Layout

        int col = 0;
\end_layout

\begin_layout Plain Layout

        int colOffset = 1;
\end_layout

\begin_layout Plain Layout

        for (int rowOffset = -1; rowOffset < 2; rowOffset++) {
\end_layout

\begin_layout Plain Layout

          // Get our next text string, and attempt to match!
\end_layout

\begin_layout Plain Layout

          text = buildTextString(col, row, 50, colOffset, rowOffset);
\end_layout

\begin_layout Plain Layout

          location = BruteForceStringMatch(text, strlen(text), pattern,
 patternLength);
\end_layout

\begin_layout Plain Layout

          if (location >= 0) {
\end_layout

\begin_layout Plain Layout

            UpdateFind(row, col, rowOffset, colOffset, location);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          delete(text);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      //Attempt to scan for word, along the right of the grid.
\end_layout

\begin_layout Plain Layout

      for (int row = 0; row < wordmapHeight; row++) {
\end_layout

\begin_layout Plain Layout

        int col = wordmapWidth - 1;
\end_layout

\begin_layout Plain Layout

        int colOffset = -1;
\end_layout

\begin_layout Plain Layout

        for (int rowOffset = -1; rowOffset < 2; rowOffset++) {
\end_layout

\begin_layout Plain Layout

          // Get our next text string, and attempt to match!
\end_layout

\begin_layout Plain Layout

          text = buildTextString(col, row, 50, colOffset, rowOffset);
\end_layout

\begin_layout Plain Layout

          location = BruteForceStringMatch(text, strlen(text), pattern,
 patternLength);
\end_layout

\begin_layout Plain Layout

          if (location >= 0) {
\end_layout

\begin_layout Plain Layout

            UpdateFind(row, col, rowOffset, colOffset, location);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          delete(text);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      printf("%d %d
\backslash
n", currentRow + 1, currentCol + 1);
\end_layout

\begin_layout Plain Layout

      // Free our word.
\end_layout

\begin_layout Plain Layout

      delete(pattern);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Free our wordmap;
\end_layout

\begin_layout Plain Layout

    for (int row = 0; row < wordmapHeight; row++) {
\end_layout

\begin_layout Plain Layout

      delete(wordmap[row]);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    delete(wordmap);
\end_layout

\begin_layout Plain Layout

    printf("
\backslash
n");
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Solution to Where's Waldorf (C++)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Where's"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Where's Waldorf problem, can be solved a number of ways, with the two
 most common methods being:
\end_layout

\begin_layout Enumerate
Move through each letter in the grid, and attempt to find the word in one
 of the eight directions leading from the current character, until a match
 is found.
 (This requires 
\begin_inset Formula $8n^{2}$
\end_inset

 searches or 
\series bold
O(n
\begin_inset script superscript

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset

)
\series default
 performance, not including the complexity of the string matching algorithm).
 An enhancement of this technique would be limit the search to places where
 the word would fit in the grid, reducing the number of tests.
\end_layout

\begin_layout Enumerate
Move along the outer most characters only, and attempt to find the word
 in three directions that look inward into the grid, utilising a pattern
 search algorithm.
 (This requires 
\begin_inset Formula $12n$
\end_inset

 searches or 
\series bold
O(n)
\series default
 performance, not including the complexity of the string matching algorithm).
\end_layout

\begin_layout Standard
For solving this problem, I utilised the second method.
 
\end_layout

\begin_layout Standard
In order to mitigate the case from being an issue, when reading in either
 a grid line or pattern to look for, I convert both to lower case before
 storing/using them.
 The sample solution first initiates a scan along the top of the grid, creating
 3 texts to search for each position along the top of the grid.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Scanning-Grid-for"

\end_inset

 demonstrates this technique.
 If found, I update the best known location (according to cuurent row and
 column values), and then continue to scan the rest of the grid (as shown
 as the gradients squares in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Scanning-Grid-for"

\end_inset

).
 Lastly at the end of the grid scan, I output the best found location.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/WheresWaldorf.eps
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Scanning Grid for Where's Waldorf
\begin_inset CommandInset label
LatexCommand label
name "fig:Scanning-Grid-for"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the sample implementation I utilised the Brute Force String Matching
 Algorithm simply to demonstarte it's use.
 However, in a real competition environment I would utilise a more efficient
 pattern matching algorithm to ensure the best possible performance.
 One such algorithm that could be used is in place of the Brute Force String
 Matching Algorithm described in the next section.
\end_layout

\begin_layout Standard
Some of the tough test cases include:
\end_layout

\begin_layout Itemize
Grids being either 1 wide or 1 row deep.
\end_layout

\begin_layout Itemize
Current text to scan is smaller than the pattern length.
\end_layout

\begin_layout Itemize
Multiple words found in the grid.
\end_layout

\begin_layout Itemize
A grid being all of one letter, and pattern to find is a string of the one
 letter.
\end_layout

\begin_layout Subsubsection
Knuth-Morris-Pratt Substring Search
\end_layout

\begin_layout Standard
When studying the worst-case performance of the brute force pattern matching,
 there is a major deficiency in that characters are potentially rescanned.
 Specifically, we may perform many comparisons while testing potential placement
 of the pattern against the text, yet if we discover a pattern character
 that does not match in the text, then we throw away all the information
 gained by these comparisons and start over again from scratch with the
 algorithm.
\end_layout

\begin_layout Standard
The Knuth-Morris-Pratt (or KMP) algorithm, avoids this waste of information,
 and in doing so, achieves 
\series bold
O(n+m)
\series default
 performance, which is optimal in the worst case.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement !h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require A Vector $T$ of $n$ characters representing a text, and vector $P$
 of $m$ characters representing a pattern to find in $T$.
 
\end_layout

\begin_layout Plain Layout


\backslash
Ensure The index of the first character of $P$ when a complete match is
 found in $T$, otherwise -1 if search was unsuccessful.
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{KMPMatch}{$T, P$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$f 
\backslash
gets 
\backslash
textsc{KMPFailure}(P)$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$i 
\backslash
gets 0$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$j 
\backslash
gets 0$}
\end_layout

\begin_layout Plain Layout


\backslash
While {$i < n$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$P[j]=T[i]$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$j = m - 1$}
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{return} $i-m+1$} 
\backslash
Comment{A match!}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
State {$i 
\backslash
gets i + 1$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$j 
\backslash
gets j + 1$}
\end_layout

\begin_layout Plain Layout


\backslash
ElsIf {$j > 0$} 
\backslash
Comment{No match, but advanced in P}
\end_layout

\begin_layout Plain Layout


\backslash
State {$j 
\backslash
gets f(j-1)$}
\end_layout

\begin_layout Plain Layout


\backslash
Else 
\end_layout

\begin_layout Plain Layout


\backslash
State {$i 
\backslash
gets i + 1$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{return} $-1$}
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Knuth-Morris-Pratt Substring Search
\begin_inset CommandInset label
LatexCommand label
name "alg:Knuth-Morris-Pratt-Substring-Sea"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require A Vector $P$ of $m$ characters representing a pattern.
 
\end_layout

\begin_layout Plain Layout


\backslash
Ensure The failure function $f$ for $P$, which maps $j$ to the length of
 the longest prefix of $P$ that is a suffix of $P[1..j]$
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{KMPFailure}{$P$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$i 
\backslash
gets 1$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$j 
\backslash
gets 0$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$f(0) 
\backslash
gets 0$}
\end_layout

\begin_layout Plain Layout


\backslash
While {$i < m$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$P[j] = P[i]$} 
\backslash
Comment {We have matched $j+1$ characters}
\end_layout

\begin_layout Plain Layout


\backslash
State {$f(i) 
\backslash
gets j + 1$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$i 
\backslash
gets i + 1$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$j 
\backslash
gets j + 1$}
\end_layout

\begin_layout Plain Layout


\backslash
ElsIf {$j > 0$} 
\backslash
Comment {$j$ indexes just after a prefix of $P$ that must match}
\end_layout

\begin_layout Plain Layout


\backslash
State {$j 
\backslash
gets f(j - 1)$}
\end_layout

\begin_layout Plain Layout


\backslash
Else 
\backslash
Comment {We have no matches}
\end_layout

\begin_layout Plain Layout


\backslash
State {$f(i) 
\backslash
gets 0$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$i 
\backslash
gets i + 1$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Knuth-Morris-Pratt Substring Search Failure Function
\begin_inset CommandInset label
LatexCommand label
name "alg:Knuth-Morris-Pratt-Substring-Sea-1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
The main idea of the KMP algorithm is to preprocess the pattern string P
 so as to compute a 
\series bold
failure function
\series default
 
\shape italic
f
\shape default
 that indicates the proper shift of 
\shape italic
P
\shape default
 so that, to the largest extent possible, we can reuse previously performed
 comparisons.
 Specifically, the failure function 
\shape italic
f(j)
\shape default
 is defined as the length of the longest prefix of 
\shape italic
P
\shape default
 that is a suffix of 
\shape italic
P[1..j]
\shape default
.
 We also use the convention that 
\shape italic
f(0) = 0
\shape default
.
 The importance of this failure function is that 
\begin_inset Quotes eld
\end_inset

encodes
\begin_inset Quotes erd
\end_inset

 repeated substrings inside the pattern itself.
\end_layout

\begin_layout Standard
The KMP pattern matching algorithm, shown in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Knuth-Morris-Pratt-Substring-Sea"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Knuth-Morris-Pratt-Substring-Sea-1"

\end_inset

, incrementally processes the text string 
\shape italic
T
\shape default
 comparing it to the pattern string 
\shape italic
P
\shape default
.
 Each time there is a match, we increment the current indices.
 On the other hand, if there is a mismatch and we have previously made progress
 in 
\shape italic
P
\shape default
, then we consult the failure function to determine the new index in 
\shape italic
P
\shape default
 where we need to continue checking 
\shape italic
P
\shape default
 against 
\shape italic
T
\shape default
.
 Otherwise, we simplate increment the index for 
\shape italic
T
\shape default
 (and keep the index variable for 
\shape italic
P
\shape default
 at its beginning).
 We repeat this process until we find a match of 
\shape italic
P
\shape default
 in 
\shape italic
T
\shape default
 or the index of 
\shape italic
T
\shape default
 reaches 
\shape italic
n
\shape default
, the length of
\shape italic
 T
\shape default
.
\end_layout

\begin_layout Standard
The main part of the KMP algorithm is the while-loop, which performs a compariso
n between a character in 
\shape italic
T
\shape default
 and a character in 
\shape italic
P
\shape default
 each iteration.
 Depending upon the outcome of this comparison, the algorithm either moves
 on to the next characters in 
\shape italic
T
\shape default
 and 
\shape italic
P
\shape default
, consults the failure function for a new candidate character in 
\shape italic
P
\shape default
, or starts over with the next index in 
\shape italic
T
\shape default
.
 The correctness of this algorithm follows from the definition of the failure
 function.
 The skipped comparisons are actually unnecessary, for the failure function
 guarantess that all the ignored comparisons are redundan - they would involve
 comparing characters we already know match.
\end_layout

\begin_layout Standard
In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Illustration-of-the"

\end_inset

, we illustrate the execution of the KMP algorithm.
 The failure function f for the pattern displayed is given in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Failure-Function-for"

\end_inset

.
 The algorithm performs 19 character comparisons, which are indicated with
 numberical labels.
 Note the use of the failure function to avoid redoing one of the comparisons
 between a character of the pattern and a character of text.
 Also note that this algorithm performs fewer overall comparisons tha the
 brute force algorithm.
\end_layout

\begin_layout Standard
The failure function utilised within the KMP Algorithm is also shown in
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Knuth-Morris-Pratt-Substring-Sea-1"

\end_inset

.
 This algorithm is another example of a bootstrapping process quite similar
 to that used in the 
\shape smallcaps
KMPMatch
\shape default
 procedure.
 We compare the pattern to itself as in the KMP Algorithm.
 Each time we have two characters that match, we set 
\begin_inset Formula $f(i)=j+1$
\end_inset

.
 Note that since we have 
\begin_inset Formula $i>j$
\end_inset

 throughtout the execution of the algorithm, 
\begin_inset Formula $f(j-1)$
\end_inset

 is always defined when we need to use it.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/KMPAlgorithm.eps
	width 75text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Illustration of the KMP algorithm.
\begin_inset CommandInset label
LatexCommand label
name "fig:Illustration-of-the"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Quote
Consider the pattern string 
\shape italic
P
\shape default
=
\begin_inset Quotes erd
\end_inset

abacab
\begin_inset Quotes erd
\end_inset

.
 The failure function f(j) for the string is shown as the following table.
\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
j
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
P(j)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
f(j)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Failure Function for Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Illustration-of-the"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Failure-Function-for"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
An implementation of the KMP Algorithm can be found in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:KMP-String-Match"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={[ANSI]C++}"
inline false
status open

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * KMP Failure function.
\end_layout

\begin_layout Plain Layout

 * @param Pattern Pointer to the pattern to be processed to derive the failure
\end_layout

\begin_layout Plain Layout

 *                function.
\end_layout

\begin_layout Plain Layout

 * @param patternLength Length of pattern.
\end_layout

\begin_layout Plain Layout

 * @return The failure function (array of int).
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

int *KMPFailure(char *Pattern, int patternLength) {
\end_layout

\begin_layout Plain Layout

  int indexI = 1;
\end_layout

\begin_layout Plain Layout

  int indexJ = 0;
\end_layout

\begin_layout Plain Layout

  int* failure = new int[patternLength]; // Create new function f.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  failure[0] = 0;
\end_layout

\begin_layout Plain Layout

  while (indexI < patternLength) {
\end_layout

\begin_layout Plain Layout

    if (Pattern[indexJ] == Pattern[indexI]) {
\end_layout

\begin_layout Plain Layout

      failure[indexI++] = ++indexJ;
\end_layout

\begin_layout Plain Layout

    } else if (indexJ > 0) {
\end_layout

\begin_layout Plain Layout

      indexJ = failure[indexJ - 1];
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      failure[indexI++] = 0;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return failure;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Utilise the KMP Substring search algorithm to find a pattern in text.
\end_layout

\begin_layout Plain Layout

 * @param Text Pointer to the text to be searched.
\end_layout

\begin_layout Plain Layout

 * @param textLength Length of the text to be processed.
\end_layout

\begin_layout Plain Layout

 * @param Pattern Pointer to the pattern to find within the text
\end_layout

\begin_layout Plain Layout

 * @param patternLength Length of the pattern string
\end_layout

\begin_layout Plain Layout

 * @return Index of pattern in text, otherwise -1 if not found.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

int KMPMatch(char* Text, int textLength, char* Pattern, int patternLength)
 {
\end_layout

\begin_layout Plain Layout

  char* failure = KMPFailure(Pattern, patternLength);
\end_layout

\begin_layout Plain Layout

  int indexI = 0;
\end_layout

\begin_layout Plain Layout

  int indexJ = 0;
\end_layout

\begin_layout Plain Layout

  while (indexI < textLength) {
\end_layout

\begin_layout Plain Layout

    if (Pattern[indexJ] == Text[indexI]) {
\end_layout

\begin_layout Plain Layout

      if (indexJ == (patternLength - 1)) {
\end_layout

\begin_layout Plain Layout

        delete(failure); // Found a match, so return the index.
\end_layout

\begin_layout Plain Layout

        return (indexI - patternLength + 1);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      indexI++;
\end_layout

\begin_layout Plain Layout

      indexJ++;
\end_layout

\begin_layout Plain Layout

    } else if (indexJ > 0) { // No match but advanced in P.
\end_layout

\begin_layout Plain Layout

      indexJ = failure[indexJ - 1]; // Move forward appropriate amount.
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      indexI++;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  delete(failure);
\end_layout

\begin_layout Plain Layout

  return -1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
KMP String Match (C++)
\begin_inset CommandInset label
LatexCommand label
name "lis:KMP-String-Match"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem - Big String Search
\end_layout

\begin_layout Standard
Search some text to locate a particular pattern.
 If the pattern exists in the text, output the 0-based index of the pattern
 in the text.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
The first line of input will be 
\shape italic
N (1 <= N <= 1000)
\shape default
, the number of test cases to run.
 On each of the next 
\shape italic
2N
\shape default
 lines will be two strings.
 The first string will be the pattern to search for.
 On the next line will be the text to search in.
 All pattern strings will have a length between 1 and 100,000 inclusive.
 All text strings will have a length between 1 and 500,000 inclusive.
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
5
\begin_inset Newline newline
\end_inset

the 
\begin_inset Newline newline
\end_inset

the quick brown fox jumps over the lazy dog
\begin_inset Newline newline
\end_inset

000111 
\begin_inset Newline newline
\end_inset

010101010101000110000111 
\begin_inset Newline newline
\end_inset

CGAT 
\begin_inset Newline newline
\end_inset

TGATCTAGCTAGCTAGCTAGCTAGCATACGCATAGCTA
\begin_inset Newline newline
\end_inset

happy 
\begin_inset Newline newline
\end_inset

I could be happy if I didn’t have to work
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
For each test case, output the test case number followed by a space, and
 then the 0-based index of the first letter of the pattern in the text if
 the pattern can be found, or NOT FOUND if the pattern does not exist in
 the text.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
1 0 
\begin_inset Newline newline
\end_inset

2 18
\begin_inset Newline newline
\end_inset

3 NOT FOUND 
\begin_inset Newline newline
\end_inset

4 11
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Solution
\end_layout

\begin_layout Standard
A sample solution to the Big String Search problem can be found in Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Bis"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language={[ANSI]C++}"
inline false
status open

\begin_layout Plain Layout

#include <cstdlib>
\end_layout

\begin_layout Plain Layout

#include <cstdio>
\end_layout

\begin_layout Plain Layout

#include <cstring>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define MAX_PATTERN_LENGTH 100000
\end_layout

\begin_layout Plain Layout

#define MAX_TEXT_LENGTH 500000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int testCases = 0;
\end_layout

\begin_layout Plain Layout

char pattern[MAX_PATTERN_LENGTH];
\end_layout

\begin_layout Plain Layout

char text[MAX_TEXT_LENGTH];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int index = 0;
\end_layout

\begin_layout Plain Layout

int testCount = 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * KMP Failure function.
\end_layout

\begin_layout Plain Layout

 * @param Pattern Pointer to the pattern to be processed to derive the failure
 function.
\end_layout

\begin_layout Plain Layout

 * @param patternLength Length of pattern.
\end_layout

\begin_layout Plain Layout

 * @return The failure function (array of int).
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

int *KMPFailure(char *Pattern, int patternLength) {
\end_layout

\begin_layout Plain Layout

  int indexI = 1;
\end_layout

\begin_layout Plain Layout

  int indexJ = 0;
\end_layout

\begin_layout Plain Layout

  int* failure = new int[patternLength]; // Create new function f.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  failure[0] = 0;
\end_layout

\begin_layout Plain Layout

  while (indexI < patternLength) {
\end_layout

\begin_layout Plain Layout

    if (Pattern[indexJ] == Pattern[indexI]) {
\end_layout

\begin_layout Plain Layout

      failure[indexI++] = ++indexJ;
\end_layout

\begin_layout Plain Layout

    } else if (indexJ > 0) {
\end_layout

\begin_layout Plain Layout

      indexJ = failure[indexJ - 1];
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      failure[indexI++] = 0;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return failure;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Utilise the KMP Substring search algorithm to find a pattern in text.
\end_layout

\begin_layout Plain Layout

 * @param Text Pointer to the text to be searched.
\end_layout

\begin_layout Plain Layout

 * @param textLength Length of the text to be processed.
\end_layout

\begin_layout Plain Layout

 * @param Pattern Pointer to the pattern to find within the text
\end_layout

\begin_layout Plain Layout

 * @param patternLength Length of the pattern string
\end_layout

\begin_layout Plain Layout

 * @return Index of pattern in text, otherwise -1 if not found.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

int KMPMatch(char* Text, int textLength, char* Pattern, int patternLength)
 {
\end_layout

\begin_layout Plain Layout

  int* failure = KMPFailure(Pattern, patternLength);
\end_layout

\begin_layout Plain Layout

  int indexI = 0;
\end_layout

\begin_layout Plain Layout

  int indexJ = 0;
\end_layout

\begin_layout Plain Layout

  while (indexI < textLength) {
\end_layout

\begin_layout Plain Layout

    if (Pattern[indexJ] == Text[indexI]) {
\end_layout

\begin_layout Plain Layout

      if (indexJ == (patternLength - 1)) {
\end_layout

\begin_layout Plain Layout

        delete [] failure;
\end_layout

\begin_layout Plain Layout

        return (indexI - patternLength + 1);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      indexI++;
\end_layout

\begin_layout Plain Layout

      indexJ++;
\end_layout

\begin_layout Plain Layout

    } else if (indexJ > 0) { // No match but advanced in P.
\end_layout

\begin_layout Plain Layout

      indexJ = failure[indexJ - 1]; // Move forward appropriate amount.
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      indexI++;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  delete [] failure;
\end_layout

\begin_layout Plain Layout

  return -1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

 * Main Function
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

  scanf("%d
\backslash
n", &testCases);
\end_layout

\begin_layout Plain Layout

  while (testCases--) {
\end_layout

\begin_layout Plain Layout

    // Read in our pattern and text
\end_layout

\begin_layout Plain Layout

    gets(pattern);
\end_layout

\begin_layout Plain Layout

    gets(text);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // found our pattern in text and report the location.
\end_layout

\begin_layout Plain Layout

    index = KMPMatch(text, strlen(text), pattern, strlen(pattern));
\end_layout

\begin_layout Plain Layout

    if (index == -1) {
\end_layout

\begin_layout Plain Layout

      printf("%d NOT FOUND
\backslash
n", testCount++);
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      printf("%d %d
\backslash
n", testCount++, index);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Solution to Big String Search (C++)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Bis"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Big String Problem is a relatively simple problem that relies on the
 string search algorithm to be correct.
 As can be seen in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Bis"

\end_inset

, within the main() function, while-loop comprises of simply reading in
 the pattern and text strings, performing the search function and reporting
 the results of the search.
\end_layout

\begin_layout Standard
Sample test cases include:
\end_layout

\begin_layout Itemize
Pattern and Text length being 1.
\end_layout

\begin_layout Itemize
Pattern length being greater than the text length.
\end_layout

\begin_layout Subsection
Graph Theory (Basic)
\end_layout

\begin_layout Standard
Graph Theory forms one of the principle areas of modern computer science
 due to its ability to be applied to a wide range of problems and areas
 of study.
\end_layout

\begin_layout Standard
When viewed abstractly, a 
\series bold
graph
\series default
 
\shape italic
G
\shape default
 is simply a set of 
\shape italic
V
\shape default
 of 
\series bold
vertices
\series default
 and a collection of 
\shape italic
E
\shape default
 of pairs of vertices from 
\shape italic
V
\shape default
, called 
\series bold
edges
\series default
.
 Thus, a graph is a way of representing connections or relationships between
 pairs of objects from some set 
\shape italic
V
\shape default
.
 Egdes in a graph are either 
\series bold
directed
\series default
 or 
\series bold
undirected
\series default
, that is an edge may only allow connection in a single direction between
 vertices.
 Egdes may also have a 
\series bold
weight
\series default
 applied that defines the cost
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A weight may have either a positive or negative value depending on what
 is being modelled.
\end_layout

\end_inset

 of utilising the edge for some defined operation.
\end_layout

\begin_layout Standard
Using the graph in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Basic-Graph"

\end_inset

 as an example, each location (town/suburb) is a vertex, and the road is
 an edge between locations.
 The directions denote if the road is a one-way street or two-way, and the
 weight is the defined time to travel on that road to get between the vertices.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Graph Basic Description.eps
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Basic Graph
\begin_inset CommandInset label
LatexCommand label
name "fig:Basic-Graph"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using the graph as shown, some examples include:
\end_layout

\begin_layout Itemize
It's quicker to travel from Caboolture to Samford Valley via Brisbane, than
 it is to go via a direct route.
 (70 vs 90)
\end_layout

\begin_layout Itemize
For someone living in Logan, in order to travel to Brisbane, must travel
 either through Ipswich or the Gold Coast.
 (via Ipswich offers the shortest time).
\end_layout

\begin_layout Itemize
The only way to travel from the Gold Coast to Samford Valley is via Brisbane.
\end_layout

\begin_layout Itemize
And if you arrive in Samford Valley, there is no road that leads out!
\end_layout

\begin_layout Standard
Other terminology that is often applied to Graph Theory includes:
\end_layout

\begin_layout Itemize
A 
\series bold
degree
\series default
 of 
\shape italic
V
\shape default
, denoted 
\shape italic
deg(v)
\shape default
, is the number of edges incident to 
\shape italic
V
\shape default
.
 This may also be broken down into in-degree and ou-degree when applied
 with a directed graph.
 (The count of the edges leading to or from the vertex respectively).
\end_layout

\begin_layout Itemize
A 
\series bold
trail
\series default
 in a graph, is a sequences of necessiarily distinct vertices, but distinct
 edges.
\end_layout

\begin_layout Itemize
A 
\series bold
path
\series default
 is a trail in which all vertices are distinct.
\end_layout

\begin_layout Itemize
A 
\series bold
circuit
\series default
 is a trail in which the starting vertex is the same as the ending vertex.
\end_layout

\begin_layout Itemize
A 
\series bold
cycle
\series default
 is a path in which the starting vertex is the same as the ending vertex.
\end_layout

\begin_layout Itemize
A 
\series bold
Hamiltonian cycle
\series default
 is a cycle that contains all the vertices of a graph.
\end_layout

\begin_layout Itemize
A 
\series bold
sparse
\series default
 graph is a graph with few edges, conversely, a 
\series bold
dense
\series default
 graph is a graph with many edges.
\end_layout

\begin_layout Standard
Other terms commonly used within Graph Theory will be introduced later through
 out this guide as needed, especially when utilised within description of
 an algorithm.
\end_layout

\begin_layout Subsubsection
Representation as adjacency matrix and adjacency list.
\end_layout

\begin_layout Standard
Graphs may be represented in two forms, either as an adjacency matrix or
 as an adjacency list.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Basic Graph.eps
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Basic Graph Example (weighted, undirected)
\begin_inset CommandInset label
LatexCommand label
name "fig:Basic-Graph-Example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Adjacency List
\end_layout

\begin_layout Standard
An Adjacency List is a method of representing a graph in a space efficient
 form, in that a vector (array) of vertices is maintained, and each element
 of the vector maintains a list (typically a linked list or ArrayList) of
 vertices that may be reached from the selected element.
 For weighted graphs, each element in the list also includes the edge weight
 in addition to the vertex.
\end_layout

\begin_layout Standard
Using the graph in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Basic-Graph-Example"

\end_inset

, the represented Adjacency List is shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Adjacency-List"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vertex
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
List
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,5 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 D,10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,5 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 C,6 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 D,3 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 E,2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,6 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 D,7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,10 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 B,3 
\begin_inset ERT
status open

\begin_layout Plain Layout

 $
\backslash
rightarrow$
\end_layout

\end_inset

 E,4 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 F,8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,2 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 C,7 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 D,4 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 F,12 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 G,6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D,8 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 E,12 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 G,1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E,6 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 F,1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Adjacency List
\begin_inset CommandInset label
LatexCommand label
name "tab:Adjacency-List"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Two advantages of utilising the Adjacency List to represent a graph are:
\end_layout

\begin_layout Itemize
The space required to store the list is minimal in that no wasted space
 is present.
\end_layout

\begin_layout Itemize
Travesal of the graph is easy, by simply following the vertex information
 in the list.
\end_layout

\begin_layout Subparagraph
Description of working
\end_layout

\begin_layout Standard
The adjacency list works primarily as it stores references and not copies
 to other vertices within the list, as well as the weights associated with
 the edge to the vertex.
 Additionally the data structure naturally supports both unweighted and
 weighted graphs, as well as directed and undirected graphs within the one
 implementation.
\end_layout

\begin_layout Standard
For graph travesal, you can simply make one of vertices within the list
 the current location, and therefore find it's edge list as well.
 This allows for a naturally recursive implementation for many graph traversal
 algorithms.
\end_layout

\begin_layout Standard
The disadvantages of the adjacency list implementation, is that in order
 to find if either an edge between vertices exist, or any cost associated,
 the list must be scanned to find the other vertex, which in worst case
 may be 
\series bold
O(n)
\series default
.
\end_layout

\begin_layout Subparagraph
Implementation
\end_layout

\begin_layout Standard
A storage class implemented in Java for representing an Adjacency List is
 shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Adjacency-List-(Java)"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.ArrayList;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class AdjacencyList {
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  public ArrayList<ArrayList<edge>> adjacencyList;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  public AdjacencyList(int vertexCount){
\end_layout

\begin_layout Plain Layout

    // Create the arraylist of arraylist of edges.
\end_layout

\begin_layout Plain Layout

    adjacencyList = new ArrayList<ArrayList<edge>>();
\end_layout

\begin_layout Plain Layout

    for (int n = 0; n < vertexCount; n++) {
\end_layout

\begin_layout Plain Layout

      adjacencyList.add(new ArrayList<edge>());
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Generic Edge List to store our edge information.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class edge implements Comparable<edge> {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * destination vertex and weight.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public int vertex, weight;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Constructor
\end_layout

\begin_layout Plain Layout

     *
\end_layout

\begin_layout Plain Layout

     * @param v The destination vertex
\end_layout

\begin_layout Plain Layout

     * @param w The weight of the edge.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public edge(int v, int w) {
\end_layout

\begin_layout Plain Layout

      vertex = v;
\end_layout

\begin_layout Plain Layout

      weight = w;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Compare function for collection sort.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    @Override
\end_layout

\begin_layout Plain Layout

    public int compareTo(edge o) {
\end_layout

\begin_layout Plain Layout

      if (this.vertex < o.vertex) {
\end_layout

\begin_layout Plain Layout

        return -1;
\end_layout

\begin_layout Plain Layout

      } else if (this.vertex > o.vertex) {
\end_layout

\begin_layout Plain Layout

        return 1;
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        return 0;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }  
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Adjacency List (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Adjacency-List-(Java)"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Sample Problem - Adjacency List
\end_layout

\begin_layout Standard
Construct the adjacency list representation of an unweighted undirected
 graph.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
The first line of input will be a number on a line by itself which is the
 number of test cases to run.
 For each test case, the first line will be two numbers separated by a space
 
\shape italic
N
\shape default
 and 
\shape italic
M
\shape default
, where 
\shape italic
N (1 <= N <= 5000)
\shape default
 is the number of nodes in the graph and 
\shape italic
M
\shape default
 
\shape italic
(1 <= M <= 10000) 
\shape default
is the number of edges.
 The graph nodes will be numbered 0 to 
\shape italic
N
\shape default
-1.
 Each of the next 
\shape italic
M
\shape default
 lines contain 2 numbers 
\shape italic
A
\shape default
 and 
\shape italic
B
\shape default
 separated by a space representing an edge in the graph between 
\shape italic
A (0 <= A < N)
\shape default
 and 
\shape italic
B (0 <= B < N)
\shape default
.
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
2 
\begin_inset Newline newline
\end_inset

4 4 
\begin_inset Newline newline
\end_inset

0 1 
\begin_inset Newline newline
\end_inset

1 2 
\begin_inset Newline newline
\end_inset

2 0 
\begin_inset Newline newline
\end_inset

2 3 
\begin_inset Newline newline
\end_inset

4 4 
\begin_inset Newline newline
\end_inset

0 3 
\begin_inset Newline newline
\end_inset

1 0 
\begin_inset Newline newline
\end_inset

2 0 
\begin_inset Newline newline
\end_inset

2 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
For each test case, output the test case number on a line followed by the
 adjacency list representation of the graph.
 For each node n in the graph output a line listing the number of the node
 followed by a colon and a space, then a comma and single space separated
 list of the nodes adjacent to n.
 The adjacent nodes should be listed in ascending order.
 See the example output below.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
1 
\begin_inset Newline newline
\end_inset

0: 1, 2 
\begin_inset Newline newline
\end_inset

1: 0, 2 
\begin_inset Newline newline
\end_inset

2: 0, 1, 3 
\begin_inset Newline newline
\end_inset

3: 2 
\begin_inset Newline newline
\end_inset

2 
\begin_inset Newline newline
\end_inset

0: 1, 2, 3 
\begin_inset Newline newline
\end_inset

1: 0 
\begin_inset Newline newline
\end_inset

2: 0, 3 
\begin_inset Newline newline
\end_inset

3: 0, 2
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Sample Solution
\end_layout

\begin_layout Standard
A sample solution to the Adjacency List problem can be found in Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Adjacency-1"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import java.util.ArrayList;
\end_layout

\begin_layout Plain Layout

import java.util.Collections;
\end_layout

\begin_layout Plain Layout

import java.util.HashSet;
\end_layout

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class AdjacencyList {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  static ArrayList<ArrayList<edge>> adjacencyList;
\end_layout

\begin_layout Plain Layout

  static ArrayList<HashSet<Integer>> adjacencyEdges;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    new AdjacencyList().run();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Run interface to be called from main().
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public void run() {
\end_layout

\begin_layout Plain Layout

    Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // get first line and get the number of cases to test.
\end_layout

\begin_layout Plain Layout

    int caseCount = Integer.parseInt(in.nextLine());
\end_layout

\begin_layout Plain Layout

    int loopCount = 0;
\end_layout

\begin_layout Plain Layout

    while (caseCount - loopCount > 0) {
\end_layout

\begin_layout Plain Layout

      String line = in.nextLine();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // extract numbers, this is the node count and edge count.
\end_layout

\begin_layout Plain Layout

      Scanner sc = new Scanner(line);
\end_layout

\begin_layout Plain Layout

      int vertexCount = sc.nextInt();
\end_layout

\begin_layout Plain Layout

      int edgeCount = sc.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Create the adjacency List.
\end_layout

\begin_layout Plain Layout

      adjacencyList = new ArrayList<ArrayList<edge>>();
\end_layout

\begin_layout Plain Layout

      adjacencyEdges = new ArrayList<HashSet<Integer>>();
\end_layout

\begin_layout Plain Layout

      for (int n = 0; n < vertexCount; n++) {
\end_layout

\begin_layout Plain Layout

        adjacencyList.add(new ArrayList<edge>());
\end_layout

\begin_layout Plain Layout

        adjacencyEdges.add(new HashSet<Integer>());
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      while (edgeCount-- > 0) {
\end_layout

\begin_layout Plain Layout

        // Get our next edge...
\end_layout

\begin_layout Plain Layout

        line = in.nextLine();
\end_layout

\begin_layout Plain Layout

        // extract numbers, this is the node count and edge count.
\end_layout

\begin_layout Plain Layout

        sc = new Scanner(line);
\end_layout

\begin_layout Plain Layout

        int source = sc.nextInt();
\end_layout

\begin_layout Plain Layout

        int dest = sc.nextInt();
\end_layout

\begin_layout Plain Layout

        edge edge1 = new edge(dest, 0);
\end_layout

\begin_layout Plain Layout

        edge edge2 = new edge(source, 0);
\end_layout

\begin_layout Plain Layout

        if (!adjacencyEdges.get(source).contains(edge1.hashCode())) {
\end_layout

\begin_layout Plain Layout

          adjacencyEdges.get(source).add(edge1.hashCode());
\end_layout

\begin_layout Plain Layout

          adjacencyList.get(source).add(edge1);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        if (!adjacencyEdges.get(dest).contains(edge2.hashCode())) {
\end_layout

\begin_layout Plain Layout

          adjacencyEdges.get(dest).add(edge2.hashCode());
\end_layout

\begin_layout Plain Layout

          adjacencyList.get(dest).add(edge2);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      System.out.printf("%d
\backslash
n", ++loopCount);
\end_layout

\begin_layout Plain Layout

      // Print the resulting adjacency list.
\end_layout

\begin_layout Plain Layout

      for (int i = 0; i < vertexCount; i++) {
\end_layout

\begin_layout Plain Layout

        // Print the vertex number.
\end_layout

\begin_layout Plain Layout

        System.out.printf("%d: ", i);
\end_layout

\begin_layout Plain Layout

        ArrayList<edge> edges = adjacencyList.get(i);
\end_layout

\begin_layout Plain Layout

        // Sort the array list.
\end_layout

\begin_layout Plain Layout

        Collections.sort(edges);
\end_layout

\begin_layout Plain Layout

        // Print the contents of the array list.
\end_layout

\begin_layout Plain Layout

        for (int node = 0; node < edges.size(); node++) {
\end_layout

\begin_layout Plain Layout

          if (node + 1 == edges.size()) {
\end_layout

\begin_layout Plain Layout

            System.out.print(edges.get(node).vertex);
\end_layout

\begin_layout Plain Layout

          } else {
\end_layout

\begin_layout Plain Layout

            System.out.printf("%d, ", edges.get(node).vertex);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        System.out.println();
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Generic Edge List to store our edge information.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class edge implements Comparable<edge> {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * destination vertex and weight.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public int vertex, weight;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Constructor
\end_layout

\begin_layout Plain Layout

     *
\end_layout

\begin_layout Plain Layout

     * @param v The destination vertex
\end_layout

\begin_layout Plain Layout

     * @param w The weight of the edge.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public edge(int v, int w) {
\end_layout

\begin_layout Plain Layout

      vertex = v;
\end_layout

\begin_layout Plain Layout

      weight = w;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Compare function for collection sort.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    @Override
\end_layout

\begin_layout Plain Layout

    public int compareTo(edge o) {
\end_layout

\begin_layout Plain Layout

      if (this.vertex < o.vertex) {
\end_layout

\begin_layout Plain Layout

        return -1;
\end_layout

\begin_layout Plain Layout

      } else if (this.vertex > o.vertex) {
\end_layout

\begin_layout Plain Layout

        return 1;
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        return 0;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    @Override
\end_layout

\begin_layout Plain Layout

    public int hashCode() {
\end_layout

\begin_layout Plain Layout

      int hash = 1;
\end_layout

\begin_layout Plain Layout

      hash = 100007 * hash + this.vertex;
\end_layout

\begin_layout Plain Layout

      hash = 100007 * hash + this.weight;
\end_layout

\begin_layout Plain Layout

      return hash;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Solution to Adjacency List Problem (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Adjacency"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Adjacency List Problem is a relatively simple problem that relies on
 the data structure implementation to be correct.
 As can be seen in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Adjacency-1"

\end_inset

, within the run() method, while-loop comprises of simply reading in the
 vertex information for each graph, building a list in memory.
 The only main complication is the list being printed in an ascending manner,
 which is solved by sorting it with 
\family typewriter
Collections.sort()
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout
Collections.sort() utilises a merge sort, offering 
\series bold
O(n log n)
\series default
 performance for sorting.
\end_layout

\end_inset

, and printing the result.
\end_layout

\begin_layout Standard
Sample test cases include:
\end_layout

\begin_layout Itemize
Edge count for the entire graph being zero.
\end_layout

\begin_layout Itemize
The degree of an vertex being zero.
\end_layout

\begin_layout Itemize
Receiving the same edge more than once in the input strings.
\end_layout

\begin_layout Paragraph
Adjacency Matrix
\end_layout

\begin_layout Standard
An Adjacency Matrix is a method of representing a graph within a two-dimension
 matrix which offers 
\series bold
O(1)
\series default
 lookout performance to determine if either an edge exists, or obtain the
 weight of an edge.
 
\end_layout

\begin_layout Standard
Using the graph in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Basic-Graph-Example"

\end_inset

, the represented Adjacency Matrix is shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Adjacency-Matrix"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="8">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vertex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Adjacency Matrix
\begin_inset CommandInset label
LatexCommand label
name "tab:Adjacency-Matrix"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Description of working
\end_layout

\begin_layout Standard
The Adjacency Matrix works well with either dense graphs (as the storage
 requirement between an Adjancey Matrix and Adjacency List would be roughly
 equal), or when performance is required when either utilising edge information
 or for performing edge manipulation operations.
\end_layout

\begin_layout Standard
The Adjacency Matrix utilises an 
\begin_inset Formula $n\times n$
\end_inset

 array 
\begin_inset Formula $A$
\end_inset

 to store the edge information, such that 
\begin_inset Formula $A[i,j]$
\end_inset

 stores a reference to edge (
\begin_inset Formula $i,j$
\end_inset

), if such an edge exists.
 If there is no edge (
\begin_inset Formula $i,j$
\end_inset

), then 
\begin_inset Formula $A[i,j]$
\end_inset

 is null, with null typically being represented by 0 (zero).
 For weighted graphs each cell, holds the weight of the edge, and for un-weighte
d graphs, each cell will hold a boolean value either 
\family typewriter
true
\family default
 (or 1) for an edge, or 
\family typewriter
false
\family default
 (0) for no edge.
\end_layout

\begin_layout Standard
Using Adjacency Matrix 
\begin_inset Formula $A$
\end_inset

, we can perform edge lookup in 
\series bold
O(1)
\series default
 time, as each lookup is the same as accessing 
\begin_inset Formula $A[i,j]$
\end_inset

.
 However, the the storage requirements for an Adjacency Matrix is 
\series bold
O(n
\begin_inset script superscript

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset

)
\series default
 which may representing very large graphs difficult.
\end_layout

\begin_layout Subparagraph
Implementation
\end_layout

\begin_layout Standard
A storage class implemented in Java for representing an Adjacency Matrix
 is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Adjacency-Matrix-(Java)"

\end_inset

.
 However it should be noted, that typically within the competition, a simple
 two dimension array of the corrrect type is used instead of the generic
 class implementation shown.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

public class AdjacencyMatrix<E> {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  private E[][] matrix;
\end_layout

\begin_layout Plain Layout

  private boolean directedGraph = false;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Create a new adjacency matrix of size n.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param numberOfVertex The number of vertices in the graph.
\end_layout

\begin_layout Plain Layout

   * @param directedGraph If the graph is directed or undirected.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public void AdjacencyMatrix(int numberOfVertex, boolean directedGraph)
 {
\end_layout

\begin_layout Plain Layout

    // Create a matrix
\end_layout

\begin_layout Plain Layout

    matrix = (E[][]) new Object[numberOfVertex][numberOfVertex];
\end_layout

\begin_layout Plain Layout

    // Set all egdes to 0.
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < numberOfVertex; i++) {
\end_layout

\begin_layout Plain Layout

      for (int j = 0; j < numberOfVertex; j++) {
\end_layout

\begin_layout Plain Layout

        setEdge(i, j, null);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    // Set if graph is directed.
\end_layout

\begin_layout Plain Layout

    this.directedGraph = directedGraph;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Find if the specified edge exists.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param i Source vertex
\end_layout

\begin_layout Plain Layout

   * @param j Destination vertex
\end_layout

\begin_layout Plain Layout

   * @return true, if an edge is present otherwise false.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public boolean isEdge(int i, int j) {
\end_layout

\begin_layout Plain Layout

    return (matrix[i][j] != null);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Set the weight of an edge.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param i Source vertex
\end_layout

\begin_layout Plain Layout

   * @param j Destination vertex
\end_layout

\begin_layout Plain Layout

   * @param weight The new weight to be applied to this edge.
 (May be zero to
\end_layout

\begin_layout Plain Layout

   * remove the edge from the graph).
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public void setEdge(int i, int j, E weight) {
\end_layout

\begin_layout Plain Layout

    matrix[i][j] = weight;
\end_layout

\begin_layout Plain Layout

    if (!directedGraph) {
\end_layout

\begin_layout Plain Layout

      // If undirected graph then set the back edge as well.
\end_layout

\begin_layout Plain Layout

      matrix[j][i] = weight;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Get the weight of an edge.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param i Source vertex
\end_layout

\begin_layout Plain Layout

   * @param j Destination vertex
\end_layout

\begin_layout Plain Layout

   * @return The current weight of an edge, or null if no edge.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public E getEdge(int i, int j) {
\end_layout

\begin_layout Plain Layout

    return matrix[i][j];
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Retrieve the matrix as a string suitable for printing.
\end_layout

\begin_layout Plain Layout

   * @return String representation of the matrix.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  @Override
\end_layout

\begin_layout Plain Layout

  public String toString(){
\end_layout

\begin_layout Plain Layout

    return matrix.toString();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Adjacency Matrix (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Adjacency-Matrix-(Java)"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Sample Problem - Adjacency Matrix
\end_layout

\begin_layout Standard
Construct the adjacency matrix representation of a weighted directed graph.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
The first line of input will be a number on a line by itself which is the
 number of test cases to run.
 For each test case, the first line will be two numbers separated by a space
 
\shape italic
N
\shape default
 and 
\shape italic
M
\shape default
, where 
\shape italic
N (1 <= N <= 5000)
\shape default
 is the number of nodes in the graph and 
\shape italic
M
\shape default
 
\shape italic
(1 <= M <= 10000)
\shape default
 is the number of edges.
 The graph nodes will be numbered 0 to 
\shape italic
N
\shape default
-1.
 Each of the next 
\shape italic
M
\shape default
 lines contain 3 numbers 
\shape italic
A B
\shape default
 and 
\shape italic
C
\shape default
 each separated by a space representing an edge in the graph from 
\shape italic
A (0 <= A < N)
\shape default
 to 
\shape italic
B (0 <= B < N) 
\shape default
with weight 
\shape italic
C (0 < C <= 1000)
\shape default
.
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
2 
\begin_inset Newline newline
\end_inset

4 4 
\begin_inset Newline newline
\end_inset

0 1 3 
\begin_inset Newline newline
\end_inset

1 2 6 
\begin_inset Newline newline
\end_inset

2 0 2 
\begin_inset Newline newline
\end_inset

2 3 4 
\begin_inset Newline newline
\end_inset

4 4 
\begin_inset Newline newline
\end_inset

0 3 10 
\begin_inset Newline newline
\end_inset

1 0 100 
\begin_inset Newline newline
\end_inset

2 0 1000 
\begin_inset Newline newline
\end_inset

2 3 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
For each test case, output the test case number on a line followed by the
 adjacency matrix representation of the graph.
 The graph node numbers should appear as headings on the columns and rows
 of the matrix and the edge weights should appear as the contents of the
 matrix.
 Each number should be printed in a field width of 4 with a single space
 between all headings and values.
 See the example output below.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

1 
\end_layout

\begin_layout Plain Layout

        0    1    2    3
\end_layout

\begin_layout Plain Layout

   0    0    3    0    0 
\end_layout

\begin_layout Plain Layout

   1    0    0    6    0 
\end_layout

\begin_layout Plain Layout

   2    2    0    0    4 
\end_layout

\begin_layout Plain Layout

   3    0    0    0    0 
\end_layout

\begin_layout Plain Layout

2 
\end_layout

\begin_layout Plain Layout

        0    1    2    3 
\end_layout

\begin_layout Plain Layout

   0    0    0    0   10
\end_layout

\begin_layout Plain Layout

   1  100    0    0    0 
\end_layout

\begin_layout Plain Layout

   2 1000    0    0    2 
\end_layout

\begin_layout Plain Layout

   3    0    0    0    0
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Sample Solution
\end_layout

\begin_layout Standard
A sample solution to the Adjacency Matrix problem can be found in Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Adjacency-1"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class AdjacencyMatrixProblem {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    int[][] adjacencyMatrix;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // get first line and get the number of cases to test.
\end_layout

\begin_layout Plain Layout

    int caseCount = Integer.parseInt(in.nextLine());
\end_layout

\begin_layout Plain Layout

    int loopCount = 0;
\end_layout

\begin_layout Plain Layout

    while (caseCount - loopCount > 0) {
\end_layout

\begin_layout Plain Layout

      String line = in.nextLine();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // extract numbers, this is the node count and edge count.
\end_layout

\begin_layout Plain Layout

      Scanner sc = new Scanner(line);
\end_layout

\begin_layout Plain Layout

      int vertexCount = sc.nextInt();
\end_layout

\begin_layout Plain Layout

      int edgeCount = sc.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Create the matrix, and clear the contents.
\end_layout

\begin_layout Plain Layout

      adjacencyMatrix = new int[vertexCount][vertexCount];
\end_layout

\begin_layout Plain Layout

      for (int i = 0; i < vertexCount; i++) {
\end_layout

\begin_layout Plain Layout

        for (int j = 0; j < vertexCount; j++) {
\end_layout

\begin_layout Plain Layout

          adjacencyMatrix[i][j] = 0;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      // Read in all the edges.
\end_layout

\begin_layout Plain Layout

      while (edgeCount-- > 0) {
\end_layout

\begin_layout Plain Layout

        // Get our next edge...
\end_layout

\begin_layout Plain Layout

        line = in.nextLine();
\end_layout

\begin_layout Plain Layout

        // extract numbers, this is the node count and edge count.
\end_layout

\begin_layout Plain Layout

        sc = new Scanner(line);
\end_layout

\begin_layout Plain Layout

        int source = sc.nextInt();
\end_layout

\begin_layout Plain Layout

        int destination = sc.nextInt();
\end_layout

\begin_layout Plain Layout

        int weight = sc.nextInt();
\end_layout

\begin_layout Plain Layout

        adjacencyMatrix[source][destination] = weight;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      // Print out the matrix.
\end_layout

\begin_layout Plain Layout

      System.out.printf("%d
\backslash
n    ", ++loopCount);
\end_layout

\begin_layout Plain Layout

      // Print the row header.
\end_layout

\begin_layout Plain Layout

      for(int i = 0; i < vertexCount; i++){
\end_layout

\begin_layout Plain Layout

        System.out.printf("%5d", i);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      System.out.println();
\end_layout

\begin_layout Plain Layout

      // Print the matrix contents
\end_layout

\begin_layout Plain Layout

      for (int i = 0; i < vertexCount; i++) {
\end_layout

\begin_layout Plain Layout

        System.out.printf("%4d", i); // Row number
\end_layout

\begin_layout Plain Layout

        for (int j = 0; j < vertexCount; j++) {
\end_layout

\begin_layout Plain Layout

          System.out.printf("%5d",adjacencyMatrix[i][j]); // Cell
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        System.out.println();
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Solution to Adjacency Matrix Problem (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Adjacency-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Adjacency Matrix Problem is a relatively simple problem that relies
 on the data structure implementation to be correct.
 Since the underlying data structure is a simple array, there is little
 that can go wrong.
\end_layout

\begin_layout Standard
The main challenges include:
\end_layout

\begin_layout Itemize
A graph with zero nodes.
\end_layout

\begin_layout Itemize
A graph with zero edges.
\end_layout

\begin_layout Itemize
Ensuring correct spacing when displaying the matrix.
\end_layout

\begin_layout Subsubsection
Graph Traversal
\end_layout

\begin_layout Standard
A common operation on a graph is to visit every vertex and perform an operation
 on it.
 This can be performed systematically through either a Breadth First Search
 (BFS) or a Depth First Search (DFS).
 Both DFS and BFS will visit all vertices in a graph, with the difference
 being in the order in which they visit each vertex.
\end_layout

\begin_layout Standard
Breadth First Search, after visting a given vertex 
\shape italic
n
\shape default
, will visit every unvisited vertex adjacent to 
\shape italic
n
\shape default
 before visiting any other nodes.
 Depth First Search, from a given vertex 
\shape italic
n
\shape default
, will proceed along a path from 
\shape italic
n
\shape default
 as deeply into the graph as possible before backtracking.
 With both algorithms, at any point we need to know:
\end_layout

\begin_layout Itemize
Which nodes we have visited.
\end_layout

\begin_layout Itemize
Which nodes we have found but need to visit.
\end_layout

\begin_layout Standard
Essentially the same algorithm is used for both BFS and DFS, however the
 datastructures to store the above knowledge points allow the algorithm
 to work differently.
 A BFS will use a queue datastructure, whilst DFS will use a stack datastructure
 to implement those knowledge points.
 The similarities can be seen comparing both Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Breadth-First-Search"

\end_inset

 and Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Depth-First-Search"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require A Graph $G$ and a vertex $s$.
 
\end_layout

\begin_layout Plain Layout


\backslash
Ensure A vertices are visited in a BFS fashion
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{BFS}{$G, s$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$L 
\backslash
gets 
\backslash
textsc{queue}()$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$L$.enqueue $ 
\backslash
gets s$} 
\backslash
Comment {enqueue $s$}
\end_layout

\begin_layout Plain Layout


\backslash
While {$L$ is not empty}
\end_layout

\begin_layout Plain Layout


\backslash
State {$v 
\backslash
gets L$.dequeue} 
\backslash
Comment {dequeue $v$}
\end_layout

\begin_layout Plain Layout


\backslash
State {visit $v$ and mark as visited} 
\backslash
Comment {perform operation on $v$}
\end_layout

\begin_layout Plain Layout


\backslash
ForAll {node $n$ adjacent to $v$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$n$ is not visited 
\backslash
textbf{and} not on queue}
\end_layout

\begin_layout Plain Layout


\backslash
State {$L$.enqueue $ 
\backslash
gets n$} 
\backslash
Comment {enqeue $n$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Breadth First Search
\begin_inset CommandInset label
LatexCommand label
name "alg:Breadth-First-Search"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require A Graph $G$ and a vertex $s$.
 
\end_layout

\begin_layout Plain Layout


\backslash
Ensure A vertices are visited in a DFS fashion
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{DFS}{$G, s$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$L 
\backslash
gets 
\backslash
textsc{stack}()$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$L$.push $ 
\backslash
gets s$} 
\backslash
Comment {push $s$}
\end_layout

\begin_layout Plain Layout


\backslash
While {$L$ is not empty}
\end_layout

\begin_layout Plain Layout


\backslash
State {$v 
\backslash
gets L$.pop} 
\backslash
Comment {pop $v$}
\end_layout

\begin_layout Plain Layout


\backslash
State {visit $v$ and mark as visited} 
\backslash
Comment {perform operation on $v$}
\end_layout

\begin_layout Plain Layout


\backslash
ForAll {node $n$ adjacent to $v$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$n$ is not visited 
\backslash
textbf{and} not on stack}
\end_layout

\begin_layout Plain Layout


\backslash
State {$L$.push $ 
\backslash
gets n$} 
\backslash
Comment {push $n$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Depth First Search
\begin_inset CommandInset label
LatexCommand label
name "alg:Depth-First-Search"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
The Depth First Search is considered an adventurous algorithm, in that it
 simple wanders the graph from vertex to vertex until it reaches a vertex
 in which it has no unexplored vertices adjacent to the current vertex.
 Once it reaches this point, it will backtrack until it finds a vertex which
 has unexplored neighbours and then continue on from this point, until all
 vertices have been visited.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:DFE-Example"

\end_inset

 displays an example of the DFS travesal, where the edges incident of a
 vertex are explored by alphabetical order of the adjacent vertices, starting
 at Vertex A.
 (The direction of travel is displayed by the arrows.
 In this example, no backtracking has taken place).
 The order of travesal in this instance is: A, B, C, E, D, F, G.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/DFS.eps
	width 65text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
DFS Example
\begin_inset CommandInset label
LatexCommand label
name "fig:DFE-Example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Breadth First Search is less adventurous than DFS, however instead of
 wandering the graph, BFS proceeds in rounds and subdivides the vertices
 into levels.
 Breadth First Search, after visting a given vertex 
\shape italic
n
\shape default
, will visit every unvisited vertex adjacent to 
\shape italic
n
\shape default
 before visiting any other nodes.
 For an unweighted graph, BFS therefore provides the shortests paths from
 the root vertex to all other vertices.
 BFS is also the basic implementation for a number of shortest paths algorithms.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:BFS-example"

\end_inset

 displays an example of the BFS traversal, where the edges incident of a
 vertex are explored by alphabetical order of the adjacent vertices, starting
 at Vertex A.
 (The discovery edges are shown with bold lines and the crossed edges with
 a dash line: (a) graph before the traversal; (b) discovery at level 1;
 (c) discovery at level 2; (d) discovery at level 3.).
 The order of travesal in this instance is: A, B, D, C, E, F, G.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/BFS.eps
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
BFS Example
\begin_inset CommandInset label
LatexCommand label
name "fig:BFS-example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
On comparing both implementations, it is considered that the DFS travesal
 is better for answering complex connectivity questions, such as determining
 if every pair of vertices in a graph can be connected by two disjoint paths.
 Whilst BFS is better for finding shortest path between a root vertex and
 a destination vertex.
\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
An implementation of the DFS algorithm in Java can be seen in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Breadth-Search-First"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import java.util.ArrayList;
\end_layout

\begin_layout Plain Layout

import java.util.LinkedList;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class BFS {
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Traverse a graph (as represented by an Adjacency Matrix) starting at
\end_layout

\begin_layout Plain Layout

   * root, printing the Vertex ID to console.
\end_layout

\begin_layout Plain Layout

   * @param matrix The Adjacency Matrix representing the Graph
\end_layout

\begin_layout Plain Layout

   * @param root The starting vertex
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public void BFSTravese(int[][] matrix, int root){
\end_layout

\begin_layout Plain Layout

    // Create a queue
\end_layout

\begin_layout Plain Layout

    LinkedList<Integer> queue = new LinkedList<Integer>();
\end_layout

\begin_layout Plain Layout

    // Create a visited list.
\end_layout

\begin_layout Plain Layout

    ArrayList<Integer> visited = new ArrayList<Integer>();
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    // Insert the start vertex into the queue.
\end_layout

\begin_layout Plain Layout

    queue.offer(root);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    // While the queue is not empty
\end_layout

\begin_layout Plain Layout

    while(!queue.isEmpty()){
\end_layout

\begin_layout Plain Layout

      int node = queue.poll();
\end_layout

\begin_layout Plain Layout

      visited.add(node);
\end_layout

\begin_layout Plain Layout

      System.out.printf("%d ", node); // Print the node ID to console.
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      for(int i = 0; i < matrix.length; i++){
\end_layout

\begin_layout Plain Layout

        // If node not in queue or in visited add to queue.
\end_layout

\begin_layout Plain Layout

        if(matrix[node][i] != 0){ // Make sure we are an edge
\end_layout

\begin_layout Plain Layout

          if(!queue.contains(i) && !visited.contains(i)){
\end_layout

\begin_layout Plain Layout

            queue.offer(i);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Breadth Search First (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Breadth-Search-First"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
An implementation of the Depth First Search can be seen in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Depth-Search-First"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import java.util.ArrayList;
\end_layout

\begin_layout Plain Layout

import java.util.Stack;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class DFS {
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Traverse a graph (as represented by an Adjacency Matrix) starting at
\end_layout

\begin_layout Plain Layout

   * root, printing the Vertex ID to console.
\end_layout

\begin_layout Plain Layout

   * @param matrix The Adjacency Matrix representing the Graph
\end_layout

\begin_layout Plain Layout

   * @param root The starting vertex
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public void DFSTravese(int[][] matrix, int root){
\end_layout

\begin_layout Plain Layout

    // Create a queue
\end_layout

\begin_layout Plain Layout

    Stack<Integer> stack = new Stack<Integer>();
\end_layout

\begin_layout Plain Layout

    // Create a visited list.
\end_layout

\begin_layout Plain Layout

    ArrayList<Integer> visited = new ArrayList<Integer>();
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    // Insert the start vertex into the queue.
\end_layout

\begin_layout Plain Layout

    stack.push(root);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    // While the queue is not empty
\end_layout

\begin_layout Plain Layout

    while(!stack.isEmpty()){
\end_layout

\begin_layout Plain Layout

      int node = stack.pop();
\end_layout

\begin_layout Plain Layout

      visited.add(node);
\end_layout

\begin_layout Plain Layout

      System.out.printf("%d ", node); // Print the node ID to console.
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      for(int i = 0; i < matrix.length; i++){
\end_layout

\begin_layout Plain Layout

        // If node not in queue or in visited add to queue.
\end_layout

\begin_layout Plain Layout

        if(matrix[node][i] != 0){ // Make sure we are an edge
\end_layout

\begin_layout Plain Layout

          if(!stack.contains(i) && !visited.contains(i)){
\end_layout

\begin_layout Plain Layout

            stack.push(i);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Depth Search First (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Depth-Search-First"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem - Monks
\end_layout

\begin_layout Standard
The order of Avidly Calculating Monks have their ashram high in the Sierra
 Nevada mountains east of Silicon Valley.
 After many years of training, each novice is faced with a final test before
 he can become a full member of the ACM.
 
\end_layout

\begin_layout Standard
In this test, the novice is led into a room containing three large urns,
 each containing a number of delicate glass beads.
 His task is to completely empty one of the urns using the following special
 procedure.
 Each day, the novice must select two of the urns, the source, and the destinati
on.
 He must then carefully move beads from the source urn to the destination
 urn, never breaking one, until the original contents of the destination
 urn are doubled.
 No other beads may be moved.
 
\end_layout

\begin_layout Standard
So for example, if the number of beads in the three urns were respectively
 
\end_layout

\begin_layout Standard
115, 200 and 256 beads 
\end_layout

\begin_layout Standard
then the novice might choose the second urn as the source and the first
 as the destination which would result in new contents of 
\end_layout

\begin_layout Standard
230, 85 and 256 beads
\end_layout

\begin_layout Standard
at the end of the first day.
 Then on the second day the novice might choose the urn with 256 beads as
 the source, and that with 85 as the destination leaving 
\end_layout

\begin_layout Standard
230, 170 and 171 beads 
\end_layout

\begin_layout Standard
at the end of the second day.
 If the original contents were 12, 30, and 12 beads, then choosing the first
 as source and the third as destination would result in 0, 30, and 24 beads
 and completion of the task.
 
\end_layout

\begin_layout Standard
The chief guru of the ACM always likes to have available a crib sheet indicating
 how many days the novices should take if they use as few transfers as possible
 to empty one of the urns.
 Your task is to provide this crib sheet.
 
\end_layout

\begin_layout Standard
Given a sequence of scenarios, each with a triple of non-negative integers
 representing the urn contents, determine for each scenario the smallest
 possible number of days required to empty one of the urns.
 This problem is guaranteed to have a solution in each case.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
Input will consist of a sequence of lines, each line representing a scenario.
 Each line consists of three integers in the range from 0 to 500 representing
 the initial urn contents, separated by single spaces.
 Input is terminated by the line “
\family typewriter
0 0 0
\family default
”, which is not processed.
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
0 3 5 
\begin_inset Newline newline
\end_inset

5 0 3 
\begin_inset Newline newline
\end_inset

1 1 1 
\begin_inset Newline newline
\end_inset

2 3 4 
\begin_inset Newline newline
\end_inset

12 3 8 
\begin_inset Newline newline
\end_inset

0 0 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
For each scenario “
\family typewriter
a b c
\family default
”, output a line of the form 
\end_layout

\begin_layout Standard

\family typewriter
a b c d
\family default
 
\end_layout

\begin_layout Standard
where d is the smallest possible number of days required to empty an urn
 beginning from contents 
\family typewriter
a
\family default
, 
\family typewriter
b
\family default
, and 
\family typewriter
c
\family default
.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
0 3 5 0
\begin_inset Newline newline
\end_inset

5 0 3 0
\begin_inset Newline newline
\end_inset

1 1 1 1
\begin_inset Newline newline
\end_inset

2 3 4 2
\begin_inset Newline newline
\end_inset

12 3 8 5
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Solution
\end_layout

\begin_layout Standard
A sample solution to the Monks problem can be found in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Monks"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.Arrays;
\end_layout

\begin_layout Plain Layout

import java.util.HashSet;
\end_layout

\begin_layout Plain Layout

import java.util.LinkedList;
\end_layout

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Jar Class to hold an instance of a set of Jars.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

class Jars {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  public final static int A = 0;
\end_layout

\begin_layout Plain Layout

  public final static int B = 1;
\end_layout

\begin_layout Plain Layout

  public final static int C = 2;
\end_layout

\begin_layout Plain Layout

  private int[] jars = {0, 0, 0};
\end_layout

\begin_layout Plain Layout

  public int count;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  @Override
\end_layout

\begin_layout Plain Layout

  public int hashCode() {
\end_layout

\begin_layout Plain Layout

    int hash = 1;
\end_layout

\begin_layout Plain Layout

    hash = 503 * hash + this.jars[0];
\end_layout

\begin_layout Plain Layout

    hash = 503 * hash + this.jars[1];
\end_layout

\begin_layout Plain Layout

    hash = 503 * hash + this.jars[2];
\end_layout

\begin_layout Plain Layout

    return hash;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  @Override
\end_layout

\begin_layout Plain Layout

  public boolean equals(Object obj) {
\end_layout

\begin_layout Plain Layout

    final Jars other = (Jars) obj;
\end_layout

\begin_layout Plain Layout

    return ((this.jars[A] == other.jars[A]) 
\end_layout

\begin_layout Plain Layout

            && (this.jars[B] == other.jars[B]) 
\end_layout

\begin_layout Plain Layout

            && (this.jars[C] == other.jars[C]));
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Constructor
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param JarA the number of beads in Jar A.
\end_layout

\begin_layout Plain Layout

   * @param JarB the number of beads in Jar B.
\end_layout

\begin_layout Plain Layout

   * @param JarC the number of beads in Jar C.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public Jars(int JarA, int JarB, int JarC) {
\end_layout

\begin_layout Plain Layout

    jars[A] = JarA;
\end_layout

\begin_layout Plain Layout

    jars[B] = JarB;
\end_layout

\begin_layout Plain Layout

    jars[C] = JarC;
\end_layout

\begin_layout Plain Layout

    count = 0;
\end_layout

\begin_layout Plain Layout

    Sort();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Copy Constructor
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param other The Jars to copy.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public Jars(Jars other) {
\end_layout

\begin_layout Plain Layout

    this.jars[A] = other.jars[A];
\end_layout

\begin_layout Plain Layout

    this.jars[B] = other.jars[B];
\end_layout

\begin_layout Plain Layout

    this.jars[C] = other.jars[C];
\end_layout

\begin_layout Plain Layout

    this.count = other.count;
\end_layout

\begin_layout Plain Layout

    Sort();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Sort the contents of the jars into numerical order.
 Thus: a < b < c
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public final void Sort() {
\end_layout

\begin_layout Plain Layout

    int tmp;
\end_layout

\begin_layout Plain Layout

    if (jars[B] < jars[A]) {
\end_layout

\begin_layout Plain Layout

      tmp = jars[B];
\end_layout

\begin_layout Plain Layout

      jars[B] = jars[A];
\end_layout

\begin_layout Plain Layout

      jars[A] = tmp;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (jars[C] < jars[B]) {
\end_layout

\begin_layout Plain Layout

      tmp = jars[C];
\end_layout

\begin_layout Plain Layout

      jars[C] = jars[B];
\end_layout

\begin_layout Plain Layout

      jars[B] = tmp;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (jars[B] < jars[A]) {
\end_layout

\begin_layout Plain Layout

      tmp = jars[B];
\end_layout

\begin_layout Plain Layout

      jars[B] = jars[A];
\end_layout

\begin_layout Plain Layout

      jars[B] = tmp;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Get if there is an empty Jar within the set.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public boolean EmptyJar() {
\end_layout

\begin_layout Plain Layout

    return ((jars[A] == 0) || (jars[B] == 0) || (jars[C] == 0));
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Move beads from one jar to another.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param source The jar to take beads from.
\end_layout

\begin_layout Plain Layout

   * @param destination The jar to add beads to.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public void moveBeads(int source, int destination) {
\end_layout

\begin_layout Plain Layout

    jars[source] -= jars[destination];
\end_layout

\begin_layout Plain Layout

    jars[destination] += jars[destination];
\end_layout

\begin_layout Plain Layout

    Sort(); // The resulting jar counts MUST be sorted.
\end_layout

\begin_layout Plain Layout

    count++; // Increment the move count.
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Monks {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Read in lines as needed.
\end_layout

\begin_layout Plain Layout

    Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

    String line = in.nextLine();
\end_layout

\begin_layout Plain Layout

    // Quit when our input is "0 0 0"
\end_layout

\begin_layout Plain Layout

    while (!line.equals("0 0 0")) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      Scanner sc = new Scanner(line);
\end_layout

\begin_layout Plain Layout

      // Output the minimum moves required.
\end_layout

\begin_layout Plain Layout

      System.out.printf("%s %d
\backslash
n", line,
\end_layout

\begin_layout Plain Layout

              LeastMoves(new Jars(sc.nextInt(), sc.nextInt(), sc.nextInt())));
\end_layout

\begin_layout Plain Layout

      line = in.nextLine(); // Get next line.
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Find the minimum number of moves required to move beads until at least
 1
\end_layout

\begin_layout Plain Layout

   * jar is empty.
 This function is a modified BFS algorithm, with each vertex
\end_layout

\begin_layout Plain Layout

   * to search next being derived from the current vertex contents.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param jars The starting jar contents.
\end_layout

\begin_layout Plain Layout

   * @return The minimum number of moves.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  static int LeastMoves(Jars jars) {
\end_layout

\begin_layout Plain Layout

    // Check for empty jar
\end_layout

\begin_layout Plain Layout

    if (jars.EmptyJar()) {
\end_layout

\begin_layout Plain Layout

      return 0; // If our start set of jars has an empty jar, then exit.
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      int leastMoves = 0; // result
\end_layout

\begin_layout Plain Layout

      LinkedList<Jars> moves = new LinkedList<Jars>(); // create queue
\end_layout

\begin_layout Plain Layout

      HashSet<Integer> visited = new HashSet<Integer>();
\end_layout

\begin_layout Plain Layout

      moves.offer(jars); // add initial jars state to queue
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      while ((!moves.isEmpty()) && (leastMoves == 0)) {
\end_layout

\begin_layout Plain Layout

        Jars current = new Jars(moves.poll()); // remove first in queue
\end_layout

\begin_layout Plain Layout

        visited.add(current.hashCode());
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        // Process the current set of Jars, first check for empty jar
\end_layout

\begin_layout Plain Layout

        if (current.EmptyJar()) {
\end_layout

\begin_layout Plain Layout

          leastMoves = current.count; // store result
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

          // Visit all neighbouring vertices (or Jars derived from the
\end_layout

\begin_layout Plain Layout

          // current Jar).
\end_layout

\begin_layout Plain Layout

          // Since all Jars are stored in numerical order (a<b<c), we
\end_layout

\begin_layout Plain Layout

          // can reduce the number of tests to perform, and this also
\end_layout

\begin_layout Plain Layout

          // ensures that any subtraction doesn't result in a negative
\end_layout

\begin_layout Plain Layout

          // bead count.
\end_layout

\begin_layout Plain Layout

          // We maintain a hash set with all visited states to ensure
\end_layout

\begin_layout Plain Layout

          // don't revisit them in future
\end_layout

\begin_layout Plain Layout

          Jars moveBtoA = new Jars(current);
\end_layout

\begin_layout Plain Layout

          moveBtoA.moveBeads(Jars.B, Jars.A);
\end_layout

\begin_layout Plain Layout

          int hash = moveBtoA.hashCode();
\end_layout

\begin_layout Plain Layout

          if (!visited.contains(hash)) {
\end_layout

\begin_layout Plain Layout

            moves.offer(moveBtoA);
\end_layout

\begin_layout Plain Layout

            visited.add(hash);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

          Jars moveCtoA = new Jars(current);
\end_layout

\begin_layout Plain Layout

          moveCtoA.moveBeads(Jars.C, Jars.A);
\end_layout

\begin_layout Plain Layout

          hash = moveCtoA.hashCode();
\end_layout

\begin_layout Plain Layout

          if (!visited.contains(hash)) {
\end_layout

\begin_layout Plain Layout

            moves.offer(moveCtoA); // add result to queue
\end_layout

\begin_layout Plain Layout

            visited.add(hash);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

          current.moveBeads(Jars.C, Jars.B);
\end_layout

\begin_layout Plain Layout

          hash = current.hashCode();
\end_layout

\begin_layout Plain Layout

          if (!visited.contains(hash)) {
\end_layout

\begin_layout Plain Layout

            moves.offer(current); // add result to queue
\end_layout

\begin_layout Plain Layout

            visited.add(hash);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      // We have found a empty jar set
\end_layout

\begin_layout Plain Layout

      return leastMoves;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Solution to Monks Problem (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Monks"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The use of the BFS algorithm highlights the breadth of the application of
 the algorithm.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Monks-Solution-Diagram"

\end_inset

 demonstrates the core method LeastMoves() of the sample solution.
 You will notice immediately that the resulting calculations that define
 new jar values form a tree (which is a type of grah), that allows us to
 the BFS to solve the problems as presented.
 The key difference, is that new vertices (or Jars) to explore are derived
 at runtime, and not part of a set graph to explore.
 This allows the solution to scale to very large graphs of possible jar
 combinations.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Monks.eps
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Monks Solution Diagram
\begin_inset CommandInset label
LatexCommand label
name "fig:Monks-Solution-Diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
At Step 1, there are no empty jars, so add the three resulting calculations
 for the new jar values to the queue.
 At Step 2, take this jar from the queue, inspect, and since there are no
 empty jars, add the three resulting calculations for the new jar values
 to the queue, if and only if the new values to be tested have not already
 been tested (and found in the 
\family typewriter
visited HashSet
\family default
).
 The process repeats for steps 3.
 Since Step 4 has an empty jar we terminate algorithm and return the current
 count value.
\end_layout

\begin_layout Standard
There are few challenging cases within the Monks problem.
 Ensuring that the jar bead counts are stored in numerical order allows
 a reduction in the number of edges to explore, as well as removing the
 requirement to ensure a subtraction from one jar does not result in a negative
 bead count within a jar.
 The main tricky case, is that when the starting bead count is such that
 there is no solution, that even after an infinite number of moves no solution
 is found.
 (The problem statement indicates that this is not an issue with the supplied
 sets to test, but the implementation still handles this).
 The implementation handles the possibility of a no-solution problem be
 ensuring that we only test jar states that have not been tested prior,
 and if run out of states to test, then there is no solution to the problem.
\end_layout

\begin_layout Standard
One of the main points within the implementation is the use of the HashSet
 to hold the visited jar states, as the 
\family typewriter
contains()
\family default
 method as implemented within 
\family typewriter
HashSet
\family default
 offers 
\series bold
O(1)
\series default
 lookup.
 If a normal 
\family typewriter
List
\family default
 was used, this would result is significantly reduced performance as the
 
\family typewriter
contains()
\family default
 method is typically 
\series bold
O(n)
\series default
 performance.
\end_layout

\begin_layout Subsubsection
Minimum Spanning Tree
\end_layout

\begin_layout Standard
Minimum spanning trees are a useful operation on a graph that allow you
 to construct a tree
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A tree is a graph, where there are no cycles
\end_layout

\end_inset

 that only includes the minimum number of egdes that also has the property
 that the sum of all edge weights is the minimum possible.
\end_layout

\begin_layout Standard
This is useful for when we wish to find the quickest or cheapest way to
 implement a network (be it Local Area Network, or Wide Area Network), when
 we wish to minimise the amount of network cabling needed to connect all
 computers in a location, etc.
\end_layout

\begin_layout Standard
For some graphs there may be multiple minimum spanning trees possible
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is true for unweighted graphs, or for graphs were most edges share
 the same weight
\end_layout

\end_inset

, which may be derived differently based on which algorithm is used to derive
 the tree.
 The two common algorithms utilised today are Kruskal's Algorithm and The
 Prim-Jarník Algorithm, whilst the original MST algorithm Barůvka's Algorithm
 is not utilised as much due to lesser performance compared to the other
 two.
\end_layout

\begin_layout Paragraph
The Prim-Jarník Algorithm
\end_layout

\begin_layout Standard
For this section I will describe and implement The Prim-Jarník Algorithm,
 as it offers good performance while remaining relatively simple to implement.
\end_layout

\begin_layout Standard
The Prim-Jarník Algorithm works by walking the graph, following the the
 edges with the least weight until all vertices have been visited.
 The full algorithm can be found in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:The-Prim-Jarník-Algorithm"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require A Graph $G$ which is a fully connected graph.
 
\end_layout

\begin_layout Plain Layout


\backslash
Ensure A tree $T$ whose properties match those of a Minimum Spanning Tree.
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{PrimJarníkMST}{$G$}
\end_layout

\begin_layout Plain Layout


\backslash
State {Pick any vertex $v$ of $G$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$D[v] 
\backslash
gets 0$} 
\backslash
Comment {$D[u]$ stores the weight of the best current edge} 
\end_layout

\begin_layout Plain Layout


\backslash
ForAll {vertex $u 
\backslash
neq v$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$D[u] 
\backslash
gets +
\backslash
infty$}
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
State {Initialise $T 
\backslash
gets 
\backslash
emptyset$}
\end_layout

\begin_layout Plain Layout


\backslash
State {Initialise Priority Queue $Q$ with an item (($u$,null, $D[u]$) for
 each vertex $u$.}
\end_layout

\begin_layout Plain Layout


\backslash
While {$Q$ is not empty}
\end_layout

\begin_layout Plain Layout


\backslash
State {$(u,e) 
\backslash
gets Q$.removeMin()}
\end_layout

\begin_layout Plain Layout


\backslash
State {Add vertex $u$ and edge $e$ to $T$.}
\end_layout

\begin_layout Plain Layout


\backslash
ForAll {vertex $z$ adjacent to $u$ such that $z$ is in $Q$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$w((u,z)) < D[z]$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$D[z] 
\backslash
gets w((u,z))$}
\end_layout

\begin_layout Plain Layout


\backslash
State {Change to $(z,(u,z))$ the element of vertex $z$ in $Q$}
\end_layout

\begin_layout Plain Layout


\backslash
State {Change to $D[z]$ the key of vertex $z$ in $Q$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{return} $T$}
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The Prim-Jarník Algorithm
\begin_inset CommandInset label
LatexCommand label
name "alg:The-Prim-Jarník-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Description of working
\end_layout

\begin_layout Standard
The algorithm essentially builds the minimum spanning tree based on the
 least weight of edges that lead to vertices that are not part of the tree.
\end_layout

\begin_layout Standard
This is achieved through the use of a priority queue, that holds the next
 least cost edge of all current vertices within the tree.
 On each iteration, it will remove the next least cost edge, add it to the
 tree, then add any new edges to the priority queue for processing.
 The algorithm terminates when all vertices are present in the tree.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-Prim-Jarník-Algorithm"

\end_inset

demonstrates the algorithm, based on the initial graph in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Basic-Graph-Example"

\end_inset

, starting at vertex D.
\end_layout

\begin_layout Standard
Starting at Vertex D, all edges that are incident are added to the priority
 queue, and the edge with the least weight is removed from the queue.
 At step (a), this is the edge (d,b).
 This edge is then added to the resulting MST, as shown in the bold line.
 This process is then repeated at Vertex B (step b), in which all edges
 are added to the queue (or if in the queue is adjusted if a new lower weight
 has been found).
 The edge with the least weight is then removed from the queue.
 This edge may be adjacent to either Vertex D or Vertex B, as the algorithm
 only cares about the minimum weight, not the current vertex.
 This process is repeated, until all vertices are within the MST T (step
 (f)).
\end_layout

\begin_layout Standard
The Prim-Jarník Algorithm depending on the implemetation will have a running
 time of 
\series bold
O(m log n)
\series default
 when an adjacency list is utilised or
\series bold
 O(n
\begin_inset script superscript

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset

)
\series default
 when an adjacency matrix is utilised.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Prim.eps
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The Prim-Jarník Algorithm
\begin_inset CommandInset label
LatexCommand label
name "fig:The-Prim-Jarník-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Implementation
\end_layout

\begin_layout Standard
An implementation of The Prim-Jarník Algorithm can be seen in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Prim-Jarník-Algorithm-(Java)"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.ArrayList;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class PrimMST {
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Construct a MST based on the Prim-Jarnik Algorithm.
 As this implementation
\end_layout

\begin_layout Plain Layout

   * is based on an Adjacency Matrix, offers O(n^2) performance.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param matrix An adjacency matrix defining a graph
\end_layout

\begin_layout Plain Layout

   * @param root The starting vertex
\end_layout

\begin_layout Plain Layout

   * @return An array with the connecting vertex ID in each element
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static int[] PrimJarnikMST(int[][] matrix, int root) {
\end_layout

\begin_layout Plain Layout

    // shortest known distance to MST, typically this may be a priority
 
\end_layout

\begin_layout Plain Layout

    // queue, but here we use an array, and linear scan the array to find
\end_layout

\begin_layout Plain Layout

    // the lowest value.
\end_layout

\begin_layout Plain Layout

    int[] distance = new int[matrix.length];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // preceeding vertex in tree
\end_layout

\begin_layout Plain Layout

    int[] pred = new int[matrix.length];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    boolean[] visited = new boolean[matrix.length]; // all false initially
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Set all distances to inf, except root vertex, which we set to 0,
\end_layout

\begin_layout Plain Layout

    // so that the main loop starts at this vertex.
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < distance.length; i++) {
\end_layout

\begin_layout Plain Layout

      distance[i] = Integer.MAX_VALUE;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    distance[root] = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Main loop, which terminates when all vertices have been visited.
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < distance.length; i++) {
\end_layout

\begin_layout Plain Layout

      int next = minVertex(distance, visited); // Get next lowest cost edge
\end_layout

\begin_layout Plain Layout

      visited[next] = true;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // The edge from pred[next] to next is in the MST (if next != root)
\end_layout

\begin_layout Plain Layout

      int[] neighbours = getNeighbours(matrix,next);
\end_layout

\begin_layout Plain Layout

      for (int j = 0; j < neighbours.length; j++) {
\end_layout

\begin_layout Plain Layout

        int vertex = neighbours[j];
\end_layout

\begin_layout Plain Layout

        int weight = matrix[next][vertex];
\end_layout

\begin_layout Plain Layout

        if (distance[vertex] > weight || distance[vertex] == 0) {
\end_layout

\begin_layout Plain Layout

          distance[vertex] = weight; // Update best weight
\end_layout

\begin_layout Plain Layout

          pred[vertex] = next; // Set best vertex to reach this vertex
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return pred;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Find the minimum distance in the current best distance vector
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param dist The vector of current minimum distance.
\end_layout

\begin_layout Plain Layout

   * @param v An array of vertices that have been visited.
\end_layout

\begin_layout Plain Layout

   * @return The shortest known distance to an unvisited vertex.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  private static int minVertex(int[] distance, boolean[] visited) {
\end_layout

\begin_layout Plain Layout

    int weight = Integer.MAX_VALUE;
\end_layout

\begin_layout Plain Layout

    int vertex = -1;   // graph not connected, or no unvisited vertices
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < distance.length; i++) {
\end_layout

\begin_layout Plain Layout

      if (!visited[i] && distance[i] < weight) {
\end_layout

\begin_layout Plain Layout

        vertex = i; // set lowest weight vertex.
\end_layout

\begin_layout Plain Layout

        weight = distance[i]; // get the weight, for later comparison
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return vertex;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  private static int[] getNeighbours(int[][] matrix, int row){
\end_layout

\begin_layout Plain Layout

    ArrayList<Integer> neighbours = new ArrayList<Integer>();
\end_layout

\begin_layout Plain Layout

    for(int i = 0; i < matrix.length; i++){
\end_layout

\begin_layout Plain Layout

      if(matrix[row][i] > 0){
\end_layout

\begin_layout Plain Layout

        neighbours.add(i);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    int[] temp = new int[neighbours.size()];
\end_layout

\begin_layout Plain Layout

    int i = 0;
\end_layout

\begin_layout Plain Layout

    for(Integer vertex: neighbours){
\end_layout

\begin_layout Plain Layout

      temp[i++] = vertex;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return temp;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Prim-Jarník Algorithm (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Prim-Jarník-Algorithm-(Java)"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Sample Problem - Minimum Spanning Tree
\begin_inset CommandInset label
LatexCommand label
name "par:Minimum Spanning Tree Problem"

\end_inset


\end_layout

\begin_layout Standard
Construct the minimum spanning tree for a weighted undirected graph.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
The first line of input will be a number on a line by itself which is the
 number of test cases to run.
 For each test case, the first line will be two numbers separated by a space
 
\shape italic
N
\shape default
 and 
\shape italic
E
\shape default
, where
\shape italic
 N
\shape default
 (
\shape italic
1
\shape default
 <= 
\shape italic
N
\shape default
 <= 5000) is the number of nodes in the graph and 
\shape italic
E
\shape default
 (1 <= 
\shape italic
E
\shape default
 <= 10000) is the number of edges.
 The graph nodes will be numbered 0 to 
\shape italic
N
\shape default
-1.
 Each of the next 
\shape italic
E
\shape default
 lines contain three numbers 
\shape italic
S, D
\shape default
 and 
\shape italic
W
\shape default
 each separated by a space representing an edge in the graph from 
\shape italic
S
\shape default
 (0 <= 
\shape italic
S
\shape default
 < 
\shape italic
N
\shape default
) to 
\shape italic
D
\shape default
 (0 <= 
\shape italic
D
\shape default
 < 
\shape italic
N
\shape default
) with weight 
\shape italic
W
\shape default
 (0 < 
\shape italic
W
\shape default
 <= 
\shape italic
1000
\shape default
).
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
2 
\begin_inset Newline newline
\end_inset

5 7 
\begin_inset Newline newline
\end_inset

0 1 10
\begin_inset Newline newline
\end_inset

1 3 2 
\begin_inset Newline newline
\end_inset

1 4 6 
\begin_inset Newline newline
\end_inset

3 4 3 
\begin_inset Newline newline
\end_inset

2 4 6 
\begin_inset Newline newline
\end_inset

0 4 20 
\begin_inset Newline newline
\end_inset

0 2 30 
\begin_inset Newline newline
\end_inset

5 6 
\begin_inset Newline newline
\end_inset

0 1 8 
\begin_inset Newline newline
\end_inset

0 3 2 
\begin_inset Newline newline
\end_inset

0 4 5 
\begin_inset Newline newline
\end_inset

1 2 6 
\begin_inset Newline newline
\end_inset

2 3 4 
\begin_inset Newline newline
\end_inset

3 4 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
For each test case, output the following message on a new line: 
\end_layout

\begin_layout Standard

\family typewriter
Test x, minimum spanning tree weight = y 
\end_layout

\begin_layout Standard
where 
\family typewriter
x
\family default
 is the test case number and y is the total weight of the edges of the minimum
 spanning tree.
 See the example output below.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
Test 1, minimum spanning tree weight = 21 
\begin_inset Newline newline
\end_inset

Test 2, minimum spanning tree weight = 15
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Sample Solution
\end_layout

\begin_layout Standard
A sample solution to the Minimum Spanning Tree problem can be found in Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Minimum"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.ArrayList;
\end_layout

\begin_layout Plain Layout

import java.util.Comparator;
\end_layout

\begin_layout Plain Layout

import java.util.PriorityQueue;
\end_layout

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class SpanningTreeProblem {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  static int vertexCount;
\end_layout

\begin_layout Plain Layout

  static int edgeCount;
\end_layout

\begin_layout Plain Layout

  static PriorityQueue<edge> edges;
\end_layout

\begin_layout Plain Layout

  static ArrayList<ArrayList<edge>> adjacencyList;
\end_layout

\begin_layout Plain Layout

  static Boolean[] visited;
\end_layout

\begin_layout Plain Layout

  private final static String OUTPUT_STRING = "Test %d, minimum spanning
 tree weight = %d
\backslash
n";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    new SpanningTreeProblem().run();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Run interface to be called from main().
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public void run() {
\end_layout

\begin_layout Plain Layout

    Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

    int caseCount = Integer.parseInt(in.nextLine());
\end_layout

\begin_layout Plain Layout

    int loopCount = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Keep looping while we have cases to test.
\end_layout

\begin_layout Plain Layout

    while (caseCount - loopCount > 0) {
\end_layout

\begin_layout Plain Layout

      int minimumWeight = 0;
\end_layout

\begin_layout Plain Layout

      vertexCount = in.nextInt();
\end_layout

\begin_layout Plain Layout

      edgeCount = in.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Construct visited map and adjacency list.
\end_layout

\begin_layout Plain Layout

      visited = new Boolean[vertexCount];
\end_layout

\begin_layout Plain Layout

      adjacencyList = new ArrayList<ArrayList<edge>>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Create priority queue.
\end_layout

\begin_layout Plain Layout

      edge comp = new edge( 0, 0);
\end_layout

\begin_layout Plain Layout

			edges = new PriorityQueue<edge>(edgeCount, comp);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Set all vertices to not visited and ensure Adjacency list has items.
\end_layout

\begin_layout Plain Layout

      for (int n = 0; n < vertexCount; n++) {
\end_layout

\begin_layout Plain Layout

        visited[n] = false;
\end_layout

\begin_layout Plain Layout

        adjacencyList.add(new ArrayList<edge>());
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Read all edges into the adjacency list.
\end_layout

\begin_layout Plain Layout

      while (edgeCount-- > 0) {
\end_layout

\begin_layout Plain Layout

        int source = in.nextInt();
\end_layout

\begin_layout Plain Layout

        int dest = in.nextInt();
\end_layout

\begin_layout Plain Layout

        int weight = in.nextInt();
\end_layout

\begin_layout Plain Layout

        adjacencyList.get(source).add(new edge(dest, weight));
\end_layout

\begin_layout Plain Layout

        adjacencyList.get(dest).add(new edge(source, weight));
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Set our source vertex to be visited.
\end_layout

\begin_layout Plain Layout

      visited[0] = true;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Add all vertex 0 edges to the priority queue
\end_layout

\begin_layout Plain Layout

      addEdges(0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // While not visited all vertices, continue to loop
\end_layout

\begin_layout Plain Layout

      while (!edges.isEmpty()) {
\end_layout

\begin_layout Plain Layout

        edge e = edges.poll();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // if vertex is not yet connected
\end_layout

\begin_layout Plain Layout

        if (visited[e.vertex] == false) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

          // take edge and process all edges incident to this edge
\end_layout

\begin_layout Plain Layout

          // each edge is in priority queue only once
\end_layout

\begin_layout Plain Layout

          minimumWeight += e.weight;
\end_layout

\begin_layout Plain Layout

          addEdges(e.vertex);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      System.out.printf(OUTPUT_STRING, ++loopCount, minimumWeight);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Add edges of vertex to the priority queue, whose edge has not been
 visited.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param vertex
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public void addEdges(int vertex) {
\end_layout

\begin_layout Plain Layout

    visited[vertex] = true;
\end_layout

\begin_layout Plain Layout

    for (edge e : adjacencyList.get(vertex)) {
\end_layout

\begin_layout Plain Layout

      // Add in edge, if neighbour has NOT been visited, to avoid cycles.
\end_layout

\begin_layout Plain Layout

      if (visited[e.vertex] == false) {
\end_layout

\begin_layout Plain Layout

        edges.add(e);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Edge container class.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class edge implements Comparator<edge> {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * destination vertex and weight.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public int vertex, weight;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Constructor
\end_layout

\begin_layout Plain Layout

     * @param v The destination vertex
\end_layout

\begin_layout Plain Layout

     * @param w The weight of the edge.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public edge(int v, int w) {
\end_layout

\begin_layout Plain Layout

      vertex = v;
\end_layout

\begin_layout Plain Layout

      weight = w;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Compare function for priority queue.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    @Override
\end_layout

\begin_layout Plain Layout

    public int compare(edge e1, edge e2) {
\end_layout

\begin_layout Plain Layout

      if (e1.weight < e2.weight) {
\end_layout

\begin_layout Plain Layout

        return -1;
\end_layout

\begin_layout Plain Layout

      } else if (e1.weight > e2.weight) {
\end_layout

\begin_layout Plain Layout

        return 1;
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        return 0;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Solution to Minimum Spanning Tree Problem (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Minimum"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The solution to the Minimum Spanning Tree problem is implemented slightly
 different to the algorithm implementation shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Prim-Jarník-Algorithm-(Java)"

\end_inset

, in that the problem solution utilises an adjacency list to represent the
 graph rather than an adjacency matrix.
 This suits the problem well, as we are interested in the sum of the tree
 and not the tree itself.
\end_layout

\begin_layout Standard
The implementation, utilises a priority queue
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The priority queue is primed with edges incident to vertex 0.
\end_layout

\end_inset

 of edges that are located incident to the edges that have been explored,
 and removes the head of the queue.
 If this edge has not been visited, we add it's weight to the sum of the
 tree, and note that we have visited the vertex.
 We then add all edges incident to the vertex just visited to the priority
 queue.
 We continue looping until the priority queue has been exhausted (which
 indicates that we have visited all vertices in the graph that are reachable
 from vertex 0).
\end_layout

\begin_layout Standard
The few edge cases to consider would be very dense graphs, very sparse graphs,
 or graphs that contain zero edges.
 An graph with all edges having the same weight, whilst will derive a different
 minimum spanning tree, is not a problem with the solution implementation,
 due to it’s use of the priority queue.
 Another item to consider is how to handle cycles within the graph representatio
n, that is a new edge, that has both source and destination vertex already
 in the resulting tree.
 (These should simply be discarded, and are within the implementation).
\end_layout

\begin_layout Paragraph
Kruskal's with Union Find Algorithm 
\end_layout

\begin_layout Standard
Kruskal's Minimum Spanning Tree Algorithm works in a very similar manner
 to that described of The Prim-Jarník Algorithm, with one exception, that
 egdes are added to the tree in order of lowest cost irrespective of the
 edge they incident with, unless addition of the edge results in a cycle
 forming.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require A Graph $G$ which is a fully connected graph.
 
\end_layout

\begin_layout Plain Layout


\backslash
Ensure A tree $T$ whose properties match those of a Minimum Spanning Tree.
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{KruskalsMST}{$G$}
\end_layout

\begin_layout Plain Layout


\backslash
ForAll {vertex $v$ in $G$}
\end_layout

\begin_layout Plain Layout


\backslash
State {Define an elementary cluster $C(v) 
\backslash
gets {v}$}
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
State {Initialise priority queue $Q$ to contains all edges in $G$, using
 weights as keys.}
\end_layout

\begin_layout Plain Layout


\backslash
State {$T 
\backslash
gets 
\backslash
emptyset$}
\end_layout

\begin_layout Plain Layout


\backslash
While {$T$ has fewer than $n-1$ egdes}
\end_layout

\begin_layout Plain Layout


\backslash
State {$(v,u) 
\backslash
gets Q.
\backslash
textsf{removeMin()}$}
\end_layout

\begin_layout Plain Layout


\backslash
State {Let $C(v)$ be the cluster containing $v$, and let $C(u)$ be the cluster
 containing $u$.}
\end_layout

\begin_layout Plain Layout


\backslash
If {$C(v) 
\backslash
neq C(u)$}
\end_layout

\begin_layout Plain Layout


\backslash
State {Add edge $(v,u)$ to $T$}
\end_layout

\begin_layout Plain Layout


\backslash
State {Merge $C(v)$ and $C(u)$ into one cluster.
 ($C(v) 
\backslash
cup C(u)$)}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{return} $T$}
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Kruskal's Algorithm
\begin_inset CommandInset label
LatexCommand label
name "alg:Kruskal's-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Description of working
\end_layout

\begin_layout Standard
The algorithm like Prim's essentially builds the minimum spanning tree based
 on the least weight of edges that lead to vertices that are not part of
 the tree.
\end_layout

\begin_layout Standard
This is achieved through the use of a single priority queue, that holds
 all edges of the graph, with the least weighted egdes being at the start/head
 of the queue.
 On each iteration, it will remove the next least cost edge, add it to the
 tree, if and only if the addition of the edge does not result in a cycle
 within the tree.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Kruskal's-Algorithm"

\end_inset

 demonstrates the algorithm, based on the initial graph in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Basic-Graph-Example"

\end_inset

.
\end_layout

\begin_layout Standard
Based on the weights, of edges within the graph depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Kruskal's-Algorithm"

\end_inset

(a), will be stored in the priority queue in the following order: {(f,g),
 (b,e), (b,d), (d,e), (a,b), (b,c), (e,g), (c,e), (d,f), (a,d), (e,f)}.
 In (a), the first edge is automatically added to the Tree (as there are
 no other edges currently in the tree).
 (b), (c) add additional edges to form a second sub-tree.
 In (d), the next edge in the priority queue is (d,e), however this is not
 added as it would create a cycle within the tree.
 The rest of the edges are added into the tree, until the number of edges
 in the resulting Tree is equal to the number of vertices - 1.
\end_layout

\begin_layout Standard
One of the key aspects of the algorithm is the method used to determining
 if 
\begin_inset Formula $C(v)\neq C(u)$
\end_inset

 is true or false as well as performing the merge operation between the
 two clusters (or sub-trees).
 To achieve this we utilise a union find data structure, that offers high
 performance in both checking if 
\begin_inset Formula $C(v)\neq C(u)$
\end_inset

 and also performing the merge operation.
\end_layout

\begin_layout Standard
Kruskal's Algorithm will typically have a performance complexity of 
\series bold
O(m log n)
\series default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Kruskals.eps
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Kruskal's Algorithm
\begin_inset CommandInset label
LatexCommand label
name "fig:Kruskal's-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Implementation
\end_layout

\begin_layout Standard
An implementation of Kruskal's Algorithm can be seen in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Kruskal's-Algorithm-(Java)"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.ArrayList;
\end_layout

\begin_layout Plain Layout

import java.util.Comparator;
\end_layout

\begin_layout Plain Layout

import java.util.PriorityQueue;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Kruskals {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Find Minimum Spanning Tree using Kruskal's Algorithm
\end_layout

\begin_layout Plain Layout

   * @param edges Priority queue of all edges available within the graph
\end_layout

\begin_layout Plain Layout

   * @param vertexCount The number of vertices in the graph.
\end_layout

\begin_layout Plain Layout

   * @return Edges that make up the minimum spanning tree.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public ArrayList<edge> Kruskals(PriorityQueue<edge> edges, int vertexCount)
 {
\end_layout

\begin_layout Plain Layout

    int minimumWeight = 0;
\end_layout

\begin_layout Plain Layout

    ArrayList<edge> tree = new ArrayList<edge>();
\end_layout

\begin_layout Plain Layout

    // Build connectivity map for Union-Find operation.
\end_layout

\begin_layout Plain Layout

    unode[] vertexMap = new unode[vertexCount];
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < vertexCount; i++) {
\end_layout

\begin_layout Plain Layout

      // Set all vertices to be in their own trees.
\end_layout

\begin_layout Plain Layout

      vertexMap[i] = new unode(null, 0);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Begin Kruskal's Algorithm with Union-Find
\end_layout

\begin_layout Plain Layout

    while (!edges.isEmpty()) {
\end_layout

\begin_layout Plain Layout

      edge currentEdge = edges.poll();
\end_layout

\begin_layout Plain Layout

      unode p = find(vertexMap[currentEdge.source]); // Get parent of tree
 that source is in
\end_layout

\begin_layout Plain Layout

      unode q = find(vertexMap[currentEdge.destination]); // Get parent of
 tree that dest is in.
\end_layout

\begin_layout Plain Layout

      if (q != p) {
\end_layout

\begin_layout Plain Layout

        // If different parents, add the edge in.
\end_layout

\begin_layout Plain Layout

        tree.add(currentEdge);
\end_layout

\begin_layout Plain Layout

        minimumWeight += currentEdge.weight;
\end_layout

\begin_layout Plain Layout

        union(p, q); // Join the two, ensuring minimum depth.
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return tree;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Edge container class.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class edge implements Comparator<edge> {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * destination vertex and weight.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public int source, destination, weight;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Constructor
\end_layout

\begin_layout Plain Layout

     *
\end_layout

\begin_layout Plain Layout

     * @param v The destination vertex
\end_layout

\begin_layout Plain Layout

     * @param w The weight of the edge.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public edge(int source, int destination, int weight) {
\end_layout

\begin_layout Plain Layout

      this.source = source;
\end_layout

\begin_layout Plain Layout

      this.destination = destination;
\end_layout

\begin_layout Plain Layout

      this.weight = weight;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Compare function for priority queue.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    @Override
\end_layout

\begin_layout Plain Layout

    public int compare(edge e1, edge e2) {
\end_layout

\begin_layout Plain Layout

      if (e1.weight < e2.weight) {
\end_layout

\begin_layout Plain Layout

        return -1;
\end_layout

\begin_layout Plain Layout

      } else if (e1.weight > e2.weight) {
\end_layout

\begin_layout Plain Layout

        return 1;
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        return 0;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Parent container class for Union-Find data structure.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class unode {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public unode parent;
\end_layout

\begin_layout Plain Layout

    public int depth;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public unode(unode parent, int depth) {
\end_layout

\begin_layout Plain Layout

      this.parent = parent;
\end_layout

\begin_layout Plain Layout

      this.depth = depth;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * FIND method.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public unode find(unode current) {
\end_layout

\begin_layout Plain Layout

    if (current.parent == null) {
\end_layout

\begin_layout Plain Layout

      return current;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return (current.parent = find(current.parent));
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * UNION method.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public void union(unode p, unode q) {
\end_layout

\begin_layout Plain Layout

    if (p.depth > q.depth) {
\end_layout

\begin_layout Plain Layout

      q.parent = p;
\end_layout

\begin_layout Plain Layout

    } else if (p.depth < q.depth) {
\end_layout

\begin_layout Plain Layout

      p.parent = q;
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      p.parent = q;
\end_layout

\begin_layout Plain Layout

      p.depth += 1;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Kruskal's Algorithm (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Kruskal's-Algorithm-(Java)"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Sample Problem- Minimum Spanning Tree
\end_layout

\begin_layout Standard
For this sample problem I will reuse the same problem from Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Minimum Spanning Tree Problem"

\end_inset

.
\end_layout

\begin_layout Subparagraph
Sample Solution
\end_layout

\begin_layout Standard
A sample solution to the Minimum Spanning Tree problem can be found in Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Minimum-Kruskals"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.ArrayList;
\end_layout

\begin_layout Plain Layout

import java.util.Comparator;
\end_layout

\begin_layout Plain Layout

import java.util.PriorityQueue;
\end_layout

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class KruskalsMinimumSpanningTree {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  int vertexCount;
\end_layout

\begin_layout Plain Layout

  int edgeCount;
\end_layout

\begin_layout Plain Layout

  PriorityQueue<edge> edges;
\end_layout

\begin_layout Plain Layout

  ArrayList<edge> tree;
\end_layout

\begin_layout Plain Layout

  private final static String OUTPUT_STRING = "Test %d, minimum spanning
 tree weight = %d
\backslash
n";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    new KruskalsMinimumSpanningTree().run();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Run interface to be called from main().
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public void run() {
\end_layout

\begin_layout Plain Layout

    Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

    int caseCount = Integer.parseInt(in.nextLine());
\end_layout

\begin_layout Plain Layout

    int loopCount = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Keep looping while we have cases to test.
\end_layout

\begin_layout Plain Layout

    while (caseCount - loopCount > 0) {
\end_layout

\begin_layout Plain Layout

      int minimumWeight = 0;
\end_layout

\begin_layout Plain Layout

      vertexCount = in.nextInt();
\end_layout

\begin_layout Plain Layout

      edgeCount = in.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Create priority queue and MST.
\end_layout

\begin_layout Plain Layout

      edge comp = new edge(0, 0, 0);
\end_layout

\begin_layout Plain Layout

      edges = new PriorityQueue<edge>(edgeCount, comp);
\end_layout

\begin_layout Plain Layout

      tree = new ArrayList<edge>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Read all edges into the adjacency list.
\end_layout

\begin_layout Plain Layout

      for (int i = 0; i < edgeCount; i++) {
\end_layout

\begin_layout Plain Layout

        edges.add(new edge(in.nextInt(), in.nextInt(), in.nextInt()));
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Build connectivity map for Union-Find operation.
\end_layout

\begin_layout Plain Layout

      unode[] vertexMap = new unode[vertexCount];
\end_layout

\begin_layout Plain Layout

      for(int i = 0; i < vertexCount; i++){
\end_layout

\begin_layout Plain Layout

        // Set all vertices to be in their own trees.
\end_layout

\begin_layout Plain Layout

        vertexMap[i] = new unode(null, 0);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      // Begin Kruskal's Algorithm with Union-Find
\end_layout

\begin_layout Plain Layout

      while (!edges.isEmpty()) {
\end_layout

\begin_layout Plain Layout

        edge currentEdge = edges.poll();
\end_layout

\begin_layout Plain Layout

        unode p = find(vertexMap[currentEdge.source]); // Get parent of tree
 that source is in
\end_layout

\begin_layout Plain Layout

        unode q = find(vertexMap[currentEdge.destination]); // Get parent
 of tree that dest is in.
\end_layout

\begin_layout Plain Layout

        if(q != p){
\end_layout

\begin_layout Plain Layout

          // If different parents, add the edge in.
\end_layout

\begin_layout Plain Layout

          tree.add(currentEdge);
\end_layout

\begin_layout Plain Layout

          minimumWeight += currentEdge.weight;
\end_layout

\begin_layout Plain Layout

          union(p,q); // Join the two, ensuring minimum depth.
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      System.out.printf(OUTPUT_STRING, ++loopCount, minimumWeight);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Edge container class.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class edge implements Comparator<edge> {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * destination vertex and weight.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public int source, destination, weight;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Constructor
\end_layout

\begin_layout Plain Layout

     *
\end_layout

\begin_layout Plain Layout

     * @param v The destination vertex
\end_layout

\begin_layout Plain Layout

     * @param w The weight of the edge.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public edge(int source, int destination, int weight) {
\end_layout

\begin_layout Plain Layout

      this.source = source;
\end_layout

\begin_layout Plain Layout

      this.destination = destination;
\end_layout

\begin_layout Plain Layout

      this.weight = weight;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Compare function for priority queue.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    @Override
\end_layout

\begin_layout Plain Layout

    public int compare(edge e1, edge e2) {
\end_layout

\begin_layout Plain Layout

      if (e1.weight < e2.weight) {
\end_layout

\begin_layout Plain Layout

        return -1;
\end_layout

\begin_layout Plain Layout

      } else if (e1.weight > e2.weight) {
\end_layout

\begin_layout Plain Layout

        return 1;
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        return 0;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Parent container class for Union-Find data structure.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class unode {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public unode parent;
\end_layout

\begin_layout Plain Layout

    public int depth;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public unode(unode parent, int depth) {
\end_layout

\begin_layout Plain Layout

      this.parent = parent;
\end_layout

\begin_layout Plain Layout

      this.depth = depth;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * FIND method.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public unode find(unode current) {
\end_layout

\begin_layout Plain Layout

    if (current.parent == null) {
\end_layout

\begin_layout Plain Layout

      return current;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return (current.parent = find(current.parent));
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * UNION method.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public void union(unode p, unode q) {
\end_layout

\begin_layout Plain Layout

    if (p.depth > q.depth) {
\end_layout

\begin_layout Plain Layout

      q.parent = p;
\end_layout

\begin_layout Plain Layout

    } else if (p.depth < q.depth) {
\end_layout

\begin_layout Plain Layout

      p.parent = q;
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      p.parent = q;
\end_layout

\begin_layout Plain Layout

      p.depth += 1;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Solution to Minimum Spanning Tree Problem (Kruskal's) (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Minimum-Kruskals"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
One of the key aspects of the implementation is the method utilised in determini
ng if 
\begin_inset Formula $C(v)\neq C(u)$
\end_inset

 is true or false as well as performing the merge operation between the
 two clusters (or sub-trees).
 To achieve this we utilise a union find data structure, that offers high
 performance in both checking if 
\begin_inset Formula $C(v)\neq C(u)$
\end_inset

 and also performing the merge operation.
 The Union Find Data structure is very simple, in that an array of vertices
 in maintained whose data contains the root of the subtree in which it exists,
 as well as the depth of the tree in which it exists.
 To determine if two vertices are in the same subtree, we simply compare
 their root vertex, and if the same, both vertices are in the same subtree,
 otherwise they are not and should be merged.
 (Both of these are
\series bold
 O(1)
\series default
 operations, except when path compression is needed).
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Kruskal's-with-Union"

\end_inset

 illustrates how the Union Find datastructure works, utilising the graph
 shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Kruskal's-Algorithm"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/UnionFind.eps
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Kruskal's with Union Find
\begin_inset CommandInset label
LatexCommand label
name "fig:Kruskal's-with-Union"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
At the start of the main loop, all vertices are placed into their own sub-trees
 (parent is null, that is they are the root of the tree).
 (a)
\end_layout

\begin_layout Enumerate
On the first iteration, we determine if the two vertices share the same
 parent, and in this case they do not.
 We simply merge both trees into 1 tree.
 (b)
\end_layout

\begin_layout Enumerate
With iterations (c) through (g), we perform the same action as above, except
 in step (e) where both B and E share a common root vertex within the sub-tree.
 Also, note that path compression doesn't occur in (e) as vertex B is not
 processed in the 
\family typewriter
find()
\family default
 method.
\end_layout

\begin_layout Enumerate
On the last iteration, however we have to merge two subtrees, which results
 in the figure shown in (h).
 However the path compression within the method 
\family typewriter
find()
\family default
, modifies the respective parent pointers so that the resultant graphs looks
 like that shown in (i).
 This flatterning of the Union Find data structure ensures minimum time
 is needed within the operation to determine is two sub-trees share the
 same parent.
 If another find option occurs involving vertex B, then vertex B will have
 it's parent changed to vertex C as well.
\end_layout

\begin_layout Standard
As can be seen in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Kruskal's-with-Union"

\end_inset

, the depth of the Union Find data structure is minimised due to the path
 compression, so that future searches for a vertices root vertex within
 it's sub-tree is very quick.
\end_layout

\begin_layout Standard
The few edge cases to consider would be very dense graphs, very sparse graphs,
 or graphs that contain zero edges.
 An graph with all edges having the same weight, whilst will derive a different
 minimum spanning tree, is not a problem with the solution implementation,
 due to it’s use of the priority queue.
 Another item to consider is how to handle cycles within the graph representatio
n, that is a new edge, that has both source and destination vertex already
 in the resulting tree.
 (These should simply be discarded, and are within the implementation).
 
\end_layout

\begin_layout Subsubsection
Single Source Shortest Path
\end_layout

\begin_layout Standard
As seen previously, the Breadth-First Search is capable of finding the shortest
 path within an unweighted graph, however in the real world edges within
 a graph almost always have a weight associated.
 For weighted graphs (being either directed or undirected) we require a
 different algorithm.
 The most popular single source shortest path algorithm was developed by
 Edsger Dijkstra, and is commonly known as Dijkstra's Algorithm.
\end_layout

\begin_layout Standard
Dijsktra's algorithm is commonly used with network routing protocols, specifical
ly Open Shortest Path First and IS-IS.
 It also has many other applications including path-finding in Artificial
 Intelligence (as utilised in computer games) or Robotics.
 One advantage of Dijkstra's algorithm, is that it will also calculate the
 shortest path from a source vertex to all other vertices within the operation
 of the algorithm.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require A simple undirected Graph $G$ with non-negative edge weights, and
 a source vertex $v$ to calculate path from.
 
\end_layout

\begin_layout Plain Layout


\backslash
Ensure A label $D[u]$, for each vertex $u$ of $G$, such that $D[u]$ is the
 distance from $v$ to $u$ in $G$.
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{DijkstrasShortestPaths}{$G, v$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$D[v] 
\backslash
gets 0$}
\end_layout

\begin_layout Plain Layout


\backslash
ForAll {vertex $u 
\backslash
neq v$ in $G$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$D[u] 
\backslash
gets +
\backslash
infty$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$P[u] 
\backslash
gets $undefined} 
\backslash
Comment {Vector $P$ to hold previous vertex}
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
State {Let a priority queue $Q$ contain all vertices of $G$ using the $D$
 labels as keys.}
\end_layout

\begin_layout Plain Layout


\backslash
While{$Q$ is not empty}
\end_layout

\begin_layout Plain Layout


\backslash
State {$u 
\backslash
gets Q.
\backslash
textsf{removeMin()}$}
\end_layout

\begin_layout Plain Layout


\backslash
ForAll {vertex $z$ adjacent to $u$ such that $z$ is in $Q$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$D[u] + w((u,z)) < D[z]$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$D[z] 
\backslash
gets D[u]+w((u,z))$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$P[z] 
\backslash
gets u$}
\end_layout

\begin_layout Plain Layout


\backslash
State {Change to $D[z]$ the key of vertex $z$ in $Q$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{return} $D$}
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Dijkstra's Algorithm
\begin_inset CommandInset label
LatexCommand label
name "alg:Dijkstra's-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
The algorithm applies a greedy method in that starting at vertex 
\begin_inset Formula $v$
\end_inset

 in graph 
\begin_inset Formula $G$
\end_inset

, we simple find the shortest path to the next vertex which has not been
 visited previously.
 Using this new information, we update all distances to vertices via this
 new vertex using a relaxation procedure, in that it takes the old distance
 estimate and checks if it can be improved to get closer to its real distance.
 This is performed by the following section of the algorithm:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
If {$D[u] + w((u,z)) < D[z]$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$D[z] 
\backslash
gets D[u]+w((u,z))$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that if the newly discovered path to 
\begin_inset Formula $z$
\end_inset

 is no better than the old way, then we do not change 
\begin_inset Formula $D[z]$
\end_inset

.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Dijsktra's-Algorithm"

\end_inset

 illustrates how Dijkstra's Algorithm works utilising the graph in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Basic-Graph-Example"

\end_inset

, starting at vertex A.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\size small
Utilising Adjacency Matrix as starting point as shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Adjacency-Matrix"

\end_inset

 for graph displayed in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Basic-Graph-Example"

\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Plain Layout

\size small
Step 1.
\end_layout

\begin_layout Plain Layout

\size small
Initially, 
\begin_inset Formula $D$
\end_inset

 contains the Adjacency Matrix Values from Vertex A.
\end_layout

\begin_layout Plain Layout
\noindent
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
G
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
z
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Visited
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[0]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[1]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[2]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[3]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[4]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[5]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[6]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
{A}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout

\size small
Step 2.
\end_layout

\begin_layout Plain Layout

\size small
Select the smallest weighted edge from 
\begin_inset Formula $D$
\end_inset

, not in Visited, (in this case B), and now update the shortest path weight.
 Note, the weight from A to D, has been updated.
\end_layout

\begin_layout Plain Layout
\noindent
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
G
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
z
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Visited
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[0]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[1]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[2]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[3]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[4]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[5]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[6]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
{A,B}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout

\size small
Step 3.
\end_layout

\begin_layout Plain Layout

\size small
Select the smallest weighted edge from 
\begin_inset Formula $D$
\end_inset

, not in Visited, (in this case E), and now update the shortest path weight.
 
\end_layout

\begin_layout Plain Layout
\noindent
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
G
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
z
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Visited
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[0]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[1]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[2]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[3]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[4]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[5]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[6]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
{A,B,E}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
13
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout

\size small
Step 4.
\end_layout

\begin_layout Plain Layout

\size small
Select the smallest weighted edgefrom 
\begin_inset Formula $D$
\end_inset

, not in Visited, (in this case D), and now update the shortest path weight.
 Note, the weight from A to F has been updated, as path {A, B, D, F} = 16
 is shorter than {A, B, E, F} = 19.
 
\end_layout

\begin_layout Plain Layout
\noindent
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
G
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
z
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Visited
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[0]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[1]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[2]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[3]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[4]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[5]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[6]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
{A,B,D,E}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
13
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout

\size small
Step 5.
\end_layout

\begin_layout Plain Layout

\size small
Select the smallest weighted edge from 
\begin_inset Formula $D$
\end_inset

, not in Visited, (in this case C), and now update the shortest path weight.
 No weights are updated.
\end_layout

\begin_layout Plain Layout
\noindent
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
G
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
z
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Visited
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[0]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[1]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[2]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[3]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[4]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[5]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[6]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
{A,B,C,D,E}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
13
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout

\size small
Step 6.
\end_layout

\begin_layout Plain Layout

\size small
Select the smallest weighted edge from 
\begin_inset Formula $D$
\end_inset

, not in Visited, (in this case G), and now update the shortest path weight.
 Note, the weight from A to F has been updated.
\end_layout

\begin_layout Plain Layout
\noindent
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
G
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
z
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Visited
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[0]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[1]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[2]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[3]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[4]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[5]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[6]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
{A,B,C,D,E,G}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
13
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout

\size small
Step 7.
\end_layout

\begin_layout Plain Layout

\size small
Select the smallest weighted edge from 
\begin_inset Formula $D$
\end_inset

, not in Visited, (in this case F), and now update the shortest path weight.
\end_layout

\begin_layout Plain Layout
\noindent
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
G
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
z
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Visited
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[0]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[1]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[2]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[3]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[4]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[5]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
D[6]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
{A,B,C,D,E,F,G}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
13
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout

\size small
Step 8.
 
\end_layout

\begin_layout Plain Layout

\size small
Since all vertices have been visited, we exit the algorithm.
 
\begin_inset Formula $D$
\end_inset

 now contains the shortest weight/cost from vertex A to all other vertices.
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Dijsktra's Algorithm
\begin_inset CommandInset label
LatexCommand label
name "fig:Dijsktra's-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As shown, Dijkstra's Algorithm gives you the weight of the shortest path
 to each other vertice, not the actual path itself.
 To find the actual path, Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Dijkstra's-Algorithm-1"

\end_inset

 is needed.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require Vector $P$ of previously visited vertices (constructed in Dijkstra's
 Algorithm), source vertex $v$ and target vertex $t$ 
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Vector $Path$ with path from $v$ to $u$
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{DijkstrasShortestPath}{$P, v, t$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$Path 
\backslash
gets 
\backslash
emptyset$} 
\backslash
Comment{stack datatype}
\end_layout

\begin_layout Plain Layout


\backslash
State {$u 
\backslash
gets t$}
\end_layout

\begin_layout Plain Layout


\backslash
While {$P[u] 
\backslash
neq $ undefined}
\end_layout

\begin_layout Plain Layout


\backslash
State {$Path .
\backslash
textsf{push()} 
\backslash
gets u$} 
\backslash
Comment{push $u$ onto stack}
\end_layout

\begin_layout Plain Layout


\backslash
State {$u 
\backslash
gets P[u]$}
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{return} $Path$}
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Dijkstra's Algorithm (Find Path)
\begin_inset CommandInset label
LatexCommand label
name "alg:Dijkstra's-Algorithm-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This additional part to the algorithm simply walks backwards through the
 Previous Vertex Vector, until the next path is undefined (meaning we are
 at the start or origin vertex).
\end_layout

\begin_layout Standard
Dijkstra's algorithm when implemented correctly with an efficient priority
 queue implementation, will offer 
\series bold
O(m log n)
\series default
 performance when used with an adjacency list representation of a graph.
\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
An implementation of Dijkstra's Algorithm can be seen in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Dijkstra's-Algorithm-(Java)"

\end_inset

.
 This implementation utilises an adjacency matrix as the graph represention
 data structure, thus offers 
\series bold
O(n
\begin_inset script superscript

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset

)
\series default
 performance.
 I've utilised an adjacency matrix in this example, as will allows easier/quicke
r understanding of the algorithm, as well as making to easily translatable
 to other programming languages such as C
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The only modification to be usable in C, would be to implement the Stack<E>
 datastructure, which can be easily done with a linked list datastructure,
 or even just a normal array (and maintaining a pointer/index to the last
 element in the array).
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.Stack;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class DijkstrasAlgorithm {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Find the shortest path from source vertex to destination vertex
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param adjacencyMatrix The graph represented as an adjacency matrix.
\end_layout

\begin_layout Plain Layout

   * @param sourceVertex The vertex to start from.
\end_layout

\begin_layout Plain Layout

   * @param destinationVertex The destination vertex
\end_layout

\begin_layout Plain Layout

   * @return A stack with the path from source to destination.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public Stack<Integer> DijkstraShortestPath(int[][] adjacencyMatrix, int
 sourceVertex,
\end_layout

\begin_layout Plain Layout

                                               int destinationVertex) {
\end_layout

\begin_layout Plain Layout

    final int UNDEFINED = -1;
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    // Define data structures needed for implementation.
\end_layout

\begin_layout Plain Layout

    Stack<Integer> path = new Stack<Integer>();
\end_layout

\begin_layout Plain Layout

    boolean[] visited = new boolean[adjacencyMatrix.length];
\end_layout

\begin_layout Plain Layout

    int[] previousVertex = new int[adjacencyMatrix.length];
\end_layout

\begin_layout Plain Layout

    int[] pathWeights = new int[adjacencyMatrix.length];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Clear all arrays being used.
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < adjacencyMatrix.length; i++) {
\end_layout

\begin_layout Plain Layout

      pathWeights[i] = Integer.MAX_VALUE; // Infinity
\end_layout

\begin_layout Plain Layout

      previousVertex[i] = UNDEFINED;
\end_layout

\begin_layout Plain Layout

      visited[i] = false;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Set the starting vertex.
\end_layout

\begin_layout Plain Layout

    pathWeights[sourceVertex] = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Follow all vertices, calculating paths/distances.
\end_layout

\begin_layout Plain Layout

    for (int k = 0; k < adjacencyMatrix.length; k++) {
\end_layout

\begin_layout Plain Layout

      int min = -1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Find shortest path to vertex not yet visited.
\end_layout

\begin_layout Plain Layout

      for (int i = 0; i < adjacencyMatrix.length; i++) {
\end_layout

\begin_layout Plain Layout

        if (!visited[i] && (min == -1 || pathWeights[i] < pathWeights[min]))
 {
\end_layout

\begin_layout Plain Layout

          min = i;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Flag we are at a new vertex.
\end_layout

\begin_layout Plain Layout

      visited[min] = true;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // perform edge relaxation
\end_layout

\begin_layout Plain Layout

      for (int i = 0; i < adjacencyMatrix.length; i++) {
\end_layout

\begin_layout Plain Layout

        if (adjacencyMatrix[min][i] > 0) {
\end_layout

\begin_layout Plain Layout

          if (pathWeights[min] + adjacencyMatrix[min][i] < pathWeights[i])
 {
\end_layout

\begin_layout Plain Layout

            pathWeights[i] = pathWeights[min] + adjacencyMatrix[min][i];
\end_layout

\begin_layout Plain Layout

            previousVertex[i] = min;
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // All vertices have been visited, so now construct a path
\end_layout

\begin_layout Plain Layout

    path.push(destinationVertex);
\end_layout

\begin_layout Plain Layout

    while (previousVertex[destinationVertex] != UNDEFINED) {
\end_layout

\begin_layout Plain Layout

      path.push(previousVertex[destinationVertex]);
\end_layout

\begin_layout Plain Layout

      destinationVertex = previousVertex[destinationVertex];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return path;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Dijkstra's Algorithm (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Dijkstra's-Algorithm-(Java)"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem - Single Source Shortest Path
\end_layout

\begin_layout Standard
Find the shortest path between a given node and all the other nodes in a
 weighted directed graph.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
The first line of input will be a number on a line by itself which is the
 number of test cases to run.
 For each test case, the first line will be three each numbers separated
 by a space 
\shape italic
N
\shape default
, 
\shape italic
E
\shape default
 and 
\shape italic
X
\shape default
, where 
\shape italic
N
\shape default
 (1 <= 
\shape italic
N
\shape default
 <= 5000) is the number of nodes in the graph, 
\shape italic
E
\shape default
 (1 <= 
\shape italic
E
\shape default
 <= 10000) is the number of edges and 
\shape italic
X
\shape default
 (0 <= 
\shape italic
X
\shape default
 < 
\shape italic
N
\shape default
) is the source node for the shortest paths.
 The graph nodes will be numbered 0 to 
\shape italic
N
\shape default
-1.
 Each of the next 
\shape italic
E
\shape default
 lines contain three numbers 
\shape italic
S
\shape default
, 
\shape italic
D
\shape default
 and 
\shape italic
W
\shape default
 each separated by a space representing an edge in the graph from 
\shape italic
S
\shape default
 (0 <= 
\shape italic
S
\shape default
 < 
\shape italic
N
\shape default
) to 
\shape italic
D
\shape default
 (0 <= 
\shape italic
D
\shape default
 < 
\shape italic
N
\shape default
) with weight 
\shape italic
W
\shape default
 (0 < 
\shape italic
W
\shape default
 <= 1000).
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
2 
\begin_inset Newline newline
\end_inset

5 7 0
\begin_inset Newline newline
\end_inset

0 1 10 
\begin_inset Newline newline
\end_inset

1 3 2 
\begin_inset Newline newline
\end_inset

1 4 6 
\begin_inset Newline newline
\end_inset

3 4 3 
\begin_inset Newline newline
\end_inset

2 4 6 
\begin_inset Newline newline
\end_inset

0 4 20 
\begin_inset Newline newline
\end_inset

0 2 30 
\begin_inset Newline newline
\end_inset

5 6 1 
\begin_inset Newline newline
\end_inset

0 1 8 
\begin_inset Newline newline
\end_inset

0 3 2 
\begin_inset Newline newline
\end_inset

0 4 5 
\begin_inset Newline newline
\end_inset

1 2 6 
\begin_inset Newline newline
\end_inset

2 3 4 
\begin_inset Newline newline
\end_inset

3 4 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
For each test case, output the test case number on a line followed by a
 space and then a space separated list shortest path weights for each node
 in ascending node number order.
 If there is no path from the source node to another node print ‘NP’.
 See the example output below.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
1 
\begin_inset Newline newline
\end_inset

0 10 30 12 15 
\begin_inset Newline newline
\end_inset

2 
\begin_inset Newline newline
\end_inset

NP 0 6 10 13
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Solution
\end_layout

\begin_layout Standard
A sample solution to the Single Source Shortest Path problem can be found
 in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Single"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.Comparator;
\end_layout

\begin_layout Plain Layout

import java.util.PriorityQueue;
\end_layout

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class ShortestPathProblem {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  private static int INFINITY = Integer.MAX_VALUE;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    new ShortestPathProblem().run();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  public void run() {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Vertex[] vertexList;  // List of all vertices in graph
\end_layout

\begin_layout Plain Layout

    PriorityQueue<Vertex> verticesQueue;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Scanner scn = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

    int testCount = scn.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Loop through all test cases.
\end_layout

\begin_layout Plain Layout

    for (int testItem = 1; testItem <= testCount; testItem++) {
\end_layout

\begin_layout Plain Layout

      int numVertices = scn.nextInt();
\end_layout

\begin_layout Plain Layout

      int numEdges = scn.nextInt();
\end_layout

\begin_layout Plain Layout

      int sourceVertex = scn.nextInt(); // source vertex
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // create array to store N vertices
\end_layout

\begin_layout Plain Layout

      vertexList = new Vertex[numVertices];
\end_layout

\begin_layout Plain Layout

      for (int n = 0; n < numVertices; n++) {
\end_layout

\begin_layout Plain Layout

        vertexList[n] = new Vertex(numVertices);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // set source vertex (distance = 0 at source!)
\end_layout

\begin_layout Plain Layout

      vertexList[sourceVertex].distance = 0; 
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      for (int edge = 0; edge < numEdges; edge++) {
\end_layout

\begin_layout Plain Layout

        int s = scn.nextInt(); // source vertex
\end_layout

\begin_layout Plain Layout

        int d = scn.nextInt(); // destination vertex
\end_layout

\begin_layout Plain Layout

        int w = scn.nextInt(); // distance from s to d
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // add to adjacency list
\end_layout

\begin_layout Plain Layout

        vertexList[s].adjacencyList[d] = w;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Create priority queue of N elements, and queue all elements.
\end_layout

\begin_layout Plain Layout

      Vertex comp = new Vertex(numVertices);
\end_layout

\begin_layout Plain Layout

      verticesQueue = new PriorityQueue<Vertex>(numVertices, comp);
\end_layout

\begin_layout Plain Layout

      for (Vertex v : vertexList) {
\end_layout

\begin_layout Plain Layout

        verticesQueue.add(v);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Start main Dijkstra'a Algorithm
\end_layout

\begin_layout Plain Layout

      while (!verticesQueue.isEmpty()) {
\end_layout

\begin_layout Plain Layout

        Vertex uVertex = verticesQueue.poll();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if (uVertex.distance == INFINITY) // vertex can't be reached
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

          break;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Loop through all neighbouring vertices
\end_layout

\begin_layout Plain Layout

        for (int n = 0; n < numVertices; n++) {
\end_layout

\begin_layout Plain Layout

          if (uVertex.adjacencyList[n] != INFINITY 
\end_layout

\begin_layout Plain Layout

                 && verticesQueue.contains(vertexList[n])) {
\end_layout

\begin_layout Plain Layout

            verticesQueue.remove(vertexList[n]); // Remove old D[n] value.
\end_layout

\begin_layout Plain Layout

            vertexList[n].setDist(uVertex.distance + uVertex.adjacencyList[n]);
\end_layout

\begin_layout Plain Layout

            verticesQueue.add(vertexList[n]); // Add updated D[n] value to
 Queue
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Output the resulting Distance from source.
\end_layout

\begin_layout Plain Layout

      System.out.printf("%d
\backslash
n", testItem);
\end_layout

\begin_layout Plain Layout

      for (Vertex vertex : vertexList) {
\end_layout

\begin_layout Plain Layout

        vertex.printDistance();
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      System.out.println();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Class to define a vertex, including it's neighbouring vertices.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class Vertex implements Comparator<Vertex> {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public int distance;  // known distance from source vertex
\end_layout

\begin_layout Plain Layout

    public int[] adjacencyList; // weights to neighbouring vertices.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Default Constructor.
\end_layout

\begin_layout Plain Layout

     * @param numNeighbours The number of vertices in the graph.
 
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public Vertex(int numNeighbours) {
\end_layout

\begin_layout Plain Layout

      distance = INFINITY;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Create a list of weights to neighbours and set the weight to INFINITY.
\end_layout

\begin_layout Plain Layout

      adjacencyList = new int[numNeighbours];
\end_layout

\begin_layout Plain Layout

      for (int i = 0; i < numNeighbours; i++) {
\end_layout

\begin_layout Plain Layout

        adjacencyList[i] = INFINITY;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Update the distance for this vertex.
\end_layout

\begin_layout Plain Layout

     * @param newDistance 
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public void setDist(int newDistance) {
\end_layout

\begin_layout Plain Layout

      if (newDistance != INFINITY) {
\end_layout

\begin_layout Plain Layout

        if (distance == INFINITY || newDistance < distance) {
\end_layout

\begin_layout Plain Layout

          distance = newDistance;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Print the distance from source vertex to this vertex.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public void printDistance() {
\end_layout

\begin_layout Plain Layout

      if (distance == INFINITY) {
\end_layout

\begin_layout Plain Layout

        System.out.print("NP ");
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        System.out.printf("%d ", distance);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Comparator method for priority queue.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    @Override
\end_layout

\begin_layout Plain Layout

    public int compare(Vertex o1, Vertex o2) {
\end_layout

\begin_layout Plain Layout

      if (o1.distance < o2.distance) {
\end_layout

\begin_layout Plain Layout

        return -1;
\end_layout

\begin_layout Plain Layout

      } else if (o1.distance > o2.distance) {
\end_layout

\begin_layout Plain Layout

        return 1;
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        return 0;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Solution to Single Source Shortest Path Problem (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Single"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The few edge cases to consider would be very dense graphs, very sparse graphs,
 or graphs that contain zero edges.
 Another edge case that should be considered is the maximum weight between
 vertices, and ensuring that the data type that holds the weight from source
 to destination is capable of representing the value without overflow.
 (That is any possible weight from source to destination is less than the
 maximum value used to hold the weight).
\end_layout

\begin_layout Standard
As the problem focuses around the algorithm itself, the implementation of
 the algorithm is the key factor in success with this problem.
 Two items to note about the implemention of the sample solution compared
 to the reference implementation, is that we don't maintain a data structure
 to find a path from a source to destination vertex, and the use of the
 priority queue.
\end_layout

\begin_layout Standard
The priority queue itself offers a significant improvement over the sample
 implementation in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Dijkstra's-Algorithm-(Java)"

\end_inset

, by providing a single datastructure that maintains a list of unvisited
 vertices and also sorts the vertices by weight, so the head of the queue
 is the next unvisited vertex with the least weight.
 This implementation as shown should offer 
\series bold
O((n+m) log n)
\series default
 performance.
\end_layout

\begin_layout Subsubsection
All Pairs Shortest Path
\end_layout

\begin_layout Standard
While is it extremely useful to find the shortest path from a source vertex
 to any other vertex within a graph, an alternative is to find the shortest
 path from any vertex to any other vertex in a graph utilising a single
 algorithm.
 This is extremely useful if the paths and path options will remain static
 throughout the operation of the software system, as is typically found
 within computer games.
 Thereby, rather than having to recalculate the path for each entity within
 the game, we can simply lookup the information as it has been precomputed.
 (Effectively a 
\series bold
O(1)
\series default
 operation vs a 
\series bold
O((n+m) log n)
\series default
 operation).
\end_layout

\begin_layout Standard
A popular algorithm to perform this is the Floyd-Warshall Algorithm, as
 shown in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Floyd-Warshall-Algorithm"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require A directed Graph $
\backslash
vec{G}$ with non-negative edge weights, with $n$ vertices.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure A numbering $v_{1}, v_{2}, 
\backslash
ldots , v_{n}$ of vertices of $
\backslash
vec{G}$ and a matrix $D$, such that $D[i,j]$ is the distance from $v_{i}$
 to $v_{j}$ in $
\backslash
vec{G}$.
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{AllPairsShortestPaths}{$
\backslash
vec{G}$}
\end_layout

\begin_layout Plain Layout


\backslash
State {let $v_{1}, v_{2}, 
\backslash
ldots , v_{n}$ be an abitrary numbering of the vertices of $
\backslash
vec{G}$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$i 
\backslash
gets 1$ to $n$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$j 
\backslash
gets 1$ to $n$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$i=j$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$D^{0}[i,i] 
\backslash
gets 0$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
If {$(v_{i}, v_{j})$ is an edge in $
\backslash
vec{G}$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$D^{0}[i,j] 
\backslash
gets w((v_{i}, v_{j}))$}
\end_layout

\begin_layout Plain Layout


\backslash
Else
\end_layout

\begin_layout Plain Layout


\backslash
State {$D^{0}[i,j] 
\backslash
gets +
\backslash
infty$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
For {$k 
\backslash
gets 1$ to $n$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$i 
\backslash
gets 1$ to $n$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$j 
\backslash
gets 1$ to $n$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$D^{k}[i,j] 
\backslash
gets 
\backslash
min
\backslash
{D^{k-1}[i,j], D^{k-1}[i,k] + D^{k-1}[k,j] 
\backslash
}$}
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{return} $D^{n}$}
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Floyd-Warshall Algorithm
\begin_inset CommandInset label
LatexCommand label
name "alg:Floyd-Warshall-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
The Floyd-Warshall Algorithm is an example of dynamic programming that compares
 all possible paths through the graph between each pair of vertices.
 The remarkable aspect of the algorithm is the simplicity of the design,
 as well as having a runtime performance of only 
\series bold
O(n
\begin_inset script superscript

\begin_layout Plain Layout

\series bold
3
\end_layout

\end_inset

)
\series default
.
\end_layout

\begin_layout Standard
If we define 
\begin_inset Formula $f(i,j,k)$
\end_inset

 as the shortest distance from 
\begin_inset Formula $i$
\end_inset

 to 
\begin_inset Formula $j$
\end_inset

, using 
\begin_inset Formula $1\ldots k$
\end_inset

 as intermediated vertex, we find that:
\end_layout

\begin_layout Itemize
\begin_inset Formula $f(i,j,n)$
\end_inset

is the shortest distance from 
\begin_inset Formula $i$
\end_inset

 to 
\begin_inset Formula $j$
\end_inset

, and
\end_layout

\begin_layout Itemize
\begin_inset Formula $f(i,j,0)$
\end_inset

is the cost of
\begin_inset Formula $(i,j)$
\end_inset

.
\end_layout

\begin_layout Standard
Understanding that the optimal part for 
\begin_inset Formula $f(i,j,k)$
\end_inset

, may or may not have 
\begin_inset Formula $k$
\end_inset

 as an intermediate vertex, we find:
\end_layout

\begin_layout Itemize
If it does, 
\begin_inset Formula $f(i,j,k)=f(i,k,k-1)-f(k,j,k-1)$
\end_inset


\end_layout

\begin_layout Itemize
Otherwise, 
\begin_inset Formula $f(i,j,k)=f(i,j,k-1)$
\end_inset


\end_layout

\begin_layout Standard
Which leads to 
\begin_inset Formula $f(i,j,k)$
\end_inset

 being the minimum of the two quantities above.
 If the above properties are extended to all vertices within the graph,
 we may find all paths in one easy operation!
\end_layout

\begin_layout Standard
Like Dijkstra's Algorithm, the Floyd-Warshall Algorithm only finds the minimum
 weight of the path, however with a small modification it is possible to
 determine the path as well.
\end_layout

\begin_layout Standard
In order to determine the path between two vertices, we are required to
 maintain an additional matrix that defines the path 
\begin_inset Formula $P$
\end_inset

.
 If the new new weight is less than the previous weight, then we store 
\begin_inset Formula $k$
\end_inset

 at 
\begin_inset Formula $P(i,j)$
\end_inset

.
 Once all weights have been determined we use Alogrithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Floyd-Warshall-Algorithm-(Find"

\end_inset

 to determine the path.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require Matrix $P$ of previously visited vertices (constructed in Floyd-Warshall
 Algorithm), source vertex $i$ and target vertex $j$ 
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Vector $Path$ with path from $i$ to $j$
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{define} $Path 
\backslash
gets 
\backslash
emptyset$} 
\backslash
Comment{Global data, Queue datatype}
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{FloydWarshallShortestPath}{$P, i, j$}
\end_layout

\begin_layout Plain Layout


\backslash
If{$P[i,j] = $ null}
\end_layout

\begin_layout Plain Layout


\backslash
State {$Path .
\backslash
textsf{add()} 
\backslash
gets P[i,j]$} 
\backslash
Comment{add $k$ onto end of queue}
\end_layout

\begin_layout Plain Layout


\backslash
Else
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textsf{FloydWarshallShortestPath}($P, i, P[i,j]$)}
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textsf{FloydWarshallShortestPath}($P, P[i,j], j$)}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Floyd-Warshall Algorithm (Find Path)
\begin_inset CommandInset label
LatexCommand label
name "alg:Floyd-Warshall-Algorithm-(Find"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
An implementation of the Floyd-Warshall Algorithm is shown in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Floyd-Warshall-Algorithm-(Java)"

\end_inset

.
 This implementation expects that the adjacency matrix is complete with
 information, and that path information is required.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.ArrayList;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class FloydWarshall {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  private int[][] path;
\end_layout

\begin_layout Plain Layout

  private int[][] pathWeights;
\end_layout

\begin_layout Plain Layout

  ArrayList<Integer> sdpath;
\end_layout

\begin_layout Plain Layout

  private final static int NULL = -1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Perform Floyd-Warshall Algorithm on weighted directed graph.
\end_layout

\begin_layout Plain Layout

   * @param matrix Adjacency Matrix representation of grpah.
\end_layout

\begin_layout Plain Layout

   * @return Matrx of costs for graph.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public int[][] AllPairsShortestPath(int[][] matrix) {
\end_layout

\begin_layout Plain Layout

    int numberVertices = matrix.length;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // create new storage container for path and weight information
\end_layout

\begin_layout Plain Layout

    path = new int[numberVertices][numberVertices];
\end_layout

\begin_layout Plain Layout

    pathWeights = new int[numberVertices][numberVertices];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Initialise containers;
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < numberVertices; i++) {
\end_layout

\begin_layout Plain Layout

      for (int j = 0; j < numberVertices; j++) {
\end_layout

\begin_layout Plain Layout

        // If no direct path, set weight to Infinity.
\end_layout

\begin_layout Plain Layout

        pathWeights[i][j] = matrix[i][j] > 0 ? matrix[i][j] : Integer.MAX_VALUE;
\end_layout

\begin_layout Plain Layout

        if(i == j){
\end_layout

\begin_layout Plain Layout

          pathWeights[i][j] = 0;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        path[i][j] = NULL;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Main loop.
\end_layout

\begin_layout Plain Layout

    for (int k = 0; k < numberVertices; k++) {
\end_layout

\begin_layout Plain Layout

      for (int i = 0; i < numberVertices; i++) {
\end_layout

\begin_layout Plain Layout

        for (int j = 0; j < numberVertices; j++) {
\end_layout

\begin_layout Plain Layout

          // Cast these to long to avoid overflow!
\end_layout

\begin_layout Plain Layout

          if ((long)pathWeights[i][j] > (long)pathWeights[i][k]+(long)pathWeight
s[k][j]) {
\end_layout

\begin_layout Plain Layout

            // Store new min weight
\end_layout

\begin_layout Plain Layout

            pathWeights[i][j] = pathWeights[i][k] + pathWeights[k][j];
\end_layout

\begin_layout Plain Layout

            // Store new path through k.
\end_layout

\begin_layout Plain Layout

            path[i][j] = k;
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return pathWeights;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Find the shortest Path from source to destination, based on a previous
\end_layout

\begin_layout Plain Layout

   * run of the Floyd-Warshall algorithm.
\end_layout

\begin_layout Plain Layout

   * @param source Source Vertex
\end_layout

\begin_layout Plain Layout

   * @param destination Destination Vertex
\end_layout

\begin_layout Plain Layout

   * @return Path from source to destination
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public ArrayList<Integer> ShortestPath(int source, int destination) {
\end_layout

\begin_layout Plain Layout

    sdpath = new ArrayList<Integer>();
\end_layout

\begin_layout Plain Layout

    SPath(source, destination);
\end_layout

\begin_layout Plain Layout

    return sdpath;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Recursively follow the path from source to destination.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  private void SPath(int source, int destination) {
\end_layout

\begin_layout Plain Layout

    if (path[source][destination] == NULL) {
\end_layout

\begin_layout Plain Layout

      sdpath.add(path[source][destination]);
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      SPath(source, path[source][destination]);
\end_layout

\begin_layout Plain Layout

      SPath(path[source][destination], destination);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Floyd-Warshall Algorithm (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Floyd-Warshall-Algorithm-(Java)"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem - All Pairs Shortest Path Problem
\end_layout

\begin_layout Standard
Find the shortest path between every pair of nodes in a weighted directed
 graph.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
The first line of input will be a number on a line by itself which is the
 number of test cases to run.
 For each test case, the first line will be two numbers separated by a space
 
\shape italic
N
\shape default
 and 
\shape italic
E
\shape default
, where 
\shape italic
N 
\shape default
(1 <= 
\shape italic
N
\shape default
 <= 1000) is the number of nodes in the graph and 
\shape italic
E
\shape default
 (1 <= 
\shape italic
E
\shape default
 <= 10000) is the number of edges.
 The graph nodes will be numbered 0 to 
\shape italic
N
\shape default
-1.
 Each of the next 
\shape italic
E
\shape default
 lines contain three numbers 
\shape italic
S
\shape default
, 
\shape italic
D
\shape default
 and 
\shape italic
W
\shape default
 each separated by a space representing an edge in the graph from 
\shape italic
S
\shape default
 (0 <= 
\shape italic
S
\shape default
 < 
\shape italic
N
\shape default
) to 
\shape italic
D
\shape default
 (0 <= 
\shape italic
D
\shape default
 < 
\shape italic
N
\shape default
) with weight 
\shape italic
W
\shape default
 (0 < 
\shape italic
W
\shape default
 <= 1000).
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
2 
\begin_inset Newline newline
\end_inset

5 7 
\begin_inset Newline newline
\end_inset

0 1 10 
\begin_inset Newline newline
\end_inset

1 3 2 
\begin_inset Newline newline
\end_inset

1 4 6 
\begin_inset Newline newline
\end_inset

3 4 3 
\begin_inset Newline newline
\end_inset

2 4 6 
\begin_inset Newline newline
\end_inset

0 4 20 
\begin_inset Newline newline
\end_inset

0 2 30 
\begin_inset Newline newline
\end_inset

5 6 
\begin_inset Newline newline
\end_inset

0 1 8 
\begin_inset Newline newline
\end_inset

0 3 2 
\begin_inset Newline newline
\end_inset

0 4 5 
\begin_inset Newline newline
\end_inset

1 2 6 
\begin_inset Newline newline
\end_inset

2 3 4 
\begin_inset Newline newline
\end_inset

3 4 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
For each test case, output the test case number on a line by itself.
 The following lines will contain the shortest paths matrix.
 That is the next 
\shape italic
n
\shape default
 (0 <= 
\shape italic
n
\shape default
 < 
\shape italic
N
\shape default
) lines will each contain a space separated list of the shortest path weight
 between node n and each other node in ascending node number order.
 If no path exists between a pair of node print ‘NP’.
 See the example output below.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
1 
\begin_inset Newline newline
\end_inset

0 10 30 12 15 
\begin_inset Newline newline
\end_inset

NP 0 NP 2 5 
\begin_inset Newline newline
\end_inset

NP NP 0 NP 6 
\begin_inset Newline newline
\end_inset

NP NP NP 0 3 
\begin_inset Newline newline
\end_inset

NP NP NP NP 0 
\begin_inset Newline newline
\end_inset

2 
\begin_inset Newline newline
\end_inset

0 8 14 2 5 
\begin_inset Newline newline
\end_inset

NP 0 6 10 13 
\begin_inset Newline newline
\end_inset

NP NP 0 4 7 
\begin_inset Newline newline
\end_inset

NP NP NP 0 3 
\begin_inset Newline newline
\end_inset

NP NP NP NP 0
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Solution
\end_layout

\begin_layout Standard
A sample solution to the All Pairs Shortest Path problem can be found in
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-All"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class AllPairsShortestProblem {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  private int[][] pathWeights;
\end_layout

\begin_layout Plain Layout

  private int[][] adjacencyMatrix;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    new AllPairsShortestProblem().run();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  public void run() {
\end_layout

\begin_layout Plain Layout

    Scanner scn = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

    int testCount = scn.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Loop through all test cases.
\end_layout

\begin_layout Plain Layout

    for (int testItem = 1; testItem <= testCount; testItem++) {
\end_layout

\begin_layout Plain Layout

      int numVertices = scn.nextInt();
\end_layout

\begin_layout Plain Layout

      int numEdges = scn.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // create adjacency Matrix
\end_layout

\begin_layout Plain Layout

      adjacencyMatrix = new int[numVertices][numVertices];
\end_layout

\begin_layout Plain Layout

      for (int i = 0; i < numVertices; i++) {
\end_layout

\begin_layout Plain Layout

        for (int j = 0; j < numVertices; j++) {
\end_layout

\begin_layout Plain Layout

          adjacencyMatrix[i][j] = 0;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      for (int edge = 0; edge < numEdges; edge++) {
\end_layout

\begin_layout Plain Layout

        int s = scn.nextInt(); // source vertex
\end_layout

\begin_layout Plain Layout

        int d = scn.nextInt(); // destination vertex
\end_layout

\begin_layout Plain Layout

        int w = scn.nextInt(); // distance from s to d
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // add to adjacency matrix
\end_layout

\begin_layout Plain Layout

        adjacencyMatrix[s][d] = w;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      // Create the matrix with wieght values.
\end_layout

\begin_layout Plain Layout

      AllPairsShortestPath(adjacencyMatrix);
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      // Output the resulting Distance from source.
\end_layout

\begin_layout Plain Layout

      System.out.printf("%d
\backslash
n", testItem);
\end_layout

\begin_layout Plain Layout

      for (int i = 0; i < numVertices; i++) {
\end_layout

\begin_layout Plain Layout

        for (int j = 0; j < numVertices; j++) {
\end_layout

\begin_layout Plain Layout

          if(pathWeights[i][j] == Integer.MAX_VALUE){
\end_layout

\begin_layout Plain Layout

            System.out.print("NP ");
\end_layout

\begin_layout Plain Layout

          } else {
\end_layout

\begin_layout Plain Layout

            System.out.printf("%d ", pathWeights[i][j]);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        System.out.println();
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  public void AllPairsShortestPath(int[][] matrix) {
\end_layout

\begin_layout Plain Layout

    int numberVertices = matrix.length;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // create new storage container for path and weight information
\end_layout

\begin_layout Plain Layout

    pathWeights = new int[numberVertices][numberVertices];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Initialise containers;
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < numberVertices; i++) {
\end_layout

\begin_layout Plain Layout

      for (int j = 0; j < numberVertices; j++) {
\end_layout

\begin_layout Plain Layout

        // If no direct path, set weight to Infinity.
\end_layout

\begin_layout Plain Layout

        pathWeights[i][j] = matrix[i][j] > 0 ? matrix[i][j] : Integer.MAX_VALUE;
\end_layout

\begin_layout Plain Layout

        if(i == j){
\end_layout

\begin_layout Plain Layout

          pathWeights[i][j] = 0;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    // Main loop.
\end_layout

\begin_layout Plain Layout

    for (int k = 0; k < numberVertices; k++) {
\end_layout

\begin_layout Plain Layout

      for (int i = 0; i < numberVertices; i++) {
\end_layout

\begin_layout Plain Layout

        for (int j = 0; j < numberVertices; j++) {
\end_layout

\begin_layout Plain Layout

          // Cast these to long to avoid overflow! 
\end_layout

\begin_layout Plain Layout

          if ((long)pathWeights[i][j] > (long)pathWeights[i][k]+(long)pathWeight
s[k][j]) {
\end_layout

\begin_layout Plain Layout

            // Store new min weight
\end_layout

\begin_layout Plain Layout

            pathWeights[i][j] = pathWeights[i][k] + pathWeights[k][j];
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Solution to All Pairs Shortest Path Problem
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-All"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The few edge cases to consider would be very dense graphs, very sparse graphs,
 or graphs that contain zero edges.
 Another edge case that should be considered is the maximum weight between
 vertices, and ensuring that the data type that holds the weight from source
 to destination is capable of representing the value without overflow.
 (That is any possible weight from source to destination is less than the
 maximum value used to hold the weight).
\end_layout

\begin_layout Subsubsection
A* Shortest Path
\end_layout

\begin_layout Standard
Another shortest path and graph traversal algorithm is the A*
\begin_inset Foot
status open

\begin_layout Plain Layout
The A* algorithm is pronounced as 
\begin_inset Quotes eld
\end_inset

A star
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

 Algorithm which offers improved runtime performance in the cases that both
 the source and destination vertex within the graph are known prior to running
 the algorithm.
 It is an extension of Dijkstra's Algorithm and A* achieves better performance
 (with respect to time) by using heuristics.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require A vertex $start$, and vertex $goal$ defining the source and destination
 vertices within an undirected graph.
 (The vertex data structure holds an adjacency list internally).
\end_layout

\begin_layout Plain Layout


\backslash
Ensure Weight of the shortest path
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{A*Search}{$start, goal$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$visited 
\backslash
gets 
\backslash
emptyset$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$Q 
\backslash
gets start$} 
\backslash
Comment {$Q$ Priority queue}
\end_layout

\begin_layout Plain Layout


\backslash
While {$Q$ is not empty}
\end_layout

\begin_layout Plain Layout


\backslash
State {$current 
\backslash
gets Q.
\backslash
textsf{removeMin()}$} 
\backslash
Comment{Remove next best from queue}
\end_layout

\begin_layout Plain Layout


\backslash
If {$current = goal$}
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{return} $goal.gScore$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
State {$visited.
\backslash
textsf{add()} 
\backslash
gets current$} 
\backslash
Comment{Add $current$ to the $visited$ set}
\end_layout

\begin_layout Plain Layout


\backslash
ForAll {vertex adjacent to $current$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$adj$ not in $visited$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$gScore 
\backslash
gets current.gScore + $distance($current, adj$)}
\end_layout

\begin_layout Plain Layout


\backslash
If{$adj$ not in $Q$ 
\backslash
textbf{or} $gScore < adj.gScore$ }
\end_layout

\begin_layout Plain Layout


\backslash
State {$adj.gScore 
\backslash
gets gScore$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$adj.hScore 
\backslash
gets$ distance($adj, goal$)}
\end_layout

\begin_layout Plain Layout


\backslash
State {$adj.fScore 
\backslash
gets adj.gScore + adj.hScorce$}
\end_layout

\begin_layout Plain Layout


\backslash
State {update $adj$ on $Q$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{return} FAILURE}
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A* Algorithm
\begin_inset CommandInset label
LatexCommand label
name "alg:AStar-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A* is commonly utilised in real-time robotics for path finding on dynamic
 graphs, or within navigation aids (such as in car GPS devices).
\end_layout

\begin_layout Paragraph
Description of working
\end_layout

\begin_layout Standard
A* utilises additional information within each vertex data structure to
 able to perform a heuristic search of the graph.
 In addition to the vertex location (x,y co-ordinates (Euclidean or Manhattan))
 and list of vertices adjacent, these are:
\end_layout

\begin_layout Itemize
gScore - cost from the start along the best path.
\end_layout

\begin_layout Itemize
hScore - heuristic estimate from the current location to the goal.
\end_layout

\begin_layout Itemize
fScore - gScrore + hScore
\end_layout

\begin_layout Standard
The algorithm also uses a priority queue of Vertices, that the lowest fScore
 has priority to be used for searching for the next vertex to traverse.
 And a Set of visited vertices, to ensure we don't search a vertex already
 searched.
\end_layout

\begin_layout Standard
The key variable in the algorithm, is the fScore, in that this is used to
 select the next vertex to traverse to in order to find the optimal path
 to the goal vertex.
 As noted above the vertex with the lowest fScore should lead to the shortest
 path, as it is an estimate of the current path cost, and the estimated
 cost left to the goal.
\end_layout

\begin_layout Standard
A demonstration of the A* Shortest Path Algorithm can be seen in Figures
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AStar-Initial-Map"

\end_inset

 to 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AStar-Initial-Map-6"

\end_inset

.
\end_layout

\begin_layout Standard
For the purposes of the demonstration, we have divided the search area into
 a square grid, with the start location being the Green Square (A) and the
 goal location being the Red Square (B) (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AStar-Initial-Map"

\end_inset

).
 Simplifying the search area, as we have done here, is the first step in
 pathfinding with A*.
 This particular method reduces our search area to a simple two dimensional
 array.
 Each item in the array represents one of the squares on the grid, and its
 status is recorded as walkable or unwalkable.
 The path is found by figuring out which squares we should take to get from
 A to B.
 Once the path is found, our entity or object moves from the center of one
 square to the center of the next until the target is reached.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/AStar1.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A* Initial Map
\begin_inset CommandInset label
LatexCommand label
name "fig:AStar-Initial-Map"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once we have simplified the search area, the next step is to start searching
 the grid to find our shortest path.
 We simply search all adjacent vertices, placing them onto the priority
 queue of vertices.
 (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AStar-Initial-Map-1"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/AStar2.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A* Default Search Pattern
\begin_inset CommandInset label
LatexCommand label
name "fig:AStar-Initial-Map-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We start the first iteration by path scoring our adjacent vertices, then
 place them onto the priority queue.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AStar-Initial-Map-2"

\end_inset

 demonstrates the gScores, hScores and fScores given to each vertex based
 on the initial search.
 (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AStar-Initial-Map-2"

\end_inset

 is prior to removing the first vertex from the priorty queue).
 It should be noted, that the hScore can be estimated in a number of ways.
 The method we use here is called the Manhattan method, where you calculate
 the total number of squares moved horizontally and vertically to reach
 the target square from the current square, ignoring diagonal movement,
 and ignoring any obstacles that may be in the way.
 We then multiply the total by 10, our cost for moving one square horizontally
 or vertically.
 This is (probably) called the Manhattan method because it is like calculating
 the number of city blocks from one place to another, where you can’t cut
 across the block diagonally.
 
\end_layout

\begin_layout Standard
While typically the hScore is the best guess, it does not represent the
 minimum number of squares in a direct line of sight from the current vertex
 to the goal vertex, but rather a best guess at the number of squares between
 the current and goal vertices.
 (The better the guess, the quicker the algorithm works).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/AStar3.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A* First Iteration
\begin_inset CommandInset label
LatexCommand label
name "fig:AStar-Initial-Map-2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AStar-Initial-Map-3"

\end_inset

 displays the first vertex to move to as part of the first iteration.
 This vertex, has the lowest fScore of 40 (shown with black border).
 On arriving, all adjacent vertices are added to the priority queue, however
 in this instance none are added.
 (All new vertices are obstacle vertices which can't be traversed).
 When add this vertex to the visited Set, and remove the vertex from the
 priority queue.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/AStar4.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A* First Iteration Step
\begin_inset CommandInset label
LatexCommand label
name "fig:AStar-Initial-Map-3"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AStar-Initial-Map-4"

\end_inset

 shows the next vertex being removed from the proirity queue (below the
 first vertex in this case), with it's adjacent vertices added to the priority
 queue, with the various Scores being shown.
 This time, when we check the adjacent squares we find that the one to the
 immediate right is a wall square, so we ignore that.
 The same goes for the one just above that.
 We also ignore the square just below the wall.
 Why? Because you can’t get to that square directly from the current square
 without cutting across the corner of the nearby wall.
 You really need to go down first and then move over to that square, moving
 around the corner in the process.
 (Note: This rule on cutting corners is optional.
 Its use depends on how your vertices are placed.)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/AStar5.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A* Second Iteration
\begin_inset CommandInset label
LatexCommand label
name "fig:AStar-Initial-Map-4"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We simply repeat this process, until we have a map as displayed in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AStar-Initial-Map-5"

\end_inset

.
 As can been seen, we have added some of the squares to the priority queue
 that are above starting point as well.
 This is due to the vertices already in the priority queue.
 After adding the two new vertices in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AStar-Initial-Map-4"

\end_inset

, the next vertex with the lowest fScore, is actually above and right of
 the start point! So we add those vertices to the priority queue as well.
 However on selection of the next vertex, we end up below the last vertex
 visited and continue on that path.
 (The final path could go either below or above the obstacle depending on
 how the priority queue is implementated, but for the sake of the demonstration
 we assume the oldest item is taken first even if two items have the same
 priority).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/AStar6.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A* Final Iteration
\begin_inset CommandInset label
LatexCommand label
name "fig:AStar-Initial-Map-5"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AStar-Initial-Map-5"

\end_inset

, displays the map after the final iteration of the algorithm.
 Take note that the path follows the lowest fScore through out the traversal.
 (Now that the current vertex is the same as the goal vertex, we terminate
 the algorithm.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/AStar7.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A* Path
\begin_inset CommandInset label
LatexCommand label
name "fig:AStar-Initial-Map-6"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To determine the actual path followed, we start at the goal square and work
 backwards moving from one square to its parent, following the arrows.
 This will eventually take you back to the starting square, and that’s your
 path.
 It should look like the the illustration in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AStar-Initial-Map-6"

\end_inset

.
 Moving from the starting square A to the destination square B is simply
 a matter of moving from the center of each square (the vertex) to the center
 of the next square on the path, until you reach the target.
\end_layout

\begin_layout Standard
The time complexity of the A* Shortest Path algorithm is deterministic on
 the hueristic function choosen, and how well it can guess the hScore value.
 This is due to the number of cells or paths that will be tested during
 the course of the algorithm running will vary accordingly to how accurate
 the estimation is.
 The absolute worst case will see A* function equivalent to Dijkstra's Algorithm.
 (However this rarely is the case).
\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
An implementation of the A* Shortest Path Algorithm is shown in Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:AStar-Shortest-Path"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.HashSet;
\end_layout

\begin_layout Plain Layout

import java.util.PriorityQueue;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * A* Search for Vertices that exist in 2D space.
 
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

public class aStar {
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Perform a search from start vertex to goal vertex, and return the cost
 of
\end_layout

\begin_layout Plain Layout

   * the path
\end_layout

\begin_layout Plain Layout

   * @param vertices An Array of Vertices within the graph.
\end_layout

\begin_layout Plain Layout

   * @param start The ID of the starting vertex.
\end_layout

\begin_layout Plain Layout

   * @param end The ID of the goal vertex.
\end_layout

\begin_layout Plain Layout

   * @return The weight of the path, or Double.POSITIVE_INFINITY if no path!
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public Double aStarSearch(Vertex[] vertices, int start, int goal) {
\end_layout

\begin_layout Plain Layout

    PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    vertices[start].gScore = 0.0;
\end_layout

\begin_layout Plain Layout

    vertices[goal].isGoal = true;
\end_layout

\begin_layout Plain Layout

    vertexQueue.add(vertices[start]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    while (!vertexQueue.isEmpty()) {
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      Vertex current = vertexQueue.poll();
\end_layout

\begin_layout Plain Layout

      if (current.isGoal) {
\end_layout

\begin_layout Plain Layout

        return vertices[goal].gScore;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      current.visited = true;
\end_layout

\begin_layout Plain Layout

      vertices[current.vertexID].visited = true;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // for all vertex adjacent to current do
\end_layout

\begin_layout Plain Layout

      for (int n = 0; n < vertices.length; n++) {
\end_layout

\begin_layout Plain Layout

        if (current.adjList.contains(n) && !vertices[n].visited) {
\end_layout

\begin_layout Plain Layout

          Vertex adj = vertices[n];
\end_layout

\begin_layout Plain Layout

          Double gScore = current.gScore + euclidianDistance(current, adj);
\end_layout

\begin_layout Plain Layout

          
\end_layout

\begin_layout Plain Layout

          // if adj not in Q or gScore < adj.gScore 
\end_layout

\begin_layout Plain Layout

          if (!vertexQueue.contains(adj) || gScore < adj.gScore) {
\end_layout

\begin_layout Plain Layout

            // Update the Scores for the adjacent vertex.
\end_layout

\begin_layout Plain Layout

            vertexQueue.remove(adj);
\end_layout

\begin_layout Plain Layout

            adj.gScore = gScore;
\end_layout

\begin_layout Plain Layout

            adj.hScore = euclidianDistance(adj, vertices[goal]);
\end_layout

\begin_layout Plain Layout

            adj.fScore = adj.gScore + adj.hScore;
\end_layout

\begin_layout Plain Layout

            // Add this vertex back into the priority queue with updated
 information.
\end_layout

\begin_layout Plain Layout

            vertexQueue.add(adj);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return Double.POSITIVE_INFINITY; // failed
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Return the distance between vertex A and vertex B, using euclidian
 distance
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param vertexA The first vertex
\end_layout

\begin_layout Plain Layout

   * @param vertexB The second vertex
\end_layout

\begin_layout Plain Layout

   * @return The distance between to two vertices.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  private  Double euclidianDistance(Vertex vertexA, Vertex vertexB) {
\end_layout

\begin_layout Plain Layout

    Double dist = Math.sqrt(
\end_layout

\begin_layout Plain Layout

              Math.pow((double)(vertexA.xCoordinate - vertexB.xCoordinate),
 2.0)
\end_layout

\begin_layout Plain Layout

            + Math.pow((double)(vertexA.yCoordinate - vertexB.yCoordinate),
 2.0));
\end_layout

\begin_layout Plain Layout

    return dist;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Class definition of the Vertex Information, with vertices in 2D space.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class Vertex implements Comparable<Vertex> {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public int xCoordinate; // Coordinate in 2D space.
\end_layout

\begin_layout Plain Layout

    public int yCoordinate; // Coordinate in 2D space.
\end_layout

\begin_layout Plain Layout

    public int vertexID;  // The id of the Vertex
\end_layout

\begin_layout Plain Layout

    public Double gScore;
\end_layout

\begin_layout Plain Layout

    public Double fScore;
\end_layout

\begin_layout Plain Layout

    public Double hScore;
\end_layout

\begin_layout Plain Layout

    public HashSet<Integer> adjList;
\end_layout

\begin_layout Plain Layout

    public Boolean visited; // Has this vertex been visited.
\end_layout

\begin_layout Plain Layout

    public Boolean isGoal; // Is this the goal vertex.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Default constructor.
\end_layout

\begin_layout Plain Layout

     *
\end_layout

\begin_layout Plain Layout

     * @param xCoord X Coordinate in 2D space.
\end_layout

\begin_layout Plain Layout

     * @param yCoord Y Coordinate in 3D space.
\end_layout

\begin_layout Plain Layout

     * @param entityId The id of the Vertex
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public Vertex(int xCoord, int yCoord, int entityId) {
\end_layout

\begin_layout Plain Layout

      xCoordinate = xCoord;
\end_layout

\begin_layout Plain Layout

      yCoordinate = yCoord;
\end_layout

\begin_layout Plain Layout

      vertexID = entityId;
\end_layout

\begin_layout Plain Layout

      gScore = Double.POSITIVE_INFINITY;
\end_layout

\begin_layout Plain Layout

      fScore = Double.POSITIVE_INFINITY;
\end_layout

\begin_layout Plain Layout

      hScore = Double.POSITIVE_INFINITY;
\end_layout

\begin_layout Plain Layout

      adjList = new HashSet<Integer>();
\end_layout

\begin_layout Plain Layout

      visited = false;
\end_layout

\begin_layout Plain Layout

      isGoal = false;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    @Override
\end_layout

\begin_layout Plain Layout

    public int compareTo(Vertex o) {
\end_layout

\begin_layout Plain Layout

      if (fScore < o.fScore) {
\end_layout

\begin_layout Plain Layout

        return -1;
\end_layout

\begin_layout Plain Layout

      } else if (fScore > o.fScore) {
\end_layout

\begin_layout Plain Layout

        return 1;
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        return 0;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
A* Shortest Path (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:AStar-Shortest-Path"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem - Shortest Road Trip
\end_layout

\begin_layout Standard
Road trip! It’s time to hit the road from your home town and travel to some
 randomly selected town on the map.
 Your map has 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $y$
\end_inset

 co-ordinates for all towns and the government has done an amazing job of
 laying perfectly straight roads between some of the towns as shown on the
 map.
 
\end_layout

\begin_layout Standard
The distance, 
\begin_inset Formula $d$
\end_inset

, between two towns, 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 is defined as the Euclidean distance between the coordinates 
\begin_inset Formula $(x_{a},y_{a})$
\end_inset

 and 
\begin_inset Formula $(x_{b},y_{b})$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d=\sqrt{(x_{a}-x_{b})^{2}+(y_{a}-y_{b})^{2}}
\]

\end_inset


\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
The first line of input will be a number on a line by itself which is the
 number of test cases to run.
 For each test case, the first line will have four numbers.
 The first number, 
\shape italic
N
\shape default
 (2 ≤ 
\shape italic
N
\shape default
 ≤ 10,000), is the number of towns on the map.
 The second number, 
\shape italic
E
\shape default
 (1 ≤ 
\shape italic
E
\shape default
 ≤ 20,000), is the number of roads on the map.
 The third and fourth numbers, 
\shape italic
S
\shape default
 (0 ≤ 
\shape italic
S
\shape default
 ≤
\shape italic
 N
\shape default
 – 1) and 
\shape italic
D
\shape default
 (0 ≤ 
\shape italic
D
\shape default
 ≤ 
\shape italic
N
\shape default
 – 1) are the numbers of the start and destination towns.
 
\end_layout

\begin_layout Standard
Each of the next 
\shape italic
N
\shape default
 lines has two integers, 
\begin_inset Formula $x_{i}$
\end_inset

 and 
\begin_inset Formula $y_{i}$
\end_inset

 (-50,000 ≤ 
\begin_inset Formula $x_{i}$
\end_inset

, 
\begin_inset Formula $y_{i}$
\end_inset

 ≤ 50,000), giving the coordinates of the 
\begin_inset Formula $i^{th}$
\end_inset

 town on the map.
 
\end_layout

\begin_layout Standard
Each of the next 
\shape italic
E
\shape default
 lines of input has two integers, 
\begin_inset Formula $n_{i}$
\end_inset

 and 
\begin_inset Formula $n_{j}$
\end_inset

 (0 ≤ 
\begin_inset Formula $n_{i}$
\end_inset

, 
\begin_inset Formula $n_{j}$
\end_inset

 ≤ 
\shape italic
N
\shape default
 – 1) giving the end towns of the roads.
 Roads only connect their start and destination towns.
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
2 
\begin_inset Newline newline
\end_inset

5 7 0 4 
\begin_inset Newline newline
\end_inset

0 0 
\begin_inset Newline newline
\end_inset

0 10 
\begin_inset Newline newline
\end_inset

5 7 
\begin_inset Newline newline
\end_inset

5 3 
\begin_inset Newline newline
\end_inset

5 -3 
\begin_inset Newline newline
\end_inset

0 1 
\begin_inset Newline newline
\end_inset

3 0 
\begin_inset Newline newline
\end_inset

3 1 
\begin_inset Newline newline
\end_inset

0 2 
\begin_inset Newline newline
\end_inset

2 3 
\begin_inset Newline newline
\end_inset

4 3 
\begin_inset Newline newline
\end_inset

1 2 
\begin_inset Newline newline
\end_inset

3 1 0 2 
\begin_inset Newline newline
\end_inset

0 0 
\begin_inset Newline newline
\end_inset

0 10 
\begin_inset Newline newline
\end_inset

10 0 
\begin_inset Newline newline
\end_inset

1 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
For each road trip in the input, output the shortest distance between the
 start and destination towns in the format shown below.
 If the destination town is not reachable output IMPOSSIBLE.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
Road Trip 1: 11.83 
\begin_inset Newline newline
\end_inset

Road Trip 2: IMPOSSIBLE
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Solution
\end_layout

\begin_layout Standard
A sample solution to the Shortest Road Trip problem can be found in Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Shortest"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.HashSet;
\end_layout

\begin_layout Plain Layout

import java.util.PriorityQueue;
\end_layout

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class ShortestRoadTrip {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    new ShortestRoadTrip().run();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  public void run() {
\end_layout

\begin_layout Plain Layout

    int numTowns, numRoads, startTown, destinationTown;
\end_layout

\begin_layout Plain Layout

    Scanner scn = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

    int numTests = scn.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int test = 1; test <= numTests; test++) {
\end_layout

\begin_layout Plain Layout

      numTowns = scn.nextInt();
\end_layout

\begin_layout Plain Layout

      numRoads = scn.nextInt();
\end_layout

\begin_layout Plain Layout

      startTown = scn.nextInt();
\end_layout

\begin_layout Plain Layout

      destinationTown = scn.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Array of all towns.
\end_layout

\begin_layout Plain Layout

      Vertex[] towns = new Vertex[numTowns]; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Get Town Co-ordinates.
\end_layout

\begin_layout Plain Layout

      for (int town = 0; town < numTowns; town++) {
\end_layout

\begin_layout Plain Layout

        int x = scn.nextInt(); 
\end_layout

\begin_layout Plain Layout

        int y = scn.nextInt();
\end_layout

\begin_layout Plain Layout

        towns[town] = new Vertex(x, y, town);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Get our road information.
\end_layout

\begin_layout Plain Layout

      for (int road = 0; road < numRoads; road++) {
\end_layout

\begin_layout Plain Layout

        int source = scn.nextInt(); // input roads
\end_layout

\begin_layout Plain Layout

        int destination = scn.nextInt();
\end_layout

\begin_layout Plain Layout

        towns[source].adjList.add(destination); // set towns adjacency
\end_layout

\begin_layout Plain Layout

        towns[destination].adjList.add(source); // i.e.
 connected by road
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Perform Search
\end_layout

\begin_layout Plain Layout

      Double tripDistance = aStarSearch(towns, startTown, destinationTown);
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Output Results
\end_layout

\begin_layout Plain Layout

      System.out.printf("Road Trip %d: ", test); 
\end_layout

\begin_layout Plain Layout

      if (!tripDistance.isInfinite()) {
\end_layout

\begin_layout Plain Layout

        System.out.printf("%.2f
\backslash
n", tripDistance);
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        System.out.println("IMPOSSIBLE");
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Perform a search from start vertex to goal vertex, and return the cost
 of
\end_layout

\begin_layout Plain Layout

   * the path
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param vertices An Array of Vertices within the graph.
\end_layout

\begin_layout Plain Layout

   * @param start The ID of the starting vertex.
\end_layout

\begin_layout Plain Layout

   * @param end The ID of the goal vertex.
\end_layout

\begin_layout Plain Layout

   * @return The weight of the path, or Double.POSITIVE_INFINITY if no path!
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public Double aStarSearch(Vertex[] vertices, int start, int goal) {
\end_layout

\begin_layout Plain Layout

    PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    vertices[start].gScore = 0.0;
\end_layout

\begin_layout Plain Layout

    vertices[goal].isGoal = true;
\end_layout

\begin_layout Plain Layout

    vertexQueue.add(vertices[start]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    while (!vertexQueue.isEmpty()) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      Vertex current = vertexQueue.poll();
\end_layout

\begin_layout Plain Layout

      if (current.isGoal) {
\end_layout

\begin_layout Plain Layout

        return vertices[goal].gScore;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      current.visited = true;
\end_layout

\begin_layout Plain Layout

      vertices[current.vertexID].visited = true;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // for all vertex adjacent to current do
\end_layout

\begin_layout Plain Layout

      for (int n = 0; n < vertices.length; n++) {
\end_layout

\begin_layout Plain Layout

        if (current.adjList.contains(n) && !vertices[n].visited) {
\end_layout

\begin_layout Plain Layout

          Vertex adj = vertices[n];
\end_layout

\begin_layout Plain Layout

          Double gScore = current.gScore + euclidianDistance(current, adj);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

          // if adj not in Q or gScore < adj.gScore 
\end_layout

\begin_layout Plain Layout

          if (!vertexQueue.contains(adj) || gScore < adj.gScore) {
\end_layout

\begin_layout Plain Layout

            // Update the Scores for the adjacent vertex.
\end_layout

\begin_layout Plain Layout

            vertexQueue.remove(adj);
\end_layout

\begin_layout Plain Layout

            adj.gScore = gScore;
\end_layout

\begin_layout Plain Layout

            adj.hScore = euclidianDistance(adj, vertices[goal]);
\end_layout

\begin_layout Plain Layout

            adj.fScore = adj.gScore + adj.hScore;
\end_layout

\begin_layout Plain Layout

            // Add this vertex back into the priority queue with updated
 information.
\end_layout

\begin_layout Plain Layout

            vertexQueue.add(adj);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return Double.POSITIVE_INFINITY; // failed
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Return the distance between vertex A and vertex B, using euclidian
 distance
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param vertexA The first vertex
\end_layout

\begin_layout Plain Layout

   * @param vertexB The second vertex
\end_layout

\begin_layout Plain Layout

   * @return The distance between to two vertices.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  private Double euclidianDistance(Vertex vertexA, Vertex vertexB) {
\end_layout

\begin_layout Plain Layout

    Double dist = Math.sqrt(
\end_layout

\begin_layout Plain Layout

              Math.pow((double)(vertexA.xCoordinate - vertexB.xCoordinate),
 2.0)
\end_layout

\begin_layout Plain Layout

            + Math.pow((double)(vertexA.yCoordinate - vertexB.yCoordinate),
 2.0));
\end_layout

\begin_layout Plain Layout

    return dist;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Class definition of the Vertex Information, with vertices in 2D space.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class Vertex implements Comparable<Vertex> {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public int xCoordinate; // Coordinate in 2D space.
\end_layout

\begin_layout Plain Layout

    public int yCoordinate; // Coordinate in 2D space.
\end_layout

\begin_layout Plain Layout

    public int vertexID;  // The id of the Vertex
\end_layout

\begin_layout Plain Layout

    public Double gScore;
\end_layout

\begin_layout Plain Layout

    public Double fScore;
\end_layout

\begin_layout Plain Layout

    public Double hScore;
\end_layout

\begin_layout Plain Layout

    public HashSet<Integer> adjList;
\end_layout

\begin_layout Plain Layout

    public Boolean visited; // Has this vertex been visited.
\end_layout

\begin_layout Plain Layout

    public Boolean isGoal; // Is this the goal vertex.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Default constructor.
\end_layout

\begin_layout Plain Layout

     *
\end_layout

\begin_layout Plain Layout

     * @param xCoord X Coordinate in 2D space.
\end_layout

\begin_layout Plain Layout

     * @param yCoord Y Coordinate in 2D space.
\end_layout

\begin_layout Plain Layout

     * @param entityId The id of the Vertex
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public Vertex(int xCoord, int yCoord, int entityId) {
\end_layout

\begin_layout Plain Layout

      xCoordinate = xCoord;
\end_layout

\begin_layout Plain Layout

      yCoordinate = yCoord;
\end_layout

\begin_layout Plain Layout

      vertexID = entityId;
\end_layout

\begin_layout Plain Layout

      gScore = Double.POSITIVE_INFINITY;
\end_layout

\begin_layout Plain Layout

      fScore = Double.POSITIVE_INFINITY;
\end_layout

\begin_layout Plain Layout

      hScore = Double.POSITIVE_INFINITY;
\end_layout

\begin_layout Plain Layout

      adjList = new HashSet<Integer>();
\end_layout

\begin_layout Plain Layout

      visited = false;
\end_layout

\begin_layout Plain Layout

      isGoal = false;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    @Override
\end_layout

\begin_layout Plain Layout

    public int compareTo(Vertex o) {
\end_layout

\begin_layout Plain Layout

      if (fScore < o.fScore) {
\end_layout

\begin_layout Plain Layout

        return -1;
\end_layout

\begin_layout Plain Layout

      } else if (fScore > o.fScore) {
\end_layout

\begin_layout Plain Layout

        return 1;
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        return 0;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Solution to Shortest Road Trip (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Shortest"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The few edge cases to consider would be very dense graphs, very sparse graphs,
 or graphs that contain zero edges.
 Another edge case that should be considered is the maximum weight between
 vertices, and ensuring that the data type that holds the weight from source
 to destination is capable of representing the value without overflow or
 even underflow.
 (That is when calculating the distance, we don't experience either overflow
 or underflow in regards when using the 
\family typewriter
pow()
\family default
 or 
\family typewriter
sqrt() 
\family default
methods).
 
\end_layout

\begin_layout Subsubsection
Topological Sort
\end_layout

\begin_layout Standard
Directed graphs wihtou direct cycles are encountered in many applications.
 Such a diagrap is often referred to as a 
\series bold
directed acyclic graph
\series default
 or 
\series bold
dag
\series default
, for short.
 Applications of such graphs include:
\end_layout

\begin_layout Itemize
Inheritence between C++ classes or Java Interfaces.
\end_layout

\begin_layout Itemize
Prerequistes between courses of a degree program.
\end_layout

\begin_layout Itemize
Scheduling constraints between tasks or a project.
\end_layout

\begin_layout Standard
Being able to sort a directed graph based on hierarchies or dependencies
 allows us to determine the order in which items may be done, or if there
 is a circular dependency in which we won't be able to complete our work.
 (That is task A relies on Task B to be completed, but Task B relies on
 Task A to be completed first.
 This is also known as the Chicken and Egg Problem).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require A directed graph $
\backslash
vec{G}$ with $n$ vertices.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure A topological ordering $v_{1}, 
\backslash
dots, v_{n}$ of $
\backslash
vec{G}$ or an indication that $
\backslash
vec{G}$ has a directed cycle.
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{TopologicalSort}{$
\backslash
vec{G}$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$S 
\backslash
gets 
\backslash
emptyset$} 
\backslash
Comment {Let $S$ be an empty Stack}
\end_layout

\begin_layout Plain Layout


\backslash
ForAll {vertex $u$ of $
\backslash
vec{G}$}
\end_layout

\begin_layout Plain Layout


\backslash
State {incounter($u$) $
\backslash
gets$ indeg($u$)}
\end_layout

\begin_layout Plain Layout


\backslash
If {incounter($u$) = 0}
\end_layout

\begin_layout Plain Layout


\backslash
State {$S$.
\backslash
textsf{push} $
\backslash
gets u$}	
\backslash
Comment {Push $u$ onto stack $S$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
State {$i 
\backslash
gets 1$}
\end_layout

\begin_layout Plain Layout


\backslash
While{$S$ is not empty}
\end_layout

\begin_layout Plain Layout


\backslash
State {$u 
\backslash
gets S$.
\backslash
textsf{pop}}	
\backslash
Comment {Pop Stack}
\end_layout

\begin_layout Plain Layout


\backslash
State {number $u$ as the $i$-th vertex $v_{i}$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$i 
\backslash
gets i + 1$}
\end_layout

\begin_layout Plain Layout


\backslash
ForAll {egde $e 
\backslash
in 
\backslash
vec{G}$.
\backslash
textsf{outIncidentEdges}($u$)}
\end_layout

\begin_layout Plain Layout


\backslash
State {$w 
\backslash
gets 
\backslash
vec{G}$.
\backslash
textsf{opposite}($u,e$)}
\end_layout

\begin_layout Plain Layout


\backslash
State {incounter($w$) $
\backslash
gets$ incounter($w$)$-1$ }
\end_layout

\begin_layout Plain Layout


\backslash
If {incounter($w$) = 0}
\end_layout

\begin_layout Plain Layout


\backslash
State {$S$.
\backslash
textsf{push} $
\backslash
gets w$}	
\backslash
Comment {Push $w$ onto stack $S$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
If{$i > n$}
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{return} $v_{1}, 
\backslash
dots, v_{n}$}
\end_layout

\begin_layout Plain Layout


\backslash
Else
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{return} "digraph $
\backslash
vec{G}$ has a directed cycle"}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Topological Sort Algorithm
\begin_inset CommandInset label
LatexCommand label
name "alg:Topological-Sort-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of Working
\end_layout

\begin_layout Standard
The alogrithm itself is based on the same principles as DFS, in that we
 first find all the vertices with an indegree of 0, and use these as our
 starting point.
 (We add these to a stack).
 The main 
\family typewriter
while()
\family default
 loop runs until this stack is empty.
 Within the main loop, we record the current vertex we are at, and then
 add all vertices incident to the current that have an indegree of 0 (when
 the current edge between the current vertex and adjacent vertex is removed)
 to stack for further processing.
\end_layout

\begin_layout Standard
At the end of the algorithm, if the number of edges processed is less than
 the total edge count, then we have detected a directed cycle in the graph
 (in which case we return an error), otherwise return a vector of order
 in which vertices were visited.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Topological-Sort"

\end_inset

 demonstrates the algorithm in action.
 (a) demonstrates the initial configuration; (b-h) after each while-loop
 iteration.
 The vertex labels give the vertex number and the current incounter value.
 The edges tarversed in previous iterations are drawn with thick solid lines.
 The edges traversed in the current iteration are drawn in dotted lines.
\end_layout

\begin_layout Standard
Within the example, the topological sort order would be: {A, D, F, B, C,
 E, G}.
\end_layout

\begin_layout Standard
A described Topological Sort algorithm has an expected runtime complexity
 of 
\series bold
O(n + m)
\series default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Topological Sort.eps
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Topological Sort
\begin_inset CommandInset label
LatexCommand label
name "fig:Topological-Sort"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
An implementation of the Topological Sort Algorithm can be found in Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Topological-Sort-Algorithm"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.ArrayList;
\end_layout

\begin_layout Plain Layout

import java.util.Stack;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class TopologicalSort {
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Perform a topological sort of the graph.
\end_layout

\begin_layout Plain Layout

   * @param graph The graph to sort.
\end_layout

\begin_layout Plain Layout

   * @return A List of vertices processed in order, or null if a cycle was
 detected.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public ArrayList<Vertex> TSort(ArrayList<Vertex> graph){
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    Stack<Vertex> vertexStack = new Stack<Vertex>();
\end_layout

\begin_layout Plain Layout

    ArrayList<Vertex> vertexVisitedOrder = new ArrayList<Vertex>();
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    // Add all vertices with an indegree of 0 to the stack.
\end_layout

\begin_layout Plain Layout

    for(Vertex vertex: graph){
\end_layout

\begin_layout Plain Layout

      if(vertex.inCount == 0){
\end_layout

\begin_layout Plain Layout

        vertexStack.push(vertex);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    //initialise the visited index.
\end_layout

\begin_layout Plain Layout

    int i = 1;
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    while(!vertexStack.empty()){
\end_layout

\begin_layout Plain Layout

      // get our next vertex from the stack, and add it to the visited array.
\end_layout

\begin_layout Plain Layout

      Vertex currentVertex = vertexStack.pop();
\end_layout

\begin_layout Plain Layout

      currentVertex.order = i++;
\end_layout

\begin_layout Plain Layout

      vertexVisitedOrder.add(currentVertex);
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      // Get all edges from this vertex.
\end_layout

\begin_layout Plain Layout

      for(Vertex w: currentVertex.adjList){
\end_layout

\begin_layout Plain Layout

        w.inCount--;
\end_layout

\begin_layout Plain Layout

        // Decrement the in degree count, and if 0, add to the processing
 list.
\end_layout

\begin_layout Plain Layout

        if(w.inCount == 0){
\end_layout

\begin_layout Plain Layout

          vertexStack.add(w);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    // If we have processed all edges, then return the visited order array.
\end_layout

\begin_layout Plain Layout

    if(i > graph.size()){
\end_layout

\begin_layout Plain Layout

      return vertexVisitedOrder;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return null; // return an error.
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Class definition of the Vertex Information, with vertices in 2D space.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class Vertex {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public int id = 0;
\end_layout

\begin_layout Plain Layout

    public int order = 0;
\end_layout

\begin_layout Plain Layout

    public ArrayList<Vertex> adjList;
\end_layout

\begin_layout Plain Layout

    public int inCount = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Default constructor.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public Vertex(int vertexID, int indeg) {
\end_layout

\begin_layout Plain Layout

      this.id = vertexID;
\end_layout

\begin_layout Plain Layout

      this.inCount = indeg;
\end_layout

\begin_layout Plain Layout

      adjList = new ArrayList<Vertex>();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Topological Sort Algorithm (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Topological-Sort-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem - Spreadsheet
\end_layout

\begin_layout Standard
In 1979, Dan Bricklin and Bob Frankston wrote VisiCalc, the first spreadsheet
 application.
 It became a huge success and, at that time, was the killer application
 for the Apple II computers.
 Today, spreadsheets are found on most desktop computers.
 
\end_layout

\begin_layout Standard
The idea behind spreadsheets is very simple, though powerful.
 A spreadsheet consists of a table where each cell contains either a number
 or a formula.
 A formula can compute an expression that depends on the values of other
 cells.
 Text and graphics can be added for presentation purposes.
 
\end_layout

\begin_layout Standard
You are to write a very simple spreadsheet application.
 Your program should accept several spreadsheets.
 Each cell of the spreadsheet contains either a numeric value (integers
 only) or a formula, which only support sums.
 If it is possible to compute all of the values of all of the formulas,
 then your program should output the resulting spreadsheet where all formulas
 have been replaced by their value.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
Naming of the top left cells.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
The first line of the input file contains the number of spreadsheets to
 follow.
 A spreadsheet starts with a line consisting of two integer numbers, separated
 by a space, giving the number of columns and rows.
 The following lines of the spreadsheet each contain a row.
 A row consists of the cells of that row, separated by a single space.
 
\end_layout

\begin_layout Standard
A cell consists either of a numeric integer value or of a formula.
 A formula starts with an equal sign (=).
 After that, one or more cell names follow, separated by plus signs (+).
 The value of such a formula is the sum of all values found in the referenced
 cells.
 These cells may again contain a formula.
 There are no spaces within a formula.
 
\end_layout

\begin_layout Standard
The name of a cell consists of one to three letters for the column followed
 by a number between 1 and 999 (including) for the row.
 The letters for the column form the following series: A, B, C, ..., Z, AA,
 AB, AC, ..., AZ, BA, ..., BZ, CA, ..., ZZ, AAA, AAB, ..., AAZ, ABA, ..., ABZ, ACA, ..., ZZZ.
 These letters correspond to the number from 1 to 18278.
 The top left cell has the name A1 (see table above).
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
2 
\begin_inset Newline newline
\end_inset

4 3 
\begin_inset Newline newline
\end_inset

10 34 37 =A1+B1+C1 
\begin_inset Newline newline
\end_inset

40 17 34 =A2+B2+C2 
\begin_inset Newline newline
\end_inset

=A1+A2 =B1+B2 =C1+C2 =D1+D2 
\begin_inset Newline newline
\end_inset

4 3 
\begin_inset Newline newline
\end_inset

10 34 37 =A1+B1+C1 
\begin_inset Newline newline
\end_inset

40 17 34 =A2+B2+C2 
\begin_inset Newline newline
\end_inset

=A1+A2 =B1+B2 =C1+C2 =D1+D2+D3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
For each test case, output the test case number followed by a colon on a
 line by itself.
 If the spreadsheet can be completely computed then, the following lines
 should contain the values of the cells of the spreadsheet printed in the
 same format as that of the input with all formulas replaced by values.
 If the spreadsheet cannot be completely computed because of cyclic references,
 then the line following the test case number should contain “Not computable!”.
 See the sample below.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
1: 
\begin_inset Newline newline
\end_inset

10 34 37 81 
\begin_inset Newline newline
\end_inset

40 17 34 91 
\begin_inset Newline newline
\end_inset

50 51 71 172 
\begin_inset Newline newline
\end_inset

2: 
\begin_inset Newline newline
\end_inset

Not computable!
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Solution
\end_layout

\begin_layout Standard
A sample solution to the Spreadsheet problem can be found in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Spreadsheet"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.ArrayList;
\end_layout

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

import java.util.Stack;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class SpreadSheet {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  static Vertex[][] cells;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    new SpreadSheet().run();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  private void run() {
\end_layout

\begin_layout Plain Layout

    int numCols;
\end_layout

\begin_layout Plain Layout

    int numRows;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Scanner sc = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

    int numSheets = sc.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int sheet = 1; sheet <= numSheets; sheet++) {
\end_layout

\begin_layout Plain Layout

      numCols = sc.nextInt();
\end_layout

\begin_layout Plain Layout

      numRows = sc.nextInt();
\end_layout

\begin_layout Plain Layout

      sc.nextLine();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Create a new spread sheet.
\end_layout

\begin_layout Plain Layout

      cells = new Vertex[numRows][numCols];
\end_layout

\begin_layout Plain Layout

      ArrayList<Vertex> graph = new ArrayList<Vertex>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Read in our rows.
\end_layout

\begin_layout Plain Layout

      for (int row = 0; row < numRows; row++) {
\end_layout

\begin_layout Plain Layout

        String rowStr = sc.nextLine();
\end_layout

\begin_layout Plain Layout

        String[] columns = rowStr.split(" ");
\end_layout

\begin_layout Plain Layout

        for (int col = 0; col < numCols; col++) {
\end_layout

\begin_layout Plain Layout

          if (cells[row][col] == null) {
\end_layout

\begin_layout Plain Layout

            cells[row][col] = new Vertex(row, col, columns[col]);
\end_layout

\begin_layout Plain Layout

          } else {
\end_layout

\begin_layout Plain Layout

            cells[row][col].setContents(columns[col]);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          // Add in all the vertices into the main graph.
\end_layout

\begin_layout Plain Layout

          graph.add(cells[row][col]);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Get our path around the spread sheet.
\end_layout

\begin_layout Plain Layout

      //ArrayList<Vertex> path = TopologicalSort(graph);
\end_layout

\begin_layout Plain Layout

      System.out.printf("%d:
\backslash
n", sheet);
\end_layout

\begin_layout Plain Layout

      if (!TopologicalSort(graph)) {
\end_layout

\begin_layout Plain Layout

        // No path found, so print we have no path.
\end_layout

\begin_layout Plain Layout

        System.out.println("Not computable!");
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        // print the output.
\end_layout

\begin_layout Plain Layout

        for (int row = 0; row < numRows; row++) {
\end_layout

\begin_layout Plain Layout

          for (int col = 0; col < numCols; col++) {
\end_layout

\begin_layout Plain Layout

            System.out.printf("%d ", cells[row][col].value);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          System.out.println();
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Perform a topological sort of the graph.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param graph The graph to sort.
\end_layout

\begin_layout Plain Layout

   * @return true if all edges processed and a order was found.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public boolean TopologicalSort(ArrayList<Vertex> graph) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Stack<Vertex> vertexStack = new Stack<Vertex>();
\end_layout

\begin_layout Plain Layout

    //ArrayList<Vertex> vertexVisitedOrder = new ArrayList<Vertex>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Add all vertices with an indegree of 0 to the stack.
\end_layout

\begin_layout Plain Layout

    for (Vertex vertex : graph) {
\end_layout

\begin_layout Plain Layout

      if (vertex.inCount == 0) {
\end_layout

\begin_layout Plain Layout

        vertexStack.push(vertex);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //initialise the vistied index.
\end_layout

\begin_layout Plain Layout

    int i = 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    while (!vertexStack.empty()) {
\end_layout

\begin_layout Plain Layout

      // get our next vertex from the stack, and add it to the visited array.
\end_layout

\begin_layout Plain Layout

      Vertex currentVertex = vertexStack.pop();
\end_layout

\begin_layout Plain Layout

      currentVertex.order = i++;
\end_layout

\begin_layout Plain Layout

      //vertexVisitedOrder.add(currentVertex);
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      // Process the dependencies immediately, rather than delaying processing
\end_layout

\begin_layout Plain Layout

      // Based on a derived path.
\end_layout

\begin_layout Plain Layout

      if (!currentVertex.adjList.isEmpty()) {
\end_layout

\begin_layout Plain Layout

        // have dependencies, so calculate
\end_layout

\begin_layout Plain Layout

        currentVertex.calculate();
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      // Get all edges from this vertex.
\end_layout

\begin_layout Plain Layout

      for (Cell cell : currentVertex.adjList) {
\end_layout

\begin_layout Plain Layout

        Vertex w = cells[cell.row][cell.column];
\end_layout

\begin_layout Plain Layout

        w.inCount--;
\end_layout

\begin_layout Plain Layout

        // Decrement the in degree count, and if 0, add to the processing
 list.
\end_layout

\begin_layout Plain Layout

        if (w.inCount == 0) {
\end_layout

\begin_layout Plain Layout

          vertexStack.add(w);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    // If we have processed all edges, then return the visited order array.
\end_layout

\begin_layout Plain Layout

    if (i > graph.size()) {
\end_layout

\begin_layout Plain Layout

      return true; // We found a parh, and processed all edges 
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return false; // return an error.
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Basic class to hold the location of a Cell (used in the adjacent list).
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class Cell {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public int row = 0;
\end_layout

\begin_layout Plain Layout

    public int column = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Basic constructor to build via row, col values.
\end_layout

\begin_layout Plain Layout

     *
\end_layout

\begin_layout Plain Layout

     * @param row
\end_layout

\begin_layout Plain Layout

     * @param col
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public Cell(int row, int col) {
\end_layout

\begin_layout Plain Layout

      this.row = row;
\end_layout

\begin_layout Plain Layout

      this.column = col;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Basic constructor to build via a spreadsheet cell reference.
\end_layout

\begin_layout Plain Layout

     *
\end_layout

\begin_layout Plain Layout

     * @param cellID The reference to this cell in A0 format.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public Cell(String cellID) {
\end_layout

\begin_layout Plain Layout

      setAddress(cellID);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Set the cell address via the spreadsheet cell reference format.
\end_layout

\begin_layout Plain Layout

     *
\end_layout

\begin_layout Plain Layout

     * @param address
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    private void setAddress(String address) {
\end_layout

\begin_layout Plain Layout

      int index = 0;
\end_layout

\begin_layout Plain Layout

      // Find the first number in the address reference
\end_layout

\begin_layout Plain Layout

      for (int cindex = 0; cindex < address.length(); cindex++) {
\end_layout

\begin_layout Plain Layout

        if (Character.isLetter(address.charAt(cindex))) {
\end_layout

\begin_layout Plain Layout

          index = cindex + 1;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // create a new array of char to hold the alpha part of the address.
\end_layout

\begin_layout Plain Layout

      char[] colAddress = new char[index];
\end_layout

\begin_layout Plain Layout

      address.getChars(0, index, colAddress, 0);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Convert both to column and row references.
\end_layout

\begin_layout Plain Layout

      column = convertToColNum(colAddress);
\end_layout

\begin_layout Plain Layout

      row = Integer.parseInt(address.substring(index)) - 1;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Convert a column Alphabet reference to a zero indexed number.
\end_layout

\begin_layout Plain Layout

     *
\end_layout

\begin_layout Plain Layout

     * @param column array of char to convert to number format.
\end_layout

\begin_layout Plain Layout

     * @return
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    private int convertToColNum(char[] column) {
\end_layout

\begin_layout Plain Layout

      int colAddress = -1;
\end_layout

\begin_layout Plain Layout

      String alpha = "_ABCDEFGHIJKLMNOPQRSTUVWXYZ"; // A = 1, Z = 26
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      for (int c = 0; c < column.length; c++) {
\end_layout

\begin_layout Plain Layout

        colAddress += alpha.indexOf(column[c]) * Math.pow(26, column.length
 - c - 1);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      return colAddress;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Class definition of the Vertex Information, with vertices in 2D space.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class Vertex {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public int order = 0;
\end_layout

\begin_layout Plain Layout

    public ArrayList<Cell> adjList;
\end_layout

\begin_layout Plain Layout

    public int inCount = 0;
\end_layout

\begin_layout Plain Layout

    public int value = 0;
\end_layout

\begin_layout Plain Layout

    public int row;
\end_layout

\begin_layout Plain Layout

    public int col;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Default constructor.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public Vertex(int row, int col) {
\end_layout

\begin_layout Plain Layout

      this.row = row;
\end_layout

\begin_layout Plain Layout

      this.col = col;
\end_layout

\begin_layout Plain Layout

      this.inCount = 0;
\end_layout

\begin_layout Plain Layout

      adjList = new ArrayList<Cell>();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Default Constructor.
\end_layout

\begin_layout Plain Layout

     *
\end_layout

\begin_layout Plain Layout

     * @param row Row of this vertex
\end_layout

\begin_layout Plain Layout

     * @param col Column of this vertex
\end_layout

\begin_layout Plain Layout

     * @param contents The contents of this cell.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public Vertex(int row, int col, String contents) {
\end_layout

\begin_layout Plain Layout

      this.row = row;
\end_layout

\begin_layout Plain Layout

      this.col = col;
\end_layout

\begin_layout Plain Layout

      this.inCount = 0;
\end_layout

\begin_layout Plain Layout

      adjList = new ArrayList<Cell>();
\end_layout

\begin_layout Plain Layout

      setContents(contents);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Set the value to be contained in this cell
\end_layout

\begin_layout Plain Layout

     *
\end_layout

\begin_layout Plain Layout

     * @param contents
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public final void setContents(String contents) {
\end_layout

\begin_layout Plain Layout

      // Attempt to get a plain number.
\end_layout

\begin_layout Plain Layout

      try {
\end_layout

\begin_layout Plain Layout

        value = Integer.parseInt(contents);
\end_layout

\begin_layout Plain Layout

      } catch (NumberFormatException e) {
\end_layout

\begin_layout Plain Layout

        // Must have a formula.
\end_layout

\begin_layout Plain Layout

        String f = contents.substring(1); //remove leading "="
\end_layout

\begin_layout Plain Layout

        String[] elements = f.split("
\backslash

\backslash
+");
\end_layout

\begin_layout Plain Layout

        // Add each element in the formula.
\end_layout

\begin_layout Plain Layout

        for (String item : elements) {
\end_layout

\begin_layout Plain Layout

          Cell element = new Cell(item);
\end_layout

\begin_layout Plain Layout

          // See if our reference already exists?
\end_layout

\begin_layout Plain Layout

          if (cells[element.row][element.column] == null) {
\end_layout

\begin_layout Plain Layout

            // create a new vertex.
\end_layout

\begin_layout Plain Layout

            cells[element.row][element.column] = new Vertex(element.row, element.col
umn);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          // Add that we have a cell that we reference.
\end_layout

\begin_layout Plain Layout

          this.inCount++;
\end_layout

\begin_layout Plain Layout

          // Let the cell we reference, know that we reference it.
  
\end_layout

\begin_layout Plain Layout

          // (add us to it's adjacency list).
\end_layout

\begin_layout Plain Layout

          cells[element.row][element.column].adjList.add(new Cell(this.row, this.col))
;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Update the value of vertex
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public void calculate() {
\end_layout

\begin_layout Plain Layout

      // Update the value of the cells, on our adjacent list with our value.
\end_layout

\begin_layout Plain Layout

      for (Cell element : adjList) {
\end_layout

\begin_layout Plain Layout

        cells[element.row][element.column].value += this.value;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Solution to Spreadsheet Problem (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Spreadsheet"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When utilising a topological sort within the spreadsheet problem, there
 are few issues with the problem.
\end_layout

\begin_layout Standard
Test cases to consider would be a spreadsheet with a single cell, a cell
 that is self referencing (that is, in cell A1, contains the formula 
\begin_inset Quotes eld
\end_inset

=A1
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
In development of a solution, special care should be taken in regards to
 development of the method that creates a row, column reference from the
 spread sheet style reference of A1.
 Input test cases should include both A1, and ZZZ999, ensuring that the
 row count is calculated correctly.
 Utilisation of regular expressions could help in determine the start of
 the number in the cell reference, however consideration for the penalities
 on using the regular expression engine, verses perfoming a linear search
 for at most 3 characters should also be considered.
\end_layout

\begin_layout Standard
Another test case to be considered is a cell's formula that may have multiple
 references to the same cell, for example 
\begin_inset Quotes eld
\end_inset

=A1+A1+
\begin_inset Formula $\ldots$
\end_inset

+A1
\begin_inset Quotes erd
\end_inset

, and that the number of cells referenced in the formula in essentially
 unlimited in length.
\end_layout

\begin_layout Standard
The solution as presented as a slight modification to the main algorithm,
 in that rather than adding the current vertex being operated on to the
 sorted path, we simple process the dependency calculation in place.
 This was done to save cycling through the path list later on, when it can
 be done in place in the middle of the algorithm.
\end_layout

\begin_layout Subsection
Graph Theory (Advanced)
\end_layout

\begin_layout Subsubsection
Maximal Matching
\end_layout

\begin_layout Standard
Description of Working
\end_layout

\begin_layout Standard
Implementation
\end_layout

\begin_layout Standard
Sample Problem -
\end_layout

\begin_layout Standard
Sample Solution
\end_layout

\begin_layout Subsubsection
Network Flow (minimum cost, maximum flow)
\end_layout

\begin_layout Standard
Description of Working
\end_layout

\begin_layout Standard
Implementation
\end_layout

\begin_layout Standard
Sample Problem -
\end_layout

\begin_layout Standard
Sample Solution
\end_layout

\begin_layout Subsection
Computational Geometery
\end_layout

\begin_layout Subsubsection
Line Segment Intersection
\end_layout

\begin_layout Standard
Determination if two line segments intersect is a key component for many
 math related problems found in computational geometery.
 The fields of application include:
\end_layout

\begin_layout Itemize
2D and 3D graphics, determining if two lines intersect, primarily for game
 logic, entity mapping, path boundaries, etc.
\end_layout

\begin_layout Itemize
Locations where roads or paths cross when determining wildlife paths, which
 may require fencing or some form of safe travel path for wildlife.
\end_layout

\begin_layout Standard
To determine if two line segments intersection requires the use of some
 mathematics and a quick glossary of terms.
\end_layout

\begin_layout Standard
A line segment, when plotted on a Cartesian graph has a start location 
\begin_inset Formula $P_{1}=(x_{1},y_{1})$
\end_inset

 and an end location 
\begin_inset Formula $P_{2}=(x_{2},y_{2})$
\end_inset

, and the line (or vector) itself is defined as 
\begin_inset Formula $L_{1}=(P_{1},P_{2})$
\end_inset

.
 To determine if two line segments as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Line-Intersection"

\end_inset

, requires some transformation of the problem.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/LineIntersection.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Line Intersection
\begin_inset CommandInset label
LatexCommand label
name "fig:Line-Intersection"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As can be seen in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Line-Intersection"

\end_inset

, there are 2 line segments, 
\begin_inset Formula $L_{1}=(P_{1},P_{2})$
\end_inset

 and 
\begin_inset Formula $L_{2}=(P_{3},P_{4})$
\end_inset

.
 In order to determine the point in which they intersect, we define the
 line-segments by their end points.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
P_{a}=P_{1}+U_{a}(P_{2}-P_{1})
\]

\end_inset


\begin_inset Formula 
\[
P_{b}=P_{3}+U_{b}(P_{4}-P_{3})
\]

\end_inset


\end_layout

\begin_layout Standard
Notice that if you put in zero for U, you’ll get the start point, if you
 put in one, you’ll get the end point.
 Also the point of intersection would be where they are equal.
 That is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
P_{a}=P_{b}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
P_{1}+U_{a}(P_{2}-P_{1})=P_{3}+U_{b}(P_{4}-P_{3})
\]

\end_inset


\end_layout

\begin_layout Standard
However since we need this in terms of x and y, we can rewrite that last
 equation as the following two:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x_{1}+U_{a}(x_{2}-x_{1})=x_{3}+U_{b}(x_{4}-x_{3})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
y_{1}+U_{a}(y_{2}-y_{1})=y_{3}+U_{b}(y_{4}-y_{3})
\]

\end_inset


\end_layout

\begin_layout Standard
We can use those to now solve for 
\begin_inset Formula $U$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
U_{a}=\frac{(x_{4}-x_{3})(y_{1}-y_{3})-(y_{4}-y_{3})(x_{1}-x_{3})}{(y_{4}-y_{3})(x_{2}-x_{1})-(x_{4}-x_{3})(y_{2}-y_{1})}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
U_{b}=\frac{(x_{2}-x_{1})(y_{1}-y_{3})-(y_{2}-y_{1})(x_{1}-x_{3})}{(y_{4}-y_{3})(x_{2}-x_{1})-(x_{4}-x_{3})(y_{2}-y_{1})}
\]

\end_inset


\end_layout

\begin_layout Standard
Notice that the denominator on both of those equations is the same.
 Solve for that first, if it is zero, then the lines are parallel and we’re
 done.
 (If both numerators are also zero, then the two line segments are coincident.)
\end_layout

\begin_layout Standard
Since these equations treat the lines as infinitely long lines instead of
 line segments we want, there is guaranteed to be an intersection point
 if the lines aren’t parallel.
 To determine if it happens in the segments we’ve specified, we need to
 see if 
\begin_inset Formula $U$
\end_inset

 is between zero and one.
 Verify that both of these are true:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
0\leq U_{a}\leq1
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
0\leq U_{b}\leq1
\]

\end_inset


\end_layout

\begin_layout Standard
If we’ve gotten this far, then our line segments intersect, and we just
 need to find the point at which they do and then we’re done.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x=x_{1}+U_{a}(x_{2}-x_{1})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
y=y_{1}+U_{a}(y_{2}-y_{1})
\]

\end_inset


\end_layout

\begin_layout Standard
A source code implementation of the above math can be found in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Line-Intersection-(Java)"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

public class LineSegmentIntersection {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Generic class to hold a point.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class Point {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public double x = 0.0;
\end_layout

\begin_layout Plain Layout

    public double y = 0.0;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Determine if 2 lines intersect, and provide intersection point.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param Line1 The vector of the first line
\end_layout

\begin_layout Plain Layout

   * @param Line2 The vector of the second line
\end_layout

\begin_layout Plain Layout

   * @return Point if there is an intersection, otherwise null.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public Point GetLineIntersection(Point[] Line1, Point[] Line2) {
\end_layout

\begin_layout Plain Layout

    Point result = new Point();
\end_layout

\begin_layout Plain Layout

    // Precalculate some points;
\end_layout

\begin_layout Plain Layout

    double x4_x3 = (Line2[1].x - Line2[0].x);
\end_layout

\begin_layout Plain Layout

    double x2_x1 = (Line1[1].x - Line1[0].x);
\end_layout

\begin_layout Plain Layout

    double y4_y3 = (Line2[1].y - Line2[0].y);
\end_layout

\begin_layout Plain Layout

    double y2_y1 = (Line1[1].y - Line1[0].y);
\end_layout

\begin_layout Plain Layout

    double x1_x3 = (Line1[0].x - Line2[0].x);
\end_layout

\begin_layout Plain Layout

    double y1_y3 = (Line1[0].y - Line2[0].y);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Get the demonitator
\end_layout

\begin_layout Plain Layout

    double dem = (y4_y3 * x2_x1) - (x4_x3 * y2_y1);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    // Determine U values.
\end_layout

\begin_layout Plain Layout

    double Ua = ((x4_x3 * y1_y3) - (y4_y3 * x1_x3)) / dem;
\end_layout

\begin_layout Plain Layout

    double Ub = ((x2_x1 * y1_y3) - (y2_y1 * x1_x3)) / dem;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Ensure our U values are in scope
\end_layout

\begin_layout Plain Layout

    if (Ua < 0 || Ua > 1 || Ub < 0 || Ub > 1) {
\end_layout

\begin_layout Plain Layout

      return null;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Calculate the intersection point.
\end_layout

\begin_layout Plain Layout

    result.x = Line1[0].x + Ua * (x2_x1);
\end_layout

\begin_layout Plain Layout

    result.y = Line1[0].y + Ua * (y2_y1);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    if (Double.isNaN(result.x) || Double.isNaN(result.y)) {
\end_layout

\begin_layout Plain Layout

      return null;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return result;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Line Intersection (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Line-Intersection-(Java)"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
With this method, we can determine if 2 lines intersect.
 However if we choose to determine in n-line segments intersect there are
 a number of approaches, with a naive approach would simply compare all
 lines with all other lines.
 This unfortunately would yield 
\series bold
O(n
\begin_inset script superscript

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset

)
\series default
 performance.
 A more efficient method would be to use a Sweep Line Algorithm.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement !h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require A set of line Segments $S$
\end_layout

\begin_layout Plain Layout


\backslash
Ensure A list of intersection points.
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{BentleyOttmannLineSweep}{$S$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$I 
\backslash
gets 
\backslash
emptyset$} 
\backslash
Comment {Let $I$ be an empty List of Intersections}
\end_layout

\begin_layout Plain Layout


\backslash
State {$SL 
\backslash
gets 
\backslash
emptyset$} 
\backslash
Comment {Let $SL$ be an empty set of the sweep line}
\end_layout

\begin_layout Plain Layout


\backslash
State {$T 
\backslash
gets S$} 
\backslash
Comment {Initialise Event Queue of all segment endpoints}
\end_layout

\begin_layout Plain Layout


\backslash
State {Sort $T$ by increasing $x$ and $y$ values of points}
\end_layout

\begin_layout Plain Layout


\backslash
While {$T 
\backslash
neq 
\backslash
emptyset$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$E 
\backslash
gets$ next event from $T$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$E$ is a left endpoint}
\end_layout

\begin_layout Plain Layout


\backslash
State {$E_{seg} 
\backslash
gets E$ segment}
\end_layout

\begin_layout Plain Layout


\backslash
State {$SL 
\backslash
gets E_{seg}$} 
\backslash
Comment {Add $E_{seg}$ to $SL$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$A_{seg} 
\backslash
gets $ segment above $E_{seg}$ in $SL$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$B_{seg} 
\backslash
gets $ segment below $E_{seg}$ in $SL$}
\end_layout

\begin_layout Plain Layout


\backslash
If {Intersection between $A_{seg}$ and $E_{seg}$ exists}
\end_layout

\begin_layout Plain Layout


\backslash
State {$T 
\backslash
gets $ Intersection ($A_{seg}$, $E_{seg}$)} 
\backslash
Comment {Insert the intersection into $T$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
If {Intersection between $B_{seg}$ and $E_{seg}$ exists}
\end_layout

\begin_layout Plain Layout


\backslash
State {$T 
\backslash
gets $ Intersection ($B_{seg}$, $E_{seg}$)} 
\backslash
Comment {Insert the intersection into $T$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
ElsIf {$E$ is a right endpoint}
\end_layout

\begin_layout Plain Layout


\backslash
State {$E_{seg} 
\backslash
gets E$ segment}
\end_layout

\begin_layout Plain Layout


\backslash
State {$A_{seg} 
\backslash
gets $ segment above $E_{seg}$ in $SL$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$B_{seg} 
\backslash
gets $ segment below $E_{seg}$ in $SL$}
\end_layout

\begin_layout Plain Layout


\backslash
State {Remove $E_{seg}$ from $SL$}
\end_layout

\begin_layout Plain Layout


\backslash
If {Intersection between $A_{seg}$ and $B_{seg}$ exists}
\end_layout

\begin_layout Plain Layout


\backslash
If {Intersection($B_{seg}$, $E_{seg}$) not in $T$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$T 
\backslash
gets $ Intersection ($A_{seg}$, $B_{seg}$)} 
\backslash
Comment {Insert the intersection into $T$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
Else 
\backslash
Comment {$E$ is an Intersection Event}
\end_layout

\begin_layout Plain Layout


\backslash
State {$I 
\backslash
gets E$}
\end_layout

\begin_layout Plain Layout


\backslash
State {Let $E_{seg1}$ above $E_{seg2}$ be $E$'s intersection segments in
 $SL$}
\end_layout

\begin_layout Plain Layout


\backslash
State {Swap $E_{seg1}$ and $E_{seg2}$, so $E_{seg2}$ is above $E_{seg1}$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$A_{seg} 
\backslash
gets $ segment above $E_{seg2}$ in $SL$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$B_{seg} 
\backslash
gets $ segment below $E_{seg1}$ in $SL$}
\end_layout

\begin_layout Plain Layout


\backslash
If {Intersection between $E_{seg2}$ and $A_{seg}$ exists}
\end_layout

\begin_layout Plain Layout


\backslash
If {Intersection($E_{seg2}$, $A_{seg}$) not in $T$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$T 
\backslash
gets $ Intersection ($E_{seg2}$, $A_{seg}$)} 
\backslash
Comment {Insert the intersection into $T$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
If {Intersection between $E_{seg1}$ and $B_{seg}$ exists}
\end_layout

\begin_layout Plain Layout


\backslash
If {Intersection($E_{seg1}$, $B_{seg}$) not in $T$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$T 
\backslash
gets $ Intersection ($E_{seg1}$, $B_{seg}$)} 
\backslash
Comment {Insert the intersection into $T$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
State {Remove $E$ from $T$}
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{return} $I$}
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Bentley-Ottmann Line Sweep Algorithm
\begin_inset CommandInset label
LatexCommand label
name "alg:Bentley-Ottmann-Line-Sweep"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of Working
\end_layout

\begin_layout Standard
The Bentley-Ottmann Line Sweep Algorithm utilises an event queue of points
 to determine if two line segments should be tested if they have an intersection
 or not, thereby reducing the number of intersection tests required.
\end_layout

\begin_layout Standard
This algorithm involves simulating the sweeping of a vertical line 
\begin_inset Formula $l$
\end_inset

, over the segments moving from left to right, starting at a location to
 the left of all input segments.
 Initially a sorted queue of all endpoints is maintainted, which forms the
 event queue of points to test.
 
\end_layout

\begin_layout Standard
During the sweep, the set of segments currently intersected by the sweep
 line is maintained by means of insertions into and removals from a binary
 search tree.
 When a new segment end point is encountered, the segment relating to the
 end point is either added or removed from the binary search tree, thus
 maintaining the list of segments intersecting with the sweep line.
 During either the insertion/removal operation a test of all segments that
 intersect the sweep line are tested to determine if they intersection,
 and if they do the intersection point is added to the event queue.
 If an intersection is encounterd during the sweep, the intersection is
 added to the known Intersection List, and the event is removed from the
 queue.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Line-Sweep-Algorithm"

\end_inset

 demonstrates the line sweep in action.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/LineSweep.eps
	width 110text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Line Sweep Algorithm
\begin_inset CommandInset label
LatexCommand label
name "fig:Line-Sweep-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Bentley-Ottmann Algorithm when used with a balanced binary search tree
 data structure such as an AVL tree or Red-Black Tree, offers 
\series bold
O(n log n)
\series default
 performance, as insertions and deletions from the tree data structure are
 
\series bold
O(log n)
\series default
 operations.
\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
An implementation of a Line Sweep Algorithm can be found in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Line-Sweep-Algorithm"

\end_inset

.
 (A full list of supporting classes can be found in the Problem Solution
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-n-Line"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

public class LineSegmentIntersection {
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Perform a line sweep on the enclosed segments.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param segments A list of segments to consider.
\end_layout

\begin_layout Plain Layout

   * @return A list of points of intersection.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public List<Point> BentleyOttmann(List<Segment> segments) {
\end_layout

\begin_layout Plain Layout

    ArrayList<Point> intersections = new ArrayList<Point>();
\end_layout

\begin_layout Plain Layout

    PriorityQueue<Event> eventQueue = new PriorityQueue<Event>();
\end_layout

\begin_layout Plain Layout

    Sweepline sweepline = new Sweepline();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Add all our endpoints to the event queue.
\end_layout

\begin_layout Plain Layout

    for (Segment segment : segments) {
\end_layout

\begin_layout Plain Layout

      eventQueue.add(new Event(segment, segment.start));
\end_layout

\begin_layout Plain Layout

      eventQueue.add(new Event(segment, segment.end));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    // Continue while we have item in queue.
\end_layout

\begin_layout Plain Layout

    while (!eventQueue.isEmpty()) {
\end_layout

\begin_layout Plain Layout

      Event event = eventQueue.poll();  // Get our next event.
\end_layout

\begin_layout Plain Layout

      if (event.segment == null) {
\end_layout

\begin_layout Plain Layout

        // Intersection.
\end_layout

\begin_layout Plain Layout

        // Add the point to the known intersections.
\end_layout

\begin_layout Plain Layout

        intersections.add(event.point);
\end_layout

\begin_layout Plain Layout

        sweepline.resort();
\end_layout

\begin_layout Plain Layout

        // Get the segment above and below the current event point.
\end_layout

\begin_layout Plain Layout

        Segment segE1 = sweepline.above(event.point);
\end_layout

\begin_layout Plain Layout

        Segment segE2 = sweepline.below(event.point);
\end_layout

\begin_layout Plain Layout

        Segment segA = sweepline.prev(segE1);
\end_layout

\begin_layout Plain Layout

        Segment segB = sweepline.next(segE2);
\end_layout

\begin_layout Plain Layout

        if (segA != null && segE2 != null) {
\end_layout

\begin_layout Plain Layout

          addIntersection(eventQueue, segA, segE2);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        if (segB != null && segE1 != null) {
\end_layout

\begin_layout Plain Layout

          addIntersection(eventQueue, segB, segE1);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      } else if (event.point == event.segment.start) {
\end_layout

\begin_layout Plain Layout

        // event is a line start.
\end_layout

\begin_layout Plain Layout

        eventTrigger = event.point.x;
\end_layout

\begin_layout Plain Layout

        sweepline.add(event.segment);
\end_layout

\begin_layout Plain Layout

        Segment segE = event.segment;
\end_layout

\begin_layout Plain Layout

        Segment segA = sweepline.prev(segE);
\end_layout

\begin_layout Plain Layout

        Segment segB = sweepline.next(segE);
\end_layout

\begin_layout Plain Layout

        if (segA != null) {
\end_layout

\begin_layout Plain Layout

          addIntersection(eventQueue, segA, segE);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        if (segB != null) {
\end_layout

\begin_layout Plain Layout

          addIntersection(eventQueue, segB, segE);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        // event is a line end
\end_layout

\begin_layout Plain Layout

        eventTrigger = event.point.x;
\end_layout

\begin_layout Plain Layout

        Segment segE = event.segment;
\end_layout

\begin_layout Plain Layout

        Segment segA = sweepline.prev(segE);
\end_layout

\begin_layout Plain Layout

        Segment segB = sweepline.next(segE);
\end_layout

\begin_layout Plain Layout

        sweepline.remove(event.segment);
\end_layout

\begin_layout Plain Layout

        if (segA != null && segB != null) {
\end_layout

\begin_layout Plain Layout

          addIntersection(eventQueue, segA, segB);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return intersections;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Add in intersection to the event queue, if an intersection exists between
 2
\end_layout

\begin_layout Plain Layout

   * segments.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param eventQueue The event queue.
\end_layout

\begin_layout Plain Layout

   * @param segA The first segment
\end_layout

\begin_layout Plain Layout

   * @param segB The second segment
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public void addIntersection(PriorityQueue<Event> eventQueue, Segment segA,
 Segment segB) {
\end_layout

\begin_layout Plain Layout

    Point segBIntersection = GetLineIntersection(segA, segB);
\end_layout

\begin_layout Plain Layout

    if (segBIntersection != null) {
\end_layout

\begin_layout Plain Layout

      Event segBEvent = new Event(null, segBIntersection);
\end_layout

\begin_layout Plain Layout

      if (!eventQueue.contains(segBEvent)) {
\end_layout

\begin_layout Plain Layout

        eventQueue.add(segBEvent);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Line Sweep Algorithm (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Line-Sweep-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem - n-Line Segment Intersection
\end_layout

\begin_layout Standard
A metal cutter cuts polygons into a sheet of metal by cutting line segments.
 Each line segment corresponds to an edge of the polygon.
 Find the co‐ordinates of the corners of the resulting polygon.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
The input consists of several test cases.
 Each line segment is listed on a line by itself as 4 positive integers:
 the 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 coordinates of one endpoint followed by the 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 coordinates of the other endpoint.
 After the last line segment in the test case, there is the character #
 on a line by itself.
 After the last test case there is another character # on a line by itself.
 You are guaranteed that, in each test case, each line segment intersects
 exactly two other line segments.
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
2 4 4 5 
\begin_inset Newline newline
\end_inset

1 6 4 2 
\begin_inset Newline newline
\end_inset

8 3 3 5 
\begin_inset Newline newline
\end_inset

6 1 7 4 
\begin_inset Newline newline
\end_inset

7 2 3 3 
\begin_inset Newline newline
\end_inset

# 
\begin_inset Newline newline
\end_inset

#
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
For each test case, output the test case number on a line, the number of
 corners, and then for each corner a single line with the x and y coordinates,
 rounded to two decimal places.
 The corner points should be sorted in increasing order of x coordinates;
 if multiple points have the same x coordinate, list those points in increasing
 order of y coordinates.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
Test Case 1: 
\begin_inset Newline newline
\end_inset

5 corners 
\begin_inset Newline newline
\end_inset

2.36 4.18 
\begin_inset Newline newline
\end_inset

3.31 2.92 
\begin_inset Newline newline
\end_inset

3.56 4.78 
\begin_inset Newline newline
\end_inset

6.38 2.15 
\begin_inset Newline newline
\end_inset

6.82 3.47
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Solution
\end_layout

\begin_layout Standard
A sample solution to the n-Line Intersection problem can be found in Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-n-Line"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.ArrayList;
\end_layout

\begin_layout Plain Layout

import java.util.Collections;
\end_layout

\begin_layout Plain Layout

import java.util.List;
\end_layout

\begin_layout Plain Layout

import java.util.ListIterator;
\end_layout

\begin_layout Plain Layout

import java.util.PriorityQueue;
\end_layout

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class LineSegmentIntersection {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    new LineSegmentIntersection().run();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main runner.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public void run() {
\end_layout

\begin_layout Plain Layout

    int testcase = 1;
\end_layout

\begin_layout Plain Layout

    ArrayList<Segment> segments;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Scanner scn = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

    String line = scn.nextLine();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Keep looping until we get a # by itself on a line.
\end_layout

\begin_layout Plain Layout

    while (line.compareTo("#") != 0) {
\end_layout

\begin_layout Plain Layout

      segments = new ArrayList<Segment>();
\end_layout

\begin_layout Plain Layout

      // Read in our segments.
\end_layout

\begin_layout Plain Layout

      while (line.compareTo("#") != 0) {
\end_layout

\begin_layout Plain Layout

        String[] values = line.split(" ");
\end_layout

\begin_layout Plain Layout

        Point start = new Point();
\end_layout

\begin_layout Plain Layout

        Point end = new Point();
\end_layout

\begin_layout Plain Layout

        start.x = Double.parseDouble(values[0]);
\end_layout

\begin_layout Plain Layout

        start.y = Double.parseDouble(values[1]);
\end_layout

\begin_layout Plain Layout

        end.x = Double.parseDouble(values[2]);
\end_layout

\begin_layout Plain Layout

        end.y = Double.parseDouble(values[3]);
\end_layout

\begin_layout Plain Layout

        segments.add(new Segment(start, end));
\end_layout

\begin_layout Plain Layout

        line = scn.nextLine();
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      // Process the segments
\end_layout

\begin_layout Plain Layout

      //List<Point> intersections = Naive(segments);
\end_layout

\begin_layout Plain Layout

      List<Point> intersections = BentleyOttmann(segments);
\end_layout

\begin_layout Plain Layout

      Collections.sort(intersections); // Sort the points.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Output the corner information.
\end_layout

\begin_layout Plain Layout

      System.out.printf("Test Case %d:
\backslash
n%d corners
\backslash
n", testcase++, intersections.size());
\end_layout

\begin_layout Plain Layout

      for (Point p : intersections) {
\end_layout

\begin_layout Plain Layout

        System.out.println(p.toString());
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      line = scn.nextLine();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Naive approach to finding intersections from n-segments.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param segments A list of segments to consider.
\end_layout

\begin_layout Plain Layout

   * @return A list of points of intersection.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public List<Point> Naive(List<Segment> segments) {
\end_layout

\begin_layout Plain Layout

    ArrayList<Point> intersections = new ArrayList<Point>();
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < segments.size(); i++) {
\end_layout

\begin_layout Plain Layout

      for (int j = 0; j < segments.size(); j++) {
\end_layout

\begin_layout Plain Layout

        Point intersection = GetLineIntersection(segments.get(i), segments.get(j))
;
\end_layout

\begin_layout Plain Layout

        if (intersection != null && !intersections.contains(intersection))
 {
\end_layout

\begin_layout Plain Layout

          intersections.add(intersection);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return intersections;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Perform a line sweep on the enclosed segments.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param segments A list of segments to consider.
\end_layout

\begin_layout Plain Layout

   * @return A list of points of intersection.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public List<Point> BentleyOttmann(List<Segment> segments) {
\end_layout

\begin_layout Plain Layout

    ArrayList<Point> intersections = new ArrayList<Point>();
\end_layout

\begin_layout Plain Layout

    PriorityQueue<Event> eventQueue = new PriorityQueue<Event>();
\end_layout

\begin_layout Plain Layout

    Sweepline sweepline = new Sweepline();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Add all our endpoints to the event queue.
\end_layout

\begin_layout Plain Layout

    for (Segment segment : segments) {
\end_layout

\begin_layout Plain Layout

      eventQueue.add(new Event(segment, segment.start));
\end_layout

\begin_layout Plain Layout

      eventQueue.add(new Event(segment, segment.end));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Continue while we have item in queue.
\end_layout

\begin_layout Plain Layout

    while (!eventQueue.isEmpty()) {
\end_layout

\begin_layout Plain Layout

      Event event = eventQueue.poll();  // Get our next event.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      if (event.segment == null) {
\end_layout

\begin_layout Plain Layout

        // Intersection.
\end_layout

\begin_layout Plain Layout

        // Add the point to the known intersections.
\end_layout

\begin_layout Plain Layout

        intersections.add(event.point);
\end_layout

\begin_layout Plain Layout

        sweepline.resort();
\end_layout

\begin_layout Plain Layout

        // Get the segment above and below the current event point.
\end_layout

\begin_layout Plain Layout

        Segment segE1 = sweepline.above(event.point);
\end_layout

\begin_layout Plain Layout

        Segment segE2 = sweepline.below(event.point);
\end_layout

\begin_layout Plain Layout

        Segment segA = sweepline.prev(segE1);
\end_layout

\begin_layout Plain Layout

        Segment segB = sweepline.next(segE2);
\end_layout

\begin_layout Plain Layout

        if (segA != null && segE2 != null) {
\end_layout

\begin_layout Plain Layout

          addIntersection(eventQueue, segA, segE2);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        if (segB != null && segE1 != null) {
\end_layout

\begin_layout Plain Layout

          addIntersection(eventQueue, segB, segE1);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      } else if (event.point == event.segment.start) {
\end_layout

\begin_layout Plain Layout

        // event is a line start.
\end_layout

\begin_layout Plain Layout

        eventTrigger = event.point.x;
\end_layout

\begin_layout Plain Layout

        sweepline.add(event.segment);
\end_layout

\begin_layout Plain Layout

        Segment segE = event.segment;
\end_layout

\begin_layout Plain Layout

        Segment segA = sweepline.prev(segE);
\end_layout

\begin_layout Plain Layout

        Segment segB = sweepline.next(segE);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if (segA != null) {
\end_layout

\begin_layout Plain Layout

          addIntersection(eventQueue, segA, segE);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        if (segB != null) {
\end_layout

\begin_layout Plain Layout

          addIntersection(eventQueue, segB, segE);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        // event is a line end
\end_layout

\begin_layout Plain Layout

        eventTrigger = event.point.x;
\end_layout

\begin_layout Plain Layout

        Segment segE = event.segment;
\end_layout

\begin_layout Plain Layout

        Segment segA = sweepline.prev(segE);
\end_layout

\begin_layout Plain Layout

        Segment segB = sweepline.next(segE);
\end_layout

\begin_layout Plain Layout

        sweepline.remove(event.segment);
\end_layout

\begin_layout Plain Layout

        if (segA != null && segB != null) {
\end_layout

\begin_layout Plain Layout

          addIntersection(eventQueue, segA, segB);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return intersections;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Add in intersection to the event queue, if an intersection exists between
 2
\end_layout

\begin_layout Plain Layout

   * segments.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param eventQueue The event queue.
\end_layout

\begin_layout Plain Layout

   * @param segA The first segment
\end_layout

\begin_layout Plain Layout

   * @param segB The second segment
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public void addIntersection(PriorityQueue<Event> eventQueue, Segment segA,
 Segment segB) {
\end_layout

\begin_layout Plain Layout

    Point segBIntersection = GetLineIntersection(segA, segB);
\end_layout

\begin_layout Plain Layout

    if (segBIntersection != null) {
\end_layout

\begin_layout Plain Layout

      Event segBEvent = new Event(null, segBIntersection);
\end_layout

\begin_layout Plain Layout

      if (!eventQueue.contains(segBEvent)) {
\end_layout

\begin_layout Plain Layout

        eventQueue.add(segBEvent);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Generic class to hold an event to be used by BentleyOttmann algorithm.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class Event implements Comparable<Event> {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Point point;
\end_layout

\begin_layout Plain Layout

    public Segment segment;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Constructor
\end_layout

\begin_layout Plain Layout

     *
\end_layout

\begin_layout Plain Layout

     * @param seg The Segment related to the event.
\end_layout

\begin_layout Plain Layout

     * @param pt The point which will trigger the event.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public Event(Segment seg, Point pt) {
\end_layout

\begin_layout Plain Layout

      point = pt;
\end_layout

\begin_layout Plain Layout

      segment = seg;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Comparable method, that compares the event point.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    @Override
\end_layout

\begin_layout Plain Layout

    public int compareTo(Event o) {
\end_layout

\begin_layout Plain Layout

      return point.compareTo(o.point);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Generic class to hold a line segment.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class Segment implements Comparable<Segment> {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Point start;
\end_layout

\begin_layout Plain Layout

    public Point end;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Main Constructor.
 Note: Points are sorted based on x location, so that
\end_layout

\begin_layout Plain Layout

     * the start point is always to the left of the end point.
\end_layout

\begin_layout Plain Layout

     *
\end_layout

\begin_layout Plain Layout

     * @param start The start point
\end_layout

\begin_layout Plain Layout

     * @param end The end point
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public Segment(Point start, Point end) {
\end_layout

\begin_layout Plain Layout

      if (end.compareTo(start) < 0) {
\end_layout

\begin_layout Plain Layout

        // swap them.
\end_layout

\begin_layout Plain Layout

        this.start = end;
\end_layout

\begin_layout Plain Layout

        this.end = start;
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      this.start = start;
\end_layout

\begin_layout Plain Layout

      this.end = end;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Comparable method, that compares the event point y location at
\end_layout

\begin_layout Plain Layout

     * intersection with the sweep line
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    @Override
\end_layout

\begin_layout Plain Layout

    public int compareTo(Segment o2) {
\end_layout

\begin_layout Plain Layout

      // Compare y positions of the segment at the x co-ordinate of the
\end_layout

\begin_layout Plain Layout

      // event trigger.
\end_layout

\begin_layout Plain Layout

      double seg1 = getY(this);
\end_layout

\begin_layout Plain Layout

      double seg2 = getY(o2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      if (seg1 > seg2) {
\end_layout

\begin_layout Plain Layout

        return 1;
\end_layout

\begin_layout Plain Layout

      } else if (seg1 < seg2) {
\end_layout

\begin_layout Plain Layout

        return -1;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      // Same location, so lets determine by slope.
\end_layout

\begin_layout Plain Layout

      seg1 = getSlope(this);
\end_layout

\begin_layout Plain Layout

      seg2 = getSlope(o2);
\end_layout

\begin_layout Plain Layout

      if (seg1 > seg2) {
\end_layout

\begin_layout Plain Layout

        return 1;
\end_layout

\begin_layout Plain Layout

      } else if (seg1 < seg2) {
\end_layout

\begin_layout Plain Layout

        return -1;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      return 0; // Same y and same slope!
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    @Override
\end_layout

\begin_layout Plain Layout

    public String toString() {
\end_layout

\begin_layout Plain Layout

      return String.format("
\backslash
"S: %.0f, %.0f, E: %.0f, %.0f
\backslash
"", start.x, start.y, end.x, end.y);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Get the y intersection of a segment to the sweep line.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param segment The segment to test against.
\end_layout

\begin_layout Plain Layout

   * @return The y location.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public double getY(Segment segment) {
\end_layout

\begin_layout Plain Layout

    // Determine slope of segment.
\end_layout

\begin_layout Plain Layout

    double slopeO2 = getSlope(segment);
\end_layout

\begin_layout Plain Layout

    // Determine y of segment
\end_layout

\begin_layout Plain Layout

    return slopeO2 * eventTrigger + (segment.start.y - slopeO2 * segment.start.x);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Get the slope of the segment.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param segment The segment whose slope is needed.
\end_layout

\begin_layout Plain Layout

   * @return The slope of the segment.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public double getSlope(Segment segment) {
\end_layout

\begin_layout Plain Layout

    return (segment.end.y - segment.start.y) / (segment.end.x - segment.start.x);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * X location of the event trigger (the location of the sweep line).
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  private static double eventTrigger;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Generic class to hold the segments that the sweep line intersects.
 This
\end_layout

\begin_layout Plain Layout

   * should use a AVL/Red-Black Tree (like the Java TreeMap class), but
 the Java
\end_layout

\begin_layout Plain Layout

   * TreeMap class won't resort the entire tree on insertion / delete operation.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class Sweepline {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    private ArrayList<Segment> sweepline;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Sweepline() {
\end_layout

\begin_layout Plain Layout

      sweepline = new ArrayList<Segment>();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Add segment to the list
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public void add(Segment segment) {
\end_layout

\begin_layout Plain Layout

      sweepline.add(segment);
\end_layout

\begin_layout Plain Layout

      Collections.sort(sweepline);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Remove a segment from the list
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public void remove(Segment segment) {
\end_layout

\begin_layout Plain Layout

      sweepline.remove(segment);
\end_layout

\begin_layout Plain Layout

      Collections.sort(sweepline);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Get the entire list of segments in the sweepline.
\end_layout

\begin_layout Plain Layout

     *
\end_layout

\begin_layout Plain Layout

     * @return
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public List<Segment> getLine() {
\end_layout

\begin_layout Plain Layout

      return sweepline;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Get the segment next to the current segment, or null if none exist.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public Segment next(Segment segment) {
\end_layout

\begin_layout Plain Layout

      if (segment == null) {
\end_layout

\begin_layout Plain Layout

        return null;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      int index = sweepline.indexOf(segment);
\end_layout

\begin_layout Plain Layout

      if (index == -1 || index == sweepline.size() - 1) {
\end_layout

\begin_layout Plain Layout

        return null;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      return sweepline.get(index + 1);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Get the segment previous to the current segment, or null is none
 exist.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public Segment prev(Segment segment) {
\end_layout

\begin_layout Plain Layout

      if (segment == null) {
\end_layout

\begin_layout Plain Layout

        return null;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      int index = sweepline.indexOf(segment);
\end_layout

\begin_layout Plain Layout

      if (index == -1 || index == 0) {
\end_layout

\begin_layout Plain Layout

        return null;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      return sweepline.get(index - 1);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Find the segment above the current point.
\end_layout

\begin_layout Plain Layout

     *
\end_layout

\begin_layout Plain Layout

     * @param point
\end_layout

\begin_layout Plain Layout

     * @return
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public Segment above(Point point) {
\end_layout

\begin_layout Plain Layout

      if (point == null) {
\end_layout

\begin_layout Plain Layout

        return null;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      for (Segment seg : sweepline) {
\end_layout

\begin_layout Plain Layout

        double y = getY(seg);
\end_layout

\begin_layout Plain Layout

        if (y == point.y) {
\end_layout

\begin_layout Plain Layout

          return seg;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      return null;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Find the segment below the current point.
\end_layout

\begin_layout Plain Layout

     *
\end_layout

\begin_layout Plain Layout

     * @param point
\end_layout

\begin_layout Plain Layout

     * @return
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public Segment below(Point point) {
\end_layout

\begin_layout Plain Layout

      if (point == null) {
\end_layout

\begin_layout Plain Layout

        return null;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      for (ListIterator iterator = sweepline.listIterator(sweepline.size());
 iterator.hasPrevious();) {
\end_layout

\begin_layout Plain Layout

        final Segment seg = (Segment) iterator.previous();
\end_layout

\begin_layout Plain Layout

        double y = getY(seg);
\end_layout

\begin_layout Plain Layout

        if (y == point.y) {
\end_layout

\begin_layout Plain Layout

          return seg;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      return null;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /**
\end_layout

\begin_layout Plain Layout

     * Resort the segments in the sweepline.
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

    public void resort() {
\end_layout

\begin_layout Plain Layout

      Collections.sort(sweepline);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Generic class to hold a point
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class Point implements Comparable<Point> {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public double x = 0.0;
\end_layout

\begin_layout Plain Layout

    public double y = 0.0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    @Override
\end_layout

\begin_layout Plain Layout

    public int compareTo(Point o) {
\end_layout

\begin_layout Plain Layout

      if (o.x == this.x) {
\end_layout

\begin_layout Plain Layout

        double temp = o.y - this.y;
\end_layout

\begin_layout Plain Layout

        if (temp < 0) {
\end_layout

\begin_layout Plain Layout

          return 1;
\end_layout

\begin_layout Plain Layout

        } else if (temp == 0) {
\end_layout

\begin_layout Plain Layout

          return 0;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        return -1;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      double temp = o.x - this.x;
\end_layout

\begin_layout Plain Layout

      if (temp < 0) {
\end_layout

\begin_layout Plain Layout

        return 1;
\end_layout

\begin_layout Plain Layout

      } else if (temp == 0) {
\end_layout

\begin_layout Plain Layout

        return 0;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      return -1;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    @Override
\end_layout

\begin_layout Plain Layout

    public String toString() {
\end_layout

\begin_layout Plain Layout

      return String.format("%.2f %.2f", x, y);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Determine if 2 lines intersect, and provide intersection point.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param Line1 The vector of the first line
\end_layout

\begin_layout Plain Layout

   * @param Line2 The vector of the second line
\end_layout

\begin_layout Plain Layout

   * @return Point if there is an intersection, otherwise null.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public Point GetLineIntersection(Segment Line1, Segment Line2) {
\end_layout

\begin_layout Plain Layout

    Point result = new Point();
\end_layout

\begin_layout Plain Layout

    // Precalculate some points;
\end_layout

\begin_layout Plain Layout

    double x4_x3 = (Line2.end.x - Line2.start.x);
\end_layout

\begin_layout Plain Layout

    double x2_x1 = (Line1.end.x - Line1.start.x);
\end_layout

\begin_layout Plain Layout

    double y4_y3 = (Line2.end.y - Line2.start.y);
\end_layout

\begin_layout Plain Layout

    double y2_y1 = (Line1.end.y - Line1.start.y);
\end_layout

\begin_layout Plain Layout

    double x1_x3 = (Line1.start.x - Line2.start.x);
\end_layout

\begin_layout Plain Layout

    double y1_y3 = (Line1.start.y - Line2.start.y);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Get the demonitator
\end_layout

\begin_layout Plain Layout

    double dem = (y4_y3 * x2_x1) - (x4_x3 * y2_y1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Determine U values.
\end_layout

\begin_layout Plain Layout

    double Ua = ((x4_x3 * y1_y3) - (y4_y3 * x1_x3)) / dem;
\end_layout

\begin_layout Plain Layout

    double Ub = ((x2_x1 * y1_y3) - (y2_y1 * x1_x3)) / dem;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Ensure our U values are in scope
\end_layout

\begin_layout Plain Layout

    if (Ua < 0 || Ua > 1 || Ub < 0 || Ub > 1) {
\end_layout

\begin_layout Plain Layout

      return null;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Calculate the intersection point.
\end_layout

\begin_layout Plain Layout

    result.x = Line1.start.x + Ua * (x2_x1);
\end_layout

\begin_layout Plain Layout

    result.y = Line1.start.y + Ua * (y2_y1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if (Double.isNaN(result.x) || Double.isNaN(result.y)) {
\end_layout

\begin_layout Plain Layout

      return null;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return result;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Solution to n-Line Segment Intersection (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-n-Line"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The solution itself does not offer a true implementation of the Bentley-Ottmann
 Algorithm, but a slightly modified version in that the datastructure that
 holds the segments that currently intersect with the sweep line is a Sorted
 List (based on the 
\begin_inset Formula $y$
\end_inset

-intersection of a segment with the current sweepline position), and not
 a Balanced Binary Search Tree.
 This does result in some performance penalty as insertions, and deletions
 are 
\series bold
O(n log n)
\series default
 and get operations are 
\series bold
O(n)
\series default
, as opposed to 
\series bold
O(log n)
\series default
 if a balanced binary search tree is used.
 The reason for this modification is that any balanced binary search tree
 implementation to be effective with this algorithm must be able to work
 with mutable key values and resort the entire tree based on the mutable
 keys
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
As far as the author is aware, implementations of balanced binary search
 trees that come with system standard libraries assume the key utilised
 is immutable.
\end_layout

\end_inset

.
 (The keys in the tree are the 
\begin_inset Formula $y$
\end_inset

-intersection position of the segment against the current 
\begin_inset Formula $x$
\end_inset

-position of the sweep line).
 This was done as a trade off against implementation complexity and performance
 complexity.
 The solution offered does however perform faster than or equal to 
\series bold
O(n
\begin_inset script superscript

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset

) 
\series default
naive approach in most circumstances despite this modification.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Bentley-Ottmann-vs-Naive"

\end_inset

 demonstrates some benchmarks as conducted on the authors system, (note:
 intersection output was enabled during these tests).
 This highlights that when there are few segments that intersecti with the
 sweepline, the modified version runs significantly faster, only matching
 the naive approach when all segments intersect the sweepline at a single
 time.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="4cm">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Line Segments
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
1,000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
10,000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
100,000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Single segments intersect with sweepline
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Naive
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
210 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2107 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
~
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Bentley-Ottmann
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
99 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
210 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2009 msec
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
3 Segments intersect with sweepline
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Naive
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
210 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2107 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
~
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Bentley-Ottmann
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
164 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
710 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
11725 msec
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
All Segments intersect with sweepline
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Naive
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
400 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
5012 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
~
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Bentley-Ottmann
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
420 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
5500 msec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
~
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Plain Layout
(
\size small
Notes: The times are only recorded if the test completes in under 5 minutes,
 the first test has no intersections, the second test has 
\begin_inset Formula $\frac{n}{2}$
\end_inset

-intersections, and the third test has 
\begin_inset Formula $2\times n$
\end_inset

-intersections, and output to console is maintained
\size default
).
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Bentley-Ottmann vs Naive
\begin_inset CommandInset label
LatexCommand label
name "tab:Bentley-Ottmann-vs-Naive"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As mentioned, the key variable with any implementation of this algorithm
 is the data structure used to hold the segments that currently intersect
 with the sweep line, as the rest of the algorithm is rather simple in structure.
 Any data strucutre must be either sortable on a mutable key value, or offer
 rapid lookups for next and prev segments based on a mutable key.
\end_layout

\begin_layout Standard
The solution to this problem is rather simple as it primarily relies on
 the implementation of the algorithm itself to produce a correct result.
 The primary case to handle is that there is no or only a single segment
 exists in the list of segments to be processed.
\end_layout

\begin_layout Standard
However there is no requirement for explicit testing of these conditions
 within the algorithm, as the algorithm naturally handles these conditions.
 
\end_layout

\begin_layout Subsubsection
Convex Hull
\end_layout

\begin_layout Standard
The convex null corresponds to the intuitive notion of a boundary of a set
 of points and can be used to approximate the shape of a complex object.
 Informally speaking, the convex hull of a set of points in the plane is
 a shape taken by a rubber band that is placed 
\begin_inset Quotes eld
\end_inset

around the points
\begin_inset Quotes erd
\end_inset

 and allowed to shrink to a state of equilibrium.
 (See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Convex-Hull"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/ConvexHull.eps
	width 75text%

\end_inset


\end_layout

\begin_layout Plain Layout

\size small
The convex hull of a set of points in the plane: (a) an example 
\begin_inset Quotes eld
\end_inset

rubber band
\begin_inset Quotes erd
\end_inset

 placed around a set of points; (b) the covex hull of the points.
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Convex Hull
\begin_inset CommandInset label
LatexCommand label
name "fig:Convex-Hull"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Indeed, computing the convex hull of a set of points is a fundamental operation
 in computational geometery.
 
\end_layout

\begin_layout Standard
Applications of the related algorithms include area calculations, the length
 of the boundary of the object (which is useful for 
\begin_inset Quotes eld
\end_inset

gift wrapping
\begin_inset Quotes erd
\end_inset

, or calculating the material required to cover an object), object culling
 in 3D/2D graphics for non-retangular shapes.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require A list $S$ of points in the plane beginning with point $a$, such
 that $a$ is one the convex hull of $S$ and the remaining points of $S$
 are sorted counterclockwise around $a$
\end_layout

\begin_layout Plain Layout


\backslash
Ensure List $S$ with only convex hull vertices remaining.
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{GrahamScan}{$S,a$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$S$.
\backslash
textsf{insertLast}($a$)} 
\backslash
Comment{Add a copy of $A$ at the end of $S$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$prev 
\backslash
gets S$.
\backslash
textsf{first}()} 
\backslash
Comment{So that $prev=a$ initially}
\end_layout

\begin_layout Plain Layout


\backslash
State {$curr 
\backslash
gets S$.
\backslash
textsf{after}($prev$)} 
\backslash
Comment {the next point is on the current vertex chain}
\end_layout

\begin_layout Plain Layout


\backslash
Repeat
\end_layout

\begin_layout Plain Layout


\backslash
State {$next 
\backslash
gets S$.
\backslash
textsf{after}($curr$)} 
\backslash
Comment {advance}
\end_layout

\begin_layout Plain Layout


\backslash
If {points (point($prev$), point($curr$), point($next$)) make a left turn}
\end_layout

\begin_layout Plain Layout


\backslash
State {$prev 
\backslash
gets curr$}
\end_layout

\begin_layout Plain Layout


\backslash
Else
\end_layout

\begin_layout Plain Layout


\backslash
State {$S$.
\backslash
textsf{remove}($curr$)} 
\backslash
Comment {point $curr$ is not in the convex hull}
\end_layout

\begin_layout Plain Layout


\backslash
State {$curr 
\backslash
gets S$.
\backslash
textsf{before}($prev$)}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
State {$curr 
\backslash
gets S$.
\backslash
textsf{after}($prev$)}
\end_layout

\begin_layout Plain Layout


\backslash
Until {$curr=S$.
\backslash
textsf{last}()}
\end_layout

\begin_layout Plain Layout


\backslash
State {$S$.
\backslash
textsf{remove}($S$.
\backslash
textsf{last}())} 
\backslash
Comment {Remove the copy of $a$}
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graham Scan Algorithm
\begin_inset CommandInset label
LatexCommand label
name "alg:Graham-Scan-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of Working
\end_layout

\begin_layout Standard
The Graham Scan Algorithm for computing the convex hull 
\begin_inset Formula $H$
\end_inset

 of a set 
\begin_inset Formula $P$
\end_inset

 of 
\begin_inset Formula $n$
\end_inset

 points in the plane consists of the following four phases:
\end_layout

\begin_layout Enumerate
We find a point 
\begin_inset Formula $a$
\end_inset

 of 
\begin_inset Formula $P$
\end_inset

 and call this the anchor point.
 Typically this will be the point with the minium 
\begin_inset Formula $y$
\end_inset

 value (and minimum 
\begin_inset Formula $x$
\end_inset

 value if a tie).
\end_layout

\begin_layout Enumerate
We sort the remaining points in 
\begin_inset Formula $P$
\end_inset

 using a radial comparison, so that all points are sorted in counterclockwise
 direction from 
\begin_inset Formula $a$
\end_inset

.
 (See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Graham-Scan--"

\end_inset

).
\end_layout

\begin_layout Enumerate
We call the Scan function, which scans through all points in 
\begin_inset Formula $S$
\end_inset

 in radial order, maintaining at each step a list of 
\begin_inset Formula $H$
\end_inset

 storing a convex chain 
\begin_inset Quotes eld
\end_inset

surrounding
\begin_inset Quotes erd
\end_inset

 the points scanned so far.
 Each time we consider a new point 
\begin_inset Formula $p$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
If 
\begin_inset Formula $p$
\end_inset

 form a left turn with the last two points in 
\begin_inset Formula $H$
\end_inset

, or if 
\begin_inset Formula $H$
\end_inset

 contains fewer than 2 points, then add 
\begin_inset Formula $p$
\end_inset

 to the end of 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Enumerate
Otherwise, remove the last point in 
\begin_inset Formula $H$
\end_inset

 and repeat the test for 
\begin_inset Formula $p$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
We stop when when we reach the anchor point 
\begin_inset Formula $a$
\end_inset

, at which point 
\begin_inset Formula $H$
\end_inset

 sotres the verives of the convex hull in counterclockwise order.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/ConvexHull2.eps
	width 40text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graham Scan - Sorting around the anchor point
\begin_inset CommandInset label
LatexCommand label
name "fig:Graham-Scan--"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Graham-Scan-1"

\end_inset

 demonstrates the third phase of the Graham Scan Algorithm.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/ConvexHull3.eps
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graham Scan - Demonstration of Scan Operation
\begin_inset CommandInset label
LatexCommand label
name "fig:Graham-Scan-1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
An implementation of the Graham Scan Algorithm can be found in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Graham-Scan-Algorithm"

\end_inset

.
 (A full list of supporting classes can be found in the Problem Solution
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Convex"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout
import java.util.ArrayList;
\end_layout

\begin_layout Plain Layout
import java.util.PriorityQueue;
\end_layout

\begin_layout Plain Layout
import java.util.Stack;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
public class ConvexHull {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
  ArrayList<Point> points;  // general list of points in the set.
\end_layout

\begin_layout Plain Layout
  PriorityQueue<Point> pointsQueue; // The points sorted by radial angle
 from the anchor.
\end_layout

\begin_layout Plain Layout
  Stack<Point> convexHull; // The resultant convex hull
\end_layout

\begin_layout Plain Layout
  Point anchor; // The anchor point.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
  /**
\end_layout

\begin_layout Plain Layout
   * Perform a scan of the points queue, building the convex hull.
\end_layout

\begin_layout Plain Layout
   */
\end_layout

\begin_layout Plain Layout
  private void grahamScan() {
\end_layout

\begin_layout Plain Layout
    convexHull.push(pointsQueue.poll()); // Add our anchor point to the convex
 hull
\end_layout

\begin_layout Plain Layout
    convexHull.push(pointsQueue.poll()); // Add our next point to the convex
 hull
\end_layout

\begin_layout Plain Layout
    while (!pointsQueue.isEmpty()) {
\end_layout

\begin_layout Plain Layout
      Point pt2 = convexHull.pop(); // Get our prev point
\end_layout

\begin_layout Plain Layout
      Point pt1 = convexHull.peek();  // Get our curr point
\end_layout

\begin_layout Plain Layout
      convexHull.push(pt2);
\end_layout

\begin_layout Plain Layout
      Point pt3 = pointsQueue.poll(); // Get out next point
\end_layout

\begin_layout Plain Layout
      if (turnsLeft(pt1, pt2, pt3)) {
\end_layout

\begin_layout Plain Layout
        convexHull.push(pt3); // Add our last point since we turned left
\end_layout

\begin_layout Plain Layout
      } else {
\end_layout

\begin_layout Plain Layout
        pointsQueue.add(pt3); // Add our just tested point back into the
 queue
\end_layout

\begin_layout Plain Layout
        convexHull.pop(); // Get rid of the last point as we turned right.
\end_layout

\begin_layout Plain Layout
      }
\end_layout

\begin_layout Plain Layout
    }
\end_layout

\begin_layout Plain Layout
  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
  /**
\end_layout

\begin_layout Plain Layout
   * Determines if there is a left turn between 2 points.
\end_layout

\begin_layout Plain Layout
   * This is done by using the difference in the cross product of points.
\end_layout

\begin_layout Plain Layout
   */
\end_layout

\begin_layout Plain Layout
  private boolean turnsLeft(Point p1, Point p2, Point p3) {
\end_layout

\begin_layout Plain Layout
    int result = (p3.x - p2.x) * (p1.y - p2.y) - (p3.y - p2.y) * (p1.x - p2.x);
\end_layout

\begin_layout Plain Layout
    return (result > 0);
\end_layout

\begin_layout Plain Layout
  }
\end_layout

\begin_layout Plain Layout
}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Graham Scan Algorithm (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Graham-Scan-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The implementation described uses a Priority Queue to hold points to be
 processed (based on radial angle from the anchor) and a Stack of points
 that form the convex hull.
 This makes it easy add and remove points as needed from both data structures,
 especially doe to the ordered nature of the priority queue.
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\family typewriter
turnsLeft()
\family default

\begin_inset Quotes erd
\end_inset

 method only needs to determine if we turned left or not, and not the angle,
 which allows us to determine this based on the cross product of the points
 in question.
\end_layout

\begin_layout Paragraph
Sample Problem - Convex Hull
\end_layout

\begin_layout Standard
Tomato plants are planted in the ground at various points in a garden.
 We wish to build a single continuous fence around the tomato plants at
 minimal cost.
 Each linear metre of fence costs $5; posts cost $1.
 You may assume that you do not need to leave any buffer zone around a tomato
 plant.
 You may also assume that the area enclosed by the fence will always be
 non‐zero.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
The first line of input will be a number on a line by itself which is the
 number of test cases to run.
 For each test case, the first line will be a number 
\begin_inset Formula $N\geq3$
\end_inset

 on a line by itself which is the number of tomato plants.
 The next 
\begin_inset Formula $N$
\end_inset

 lines consists of a pair of non-negative integers, which are the 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 coordinates of the end points of the line segments.
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
2 
\begin_inset Newline newline
\end_inset

7 
\begin_inset Newline newline
\end_inset

5 4 
\begin_inset Newline newline
\end_inset

4 2 
\begin_inset Newline newline
\end_inset

3 3 
\begin_inset Newline newline
\end_inset

6 1 
\begin_inset Newline newline
\end_inset

7 4 
\begin_inset Newline newline
\end_inset

2 1 
\begin_inset Newline newline
\end_inset

1 3 
\begin_inset Newline newline
\end_inset

4 
\begin_inset Newline newline
\end_inset

6 2 
\begin_inset Newline newline
\end_inset

6 3 
\begin_inset Newline newline
\end_inset

6 4 
\begin_inset Newline newline
\end_inset

5 1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
For each test case, output a single line containing the cost of building
 the fence, rounded to two decimal places.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
$82.61 
\begin_inset Newline newline
\end_inset

$35.88
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Solution
\end_layout

\begin_layout Standard
A sample solution to the Convex Hull problem can be found in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Convex"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout
import java.util.ArrayList;
\end_layout

\begin_layout Plain Layout
import java.util.Collections;
\end_layout

\begin_layout Plain Layout
import java.util.Comparator;
\end_layout

\begin_layout Plain Layout
import java.util.PriorityQueue;
\end_layout

\begin_layout Plain Layout
import java.util.Scanner;
\end_layout

\begin_layout Plain Layout
import java.util.Stack;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
public class ConvexHull {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
  private double costPost = 1.0;
\end_layout

\begin_layout Plain Layout
  private double costFencePerM = 5.0;
\end_layout

\begin_layout Plain Layout
  ArrayList<Point> points;  // general list of points in the set.
\end_layout

\begin_layout Plain Layout
  PriorityQueue<Point> pointsQueue; // The points sorted by radial angle
 from the anchor.
\end_layout

\begin_layout Plain Layout
  Stack<Point> convexHull; // The resultant convex hull
\end_layout

\begin_layout Plain Layout
  Point anchor; // The anchor point.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
  /**
\end_layout

\begin_layout Plain Layout
   * Main
\end_layout

\begin_layout Plain Layout
   */
\end_layout

\begin_layout Plain Layout
  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout
    new ConvexHull().run();
\end_layout

\begin_layout Plain Layout
  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
  /**
\end_layout

\begin_layout Plain Layout
   * Main runner.
\end_layout

\begin_layout Plain Layout
   */
\end_layout

\begin_layout Plain Layout
  public void run() {
\end_layout

\begin_layout Plain Layout
    Scanner scn = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout
    int numberOfTestCases = scn.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    while (numberOfTestCases-- > 0) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
      int numberOfPoint = scn.nextInt();
\end_layout

\begin_layout Plain Layout
      points = new ArrayList<Point>(numberOfPoint);
\end_layout

\begin_layout Plain Layout
      pointsQueue = new PriorityQueue<Point>(numberOfPoint);
\end_layout

\begin_layout Plain Layout
      convexHull = new Stack<Point>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
      // read in all our points.
\end_layout

\begin_layout Plain Layout
      while (numberOfPoint-- > 0) {
\end_layout

\begin_layout Plain Layout
        points.add(new Point(scn.nextInt(), scn.nextInt()));
\end_layout

\begin_layout Plain Layout
      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
      // Sort our list of points, based on y and x values;
\end_layout

\begin_layout Plain Layout
      Collections.sort(points, new PointSort());
\end_layout

\begin_layout Plain Layout
      anchor = points.get(0); // Get the start of the list, this is our anchor.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
      // Add the points to the priority queue.
\end_layout

\begin_layout Plain Layout
      for (Point point : points) {
\end_layout

\begin_layout Plain Layout
        pointsQueue.add(point); // These are sorted based on angle between
 anchor and point.
\end_layout

\begin_layout Plain Layout
      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
      // Don't bother building a convex hull with 3 or less points.
\end_layout

\begin_layout Plain Layout
      if (points.size() > 3) {
\end_layout

\begin_layout Plain Layout
        grahamScan();
\end_layout

\begin_layout Plain Layout
      } else {
\end_layout

\begin_layout Plain Layout
        // Just add the points to the convex hull...
\end_layout

\begin_layout Plain Layout
        while (!pointsQueue.isEmpty()) {
\end_layout

\begin_layout Plain Layout
          convexHull.push(pointsQueue.poll());
\end_layout

\begin_layout Plain Layout
        }
\end_layout

\begin_layout Plain Layout
      }
\end_layout

\begin_layout Plain Layout
      System.out.printf("$%.2f
\backslash
n", calculateFenceCost());
\end_layout

\begin_layout Plain Layout
    }
\end_layout

\begin_layout Plain Layout
  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
  /**
\end_layout

\begin_layout Plain Layout
   * Perform a scan of the points queue, building the convex hull.
\end_layout

\begin_layout Plain Layout
   */
\end_layout

\begin_layout Plain Layout
  private void grahamScan() {
\end_layout

\begin_layout Plain Layout
    convexHull.push(pointsQueue.poll()); // Add our anchor point to the convex
 hull
\end_layout

\begin_layout Plain Layout
    convexHull.push(pointsQueue.poll()); // Add our next point to the convex
 hull
\end_layout

\begin_layout Plain Layout
    while (!pointsQueue.isEmpty()) {
\end_layout

\begin_layout Plain Layout
      Point pt2 = convexHull.pop(); // Get our prev point
\end_layout

\begin_layout Plain Layout
      Point pt1 = convexHull.peek();  // Get our curr point
\end_layout

\begin_layout Plain Layout
      convexHull.push(pt2);
\end_layout

\begin_layout Plain Layout
      Point pt3 = pointsQueue.poll(); // Get out next point
\end_layout

\begin_layout Plain Layout
      //System.out.printf("Test Points: (%s), (%s), (%s)
\backslash
n", pt1, pt2, pt3);
\end_layout

\begin_layout Plain Layout
      if (turnsLeft(pt1, pt2, pt3)) {
\end_layout

\begin_layout Plain Layout
        convexHull.push(pt3); // Add our last point since we turned left
\end_layout

\begin_layout Plain Layout
      } else {
\end_layout

\begin_layout Plain Layout
        pointsQueue.add(pt3); // Add our just tested point back into the
 queue
\end_layout

\begin_layout Plain Layout
        convexHull.pop(); // Get rid of the last point as we turned right.
\end_layout

\begin_layout Plain Layout
      }
\end_layout

\begin_layout Plain Layout
    }
\end_layout

\begin_layout Plain Layout
  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
  /**
\end_layout

\begin_layout Plain Layout
   * Generic class to hold a point
\end_layout

\begin_layout Plain Layout
   */
\end_layout

\begin_layout Plain Layout
  public class Point implements Comparable<Point> {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    public int x = 0;
\end_layout

\begin_layout Plain Layout
    public int y = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    public Point(int x, int y) {
\end_layout

\begin_layout Plain Layout
      this.x = x;
\end_layout

\begin_layout Plain Layout
      this.y = y;
\end_layout

\begin_layout Plain Layout
    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    /**
\end_layout

\begin_layout Plain Layout
     * Comparable function based on radial angle from the anchor.
\end_layout

\begin_layout Plain Layout
     */
\end_layout

\begin_layout Plain Layout
    @Override
\end_layout

\begin_layout Plain Layout
    public int compareTo(Point point) {
\end_layout

\begin_layout Plain Layout
      // Determine the angle from the anchor to this vs point.
\end_layout

\begin_layout Plain Layout
      double anglePoint = getAngle(point);
\end_layout

\begin_layout Plain Layout
      double angleThis = getAngle(this);
\end_layout

\begin_layout Plain Layout
      if (anglePoint > angleThis) {
\end_layout

\begin_layout Plain Layout
        return -1;
\end_layout

\begin_layout Plain Layout
      } else if (anglePoint < angleThis) {
\end_layout

\begin_layout Plain Layout
        return 1;
\end_layout

\begin_layout Plain Layout
      }
\end_layout

\begin_layout Plain Layout
      // Angles are the SAME! so determine by distance from anchor.
\end_layout

\begin_layout Plain Layout
      anglePoint = vectorLength(findVector(anchor, point));
\end_layout

\begin_layout Plain Layout
      angleThis = vectorLength(findVector(anchor, this));
\end_layout

\begin_layout Plain Layout
      if (anglePoint > angleThis) {
\end_layout

\begin_layout Plain Layout
        return -1;
\end_layout

\begin_layout Plain Layout
      } else if (anglePoint < angleThis) {
\end_layout

\begin_layout Plain Layout
        return 1;
\end_layout

\begin_layout Plain Layout
      }
\end_layout

\begin_layout Plain Layout
      return 0;
\end_layout

\begin_layout Plain Layout
    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    @Override
\end_layout

\begin_layout Plain Layout
    public String toString() {
\end_layout

\begin_layout Plain Layout
      return String.format("%d %d", x, y);
\end_layout

\begin_layout Plain Layout
    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    /**
\end_layout

\begin_layout Plain Layout
     * Return the angle between the anchor (as origin) and point.
\end_layout

\begin_layout Plain Layout
     */
\end_layout

\begin_layout Plain Layout
    private double getAngle(Point point) {
\end_layout

\begin_layout Plain Layout
      return Math.atan2(point.y - anchor.y, point.x - anchor.x);
\end_layout

\begin_layout Plain Layout
    }
\end_layout

\begin_layout Plain Layout
  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
  /**
\end_layout

\begin_layout Plain Layout
   * Generic Comparator to sort a list by y, and x values.
\end_layout

\begin_layout Plain Layout
   */
\end_layout

\begin_layout Plain Layout
  private class PointSort implements Comparator<Point> {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    @Override
\end_layout

\begin_layout Plain Layout
    public int compare(Point point1, Point point2) {
\end_layout

\begin_layout Plain Layout
      if (point1.y < point2.y) {
\end_layout

\begin_layout Plain Layout
        return -1;
\end_layout

\begin_layout Plain Layout
      } else if (point1.y > point2.y) {
\end_layout

\begin_layout Plain Layout
        return 1;
\end_layout

\begin_layout Plain Layout
      } else if (point1.x < point2.x) {
\end_layout

\begin_layout Plain Layout
        return -1;
\end_layout

\begin_layout Plain Layout
      } else if (point1.x > point2.x) {
\end_layout

\begin_layout Plain Layout
        return 1;
\end_layout

\begin_layout Plain Layout
      }
\end_layout

\begin_layout Plain Layout
      return 0;
\end_layout

\begin_layout Plain Layout
    }
\end_layout

\begin_layout Plain Layout
  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
  /**
\end_layout

\begin_layout Plain Layout
   * Determine the vector from point 1 to point 2.
\end_layout

\begin_layout Plain Layout
   */
\end_layout

\begin_layout Plain Layout
  private Point findVector(Point point1, Point point2) {
\end_layout

\begin_layout Plain Layout
    return new Point(point2.x - point1.x, point2.y - point1.y);
\end_layout

\begin_layout Plain Layout
  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
  /**
\end_layout

\begin_layout Plain Layout
   * Determine the vector length from origin.
\end_layout

\begin_layout Plain Layout
   */
\end_layout

\begin_layout Plain Layout
  private double vectorLength(Point point) {
\end_layout

\begin_layout Plain Layout
    return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
\end_layout

\begin_layout Plain Layout
  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
  /**
\end_layout

\begin_layout Plain Layout
   * Determines if there is a left turn between 2 points.
 This is done by using
\end_layout

\begin_layout Plain Layout
   * the difference in the cross product of all points.
\end_layout

\begin_layout Plain Layout
   */
\end_layout

\begin_layout Plain Layout
  private boolean turnsLeft(Point p1, Point p2, Point p3) {
\end_layout

\begin_layout Plain Layout
    int result = (p3.x - p2.x) * (p1.y - p2.y) - (p3.y - p2.y) * (p1.x - p2.x);
\end_layout

\begin_layout Plain Layout
    return (result > 0);
\end_layout

\begin_layout Plain Layout
  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
  /**
\end_layout

\begin_layout Plain Layout
   * Calculate the cost of the fence around the convex hull.
\end_layout

\begin_layout Plain Layout
   *
\end_layout

\begin_layout Plain Layout
   * @return
\end_layout

\begin_layout Plain Layout
   */
\end_layout

\begin_layout Plain Layout
  double calculateFenceCost() {
\end_layout

\begin_layout Plain Layout
    double numPosts = convexHull.size();
\end_layout

\begin_layout Plain Layout
    double metersOfFence = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    Point first = convexHull.peek();
\end_layout

\begin_layout Plain Layout
    Point previous = convexHull.pop();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    // Work around the convex hull and determine the length of the fence.
\end_layout

\begin_layout Plain Layout
    while (!convexHull.isEmpty()) {
\end_layout

\begin_layout Plain Layout
      Point next = (Point) convexHull.pop();
\end_layout

\begin_layout Plain Layout
      metersOfFence += vectorLength(findVector(previous, next));
\end_layout

\begin_layout Plain Layout
      previous = next;
\end_layout

\begin_layout Plain Layout
    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    // Add in the final section of fence (from the last point back to anchor).
\end_layout

\begin_layout Plain Layout
    metersOfFence += vectorLength(findVector(previous, first)); // join
 fence back to start
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    // Return the cost.
\end_layout

\begin_layout Plain Layout
    return (costPost * numPosts) + (costFencePerM * metersOfFence);
\end_layout

\begin_layout Plain Layout
  }
\end_layout

\begin_layout Plain Layout
}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

Solution to Convex Hull Problem (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Convex"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The solution to this problem is rather simple as it primarily relies on
 the implementation of the algorithm itself to produce a correct result.
 
\end_layout

\begin_layout Standard
Some sample cases that must be considered are: 
\end_layout

\begin_layout Itemize
Less than 3 points within a series of points to determine the convex hull.
 (This is explicity tested for).
\end_layout

\begin_layout Itemize
A series of points that have the same radial angle from the anchor.
 This can be handled by ordering them based on distance from the anchor
 in such case, or simply removing the closest point to the anchor from the
 queue of points to be processed.
\end_layout

\begin_layout Standard
Other than the first point, there is no requirement for explicit testing
 of the other conditions within the algorithm, as the algorithm naturally
 handles these conditions.
 
\end_layout

\begin_layout Subsection
Dynamic Programming
\end_layout

\begin_layout Standard
Dynamic Programming is a problem solving approach and not a specific algorithm,
 and thus maybe used to solve a multitude of different problems.
\end_layout

\begin_layout Standard
The primary aspect of Dynamic Programming is the ability to break larger
 complex problems into simple problems, however to use Dynamic Programming,
 a problem should exhibit properties of overlapping subproblems and/or optimal
 substructure.
\end_layout

\begin_layout Standard
Overlapping subproblem refers to if the problem can be broken down into
 subproblems which are reused several times or a recursive algorithm for
 the problem solves the same subproblem over and over rather than always
 generating new subproblem.
 For example, the problem of computing the Fibonacci sequence exhibits overlappi
ng subproblems.
 The problem of computing the nth Fibonacci number F(n), can be broken down
 into the subproblems of computing F(n − 1) and F(n − 2), and then adding
 the two.
 The subproblem of computing F(n − 1) can itself be broken down into a subproble
m that involves computing F(n − 2).
 Therefore the computation of F(n − 2) is reused, and the Fibonacci sequence
 thus exhibits overlapping subproblems.
\end_layout

\begin_layout Standard
A problem is defined to have optimal substructure if an optimal solution
 can be constructed efficiently from optimal solutions of its subproblems.
 Optimal Substructure This property is used to determine the usefulness
 of dynamic programming and greedy algorithms in a problem.
 Typically, a greedy algorithm is used to solve a problem with optimal substruct
ure if it can be proved by induction that this is optimal at each step.
 Otherwise, providing the problem exhibits overlapping subproblems as well,
 dynamic programming is used.
 If there are no appropriate greedy algorithms and the problem fails to
 exhibit overlapping subproblems, often a lengthy but straightforward search
 of the solution space is the best alternative.
\end_layout

\begin_layout Subsubsection
Knapsack Problem
\begin_inset CommandInset label
LatexCommand label
name "sub:Knapsack-Problem"

\end_inset


\end_layout

\begin_layout Standard
The Knapsack Problem is a problem of combinational optimisation, where given
 a set of items of differing weights, attempt to find the optimal list of
 items to be included based on value within set total weight constriants.
 The problem derives its name from the challenge faced by someone who is
 constrained by a fixed-size knapsack and must fill it with the most valuable
 items.
\end_layout

\begin_layout Standard
The problem often arises in areas where resource allocation is to occur
 where there are financial or physical restraints associated with activities
 and is useful for applications such as producing the least wasteful method
 of cutting raw materials, selection of investments, as well as generating
 keys for the Merkle–Hellman knapsack cryptosystem.
\end_layout

\begin_layout Standard
The knapsack problem formally is attempting to achieve:
\end_layout

\begin_layout Standard
\noindent
\align center
maximise 
\begin_inset Formula $\sum\limits _{i\in S}b_{i}$
\end_inset

 subject to 
\begin_inset Formula $\sum\limits _{i\in S}w_{i}\leq W$
\end_inset

.
\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $S$
\end_inset

 is a set of items, each item 
\begin_inset Formula $i$
\end_inset

 has a weight 
\begin_inset Formula $w_{i}$
\end_inset

 and a benefit value 
\begin_inset Formula $b_{i}$
\end_inset

, whic is the utility value assigned to item 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require A set $S$ of $n$ items, such that item $i$ has positive benefit
 $b_{i}$, and positive integer weight $w_{i}$; positive integer maximum
 total weigth $W$.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure For $w=0,
\backslash
dots,W$, maximum benefit $B[w]$ of a subet of $S$ with total weight as most
 $w$.
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{01Knapsack}{$S,W$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$w 
\backslash
gets 0$ to $W$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$B[w] 
\backslash
gets 0$}
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
For {$k 
\backslash
gets 1$ to $n$}
\end_layout

\begin_layout Plain Layout


\backslash
For {$w 
\backslash
gets W$ down to $w_{k}$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$B[w - w_{k}] + b_{k} > B[w]$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$B[w] 
\backslash
gets B[w - w_{k}] + b_{k}$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Knapsack Algorithm
\begin_inset CommandInset label
LatexCommand label
name "alg:Knapsack-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of Working
\end_layout

\begin_layout Standard
The Knapsack Problem can be solved by utilising an exhaustive search of
 the combination space, however requires that all subset combinations be
 calculated which often leads to 
\series bold
O(2
\begin_inset script superscript

\begin_layout Plain Layout
n
\end_layout

\end_inset

)
\series default
 type performance.
\end_layout

\begin_layout Standard
However the Knapsack Algorithm shown in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Knapsack-Algorithm"

\end_inset

, simplifies the solution by breaking down the larger problem into smaller
 problems.
 This is formulated by defining the benefit for each item to be based on
 the weight of the item, and the number of items available, that is 
\begin_inset Formula $B[k,w]$
\end_inset

, and by examining the algorithm we see that 
\begin_inset Formula $B[k,w]$
\end_inset

 is built from 
\begin_inset Formula $B[k-1,w]$
\end_inset

 and possibly 
\begin_inset Formula $B[k-1,w-w_{k}]$
\end_inset

.
 Thus we have a subproblem definition that is simple (it involves just two
 parameters) and satisfies the subproblem optimisation condition.
 Moreover, it has subproblem overlap, for an optimal subset of total weight
 at most 
\begin_inset Formula $w$
\end_inset

 may be used by many future problems.
\end_layout

\begin_layout Standard
The running time of the Knapsack algorithm is dominated by the two nested
 for-loops, where the one iterates 
\begin_inset Formula $n$
\end_inset

 times and the inner one iterates at most 
\begin_inset Formula $W$
\end_inset

 times.
 After it completes we can find the optimal value by locating the value
 
\begin_inset Formula $B[w]$
\end_inset

 that is greatest among all 
\begin_inset Formula $w\leq W$
\end_inset

.
 Typically the Knapsack algorithm will be in the order of 
\series bold
O(nW)
\series default
, however it is common to refer to the algorithm as running in pseudo-polynomina
l time, for it's running time depends on the magnitude of a number of given
 input.
 
\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
An implementation of the Knapsack Algorithm can be found in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Knapsack-Algorithm-(Java)"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

public class Knapsack {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Default class to hold an item.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class Item {
\end_layout

\begin_layout Plain Layout

    public int value;
\end_layout

\begin_layout Plain Layout

    public int weight;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Determine the maximum weight to hold.
\end_layout

\begin_layout Plain Layout

   * @param items Array of Item to be considered.
\end_layout

\begin_layout Plain Layout

   * @param capacity The maximum capacity of the container.
\end_layout

\begin_layout Plain Layout

   * @return The maximum weight of items.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public int Knapsack(Item[] items, int capacity) {
\end_layout

\begin_layout Plain Layout

    int[][] solution = new int[capacity+1][items.length + 1];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int k = 1; k < items.length + 1; k++) {
\end_layout

\begin_layout Plain Layout

      for (int w = 1; w < capacity+1; w++) {
\end_layout

\begin_layout Plain Layout

        if (items[k - 1].weight > w) {
\end_layout

\begin_layout Plain Layout

          solution[w][k] = solution[w][k - 1];
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          solution[w][k] = Math.max(solution[w][k - 1],
\end_layout

\begin_layout Plain Layout

                  solution[w - items[k - 1].weight][k - 1] + items[k - 1].value);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return solution[capacity][items.length];
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Knapsack Algorithm (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Knapsack-Algorithm-(Java)"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem - Knapsack
\end_layout

\begin_layout Standard
Given weights and values for a set of items, determine the maximum value
 of items that can be carried in a vehicle with a given carrying capacity
 without exceeding that capacity.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
The input begins with a line containing a single integer, 
\begin_inset Formula $T$
\end_inset

, the number of test cases which follow, 1 ≤ 
\begin_inset Formula $T$
\end_inset

 ≤ 100.
 
\end_layout

\begin_layout Standard
For each test case, 4 lines of integers follow.
 
\end_layout

\begin_layout Itemize
The first line contains the capacity of the vehicle, 
\begin_inset Formula $W,100\leq W\leq5000$
\end_inset

.
 
\end_layout

\begin_layout Itemize
The second line contains the number of items available to choose from, 
\begin_inset Formula $N,1\leq N\leq1000$
\end_inset

.
 
\end_layout

\begin_layout Itemize
The third line contains weights for the individual items 
\begin_inset Formula $w_{1}\ldots w_{n},1\leq w_{i}\leq1000$
\end_inset

.
 
\end_layout

\begin_layout Itemize
The fourth line contains values for the individual items, 
\begin_inset Formula $v_{1}\ldots v_{n},1\leq v_{i}\leq1000$
\end_inset

.
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
2 
\begin_inset Newline newline
\end_inset

5 
\begin_inset Newline newline
\end_inset

4 
\begin_inset Newline newline
\end_inset

2 1 3 2 
\begin_inset Newline newline
\end_inset

12 10 20 15 
\begin_inset Newline newline
\end_inset

10 
\begin_inset Newline newline
\end_inset

4 
\begin_inset Newline newline
\end_inset

7 3 4 5 
\begin_inset Newline newline
\end_inset

42 12 40 25
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
For each test case output the maximum value of the load that fits in the
 capacity of the vehicle on a line by itself.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
37
\begin_inset Newline newline
\end_inset

65
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Solution
\end_layout

\begin_layout Standard
A sample solution to the Knapsack problem can be found in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Knapsack"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class KnapsackProblem {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    new KnapsackProblem().run();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  public void run() {
\end_layout

\begin_layout Plain Layout

    int vehicleCapacity;
\end_layout

\begin_layout Plain Layout

    int numItems;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Scanner in = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    int testCases = in.nextInt();
\end_layout

\begin_layout Plain Layout

    while (testCases-- > 0) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Get our vehicle capacity, and maximum number of items.
\end_layout

\begin_layout Plain Layout

      vehicleCapacity = in.nextInt();
\end_layout

\begin_layout Plain Layout

      numItems = in.nextInt();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      Item[] items = new Item[numItems];
\end_layout

\begin_layout Plain Layout

      // Read in the weights and values for our items.
\end_layout

\begin_layout Plain Layout

      for (int i = 0; i < numItems; i++) {
\end_layout

\begin_layout Plain Layout

        items[i] = new Item();
\end_layout

\begin_layout Plain Layout

        items[i].weight = in.nextInt();
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      for (int i = 0; i < numItems; i++) {
\end_layout

\begin_layout Plain Layout

        items[i].value = in.nextInt();
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // Calculate the max weight and output.
\end_layout

\begin_layout Plain Layout

      System.out.println(Knapsack(items, vehicleCapacity));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Default class to hold an item.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public class Item {
\end_layout

\begin_layout Plain Layout

    public int value;
\end_layout

\begin_layout Plain Layout

    public int weight;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Determine the maximum weight to hold.
\end_layout

\begin_layout Plain Layout

   * @param items Array of Item to be considered.
\end_layout

\begin_layout Plain Layout

   * @param capacity The maximum capacity of the container.
\end_layout

\begin_layout Plain Layout

   * @return The maximum weight of items.
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public int Knapsack(Item[] items, int capacity) {
\end_layout

\begin_layout Plain Layout

    int[][] solution = new int[capacity+1][items.length + 1];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (int k = 1; k < items.length + 1; k++) {
\end_layout

\begin_layout Plain Layout

      for (int w = 1; w < capacity+1; w++) {
\end_layout

\begin_layout Plain Layout

        if (items[k - 1].weight > w) {
\end_layout

\begin_layout Plain Layout

          solution[w][k] = solution[w][k - 1];
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          solution[w][k] = Math.max(solution[w][k - 1],
\end_layout

\begin_layout Plain Layout

                  solution[w - items[k - 1].weight][k - 1] + items[k - 1].value);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return solution[capacity][items.length];
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Solution to Knapsack Problem (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Knapsack"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The solution to this problem is rather simple as it primarily relies on
 the implementation of the algorithm itself to produce a correct result.
\end_layout

\begin_layout Standard
Some sample cases that must be considered are:
\end_layout

\begin_layout Itemize
Only a single item exists in the list of items.
\end_layout

\begin_layout Itemize
Only a single item exists in the list of items, and it's weight exceeds
 the maximum weight.
 
\end_layout

\begin_layout Itemize
All items have weights that exceed the maximum weight.
\end_layout

\begin_layout Standard
However there is no requirement for explicit testing of these conditions
 within the algorithm, as the algorithm naturally handles these conditions.
\end_layout

\begin_layout Subsubsection
Edit Distance
\end_layout

\begin_layout Standard
The Edit Distance Problem defines the edit distance for a pair of strings,
 as being the minimum number of edits needed to transform one string to
 the the other string.
 A number of allowed transactions are permitted for the transformation,
 these include:
\end_layout

\begin_layout Itemize
insertion of a character.
\end_layout

\begin_layout Itemize
deletion of a character.
\end_layout

\begin_layout Itemize
substitution of a single character.
\end_layout

\begin_layout Standard
For example, the edit distance between 
\begin_inset Quotes eld
\end_inset

hamlet
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

camelot
\begin_inset Quotes erd
\end_inset

 is 3.
\end_layout

\begin_layout Verse
hamlet 
\begin_inset Formula $\rightarrow$
\end_inset

 camlet 
\begin_inset Formula $\rightarrow$
\end_inset

 camelet 
\begin_inset Formula $\rightarrow$
\end_inset

 camelot.
\end_layout

\begin_layout Standard
Various applications for calculating the edit distance include:
\end_layout

\begin_layout Itemize
File Revision - The UNIX command 
\family typewriter
diff
\family default
 finds the difference between two text files, producing an edit script to
 convert the first file into the second.
\end_layout

\begin_layout Itemize
Spelling Correction - Algorithms related to the edit distance may be used
 in spelling correctors.
 If a text contains a word, w, that is not in the dictionary, a `close'
 word, i.e.
 one with a small edit distance to w, may be suggested as a correction.
 Transposition errors are common in written text.
 A transposition can be treated as a deletion plus an insertion, but a simple
 variation on the algorithm can treat a transposition as a single point
 mutation.
 
\end_layout

\begin_layout Itemize
Plagiarism Detection - The edit distance provides an indication of similarity
 that might be too close in some situations.
\end_layout

\begin_layout Itemize
Molecular Biology - The edit distance gives an indication of how `close'
 two strings are.
 Similar measures are used to compute a distance between DNA sequences (strings
 over {A,C,G,T}, or protein sequences (over an alphabet of 20 amino acids),
 for various purposes, e.g.:
\end_layout

\begin_deeper
\begin_layout Enumerate
to find genes or proteins that may have shared functions or properties 
\end_layout

\begin_layout Enumerate
to infer family relationships and evolutionary trees over different organisms
 
\end_layout

\end_deeper
\begin_layout Itemize
Speech Recognition - Algorithms similar to those for the edit-distance problem
 are used in some speech recognition systems: find a close match between
 a new utterance and one in a library of classified utterances.
 
\end_layout

\begin_layout Standard
Additionally there are different algorithms for Edit Distance, each refined
 to serve a particular set of requirements or the domain in which they will
 exist, with most of these focused on the length of the alphabet to be processed
 and the length of strings to be processed.
 The algorithm described is also known as the Levenshtein distance.
\end_layout

\begin_layout Standard
Mathematically, edit distance between two strings 
\begin_inset Formula $a,b$
\end_inset

 is given by 
\begin_inset Formula $E{}_{a,b}(\left|a\right|,\left|b\right|)$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
E{}_{a,b}(i,j)=\begin{cases}
0 & ,i=j=0\\
i & ,j=0\wedge i>0\\
j & ,i=0\wedge j>0\\
\min\begin{cases}
E_{a,b}(i-1,j)+1\\
E_{a,b}(i,j-1)+1\\
E_{a,b}(i-1,j-1)+[a_{i}\neq b_{j}]
\end{cases} & ,\textrm{else}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require Two strings $a$ and $b$ of non-zero length.
\end_layout

\begin_layout Plain Layout


\backslash
Ensure The edit distance from $a$ to $b$.
\end_layout

\begin_layout Plain Layout


\backslash
State
\end_layout

\begin_layout Plain Layout


\backslash
Procedure{EditDistance}{$a, b$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$len_a 
\backslash
gets a$.length}
\end_layout

\begin_layout Plain Layout


\backslash
State {$len_b 
\backslash
gets b$.length}
\end_layout

\begin_layout Plain Layout


\backslash
State {$cost 
\backslash
gets 0$}
\end_layout

\begin_layout Plain Layout


\backslash
If {$a[0] 
\backslash
neq b[0]$}
\end_layout

\begin_layout Plain Layout


\backslash
State {$cost 
\backslash
gets 1$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
If {$len_a = 0$}
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{return} $len_b$}
\end_layout

\begin_layout Plain Layout


\backslash
ElsIf {$len_b = 0$}
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{return} $len_a$}
\end_layout

\begin_layout Plain Layout


\backslash
Else
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
textbf{return} $
\backslash
min (
\backslash
textsf{EditDistance}(a[1
\backslash
dots len_a], b) + 1 ,$}
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
indent
\backslash
indent
\backslash
indent$
\backslash
textsf{EditDistance}(a, b[1
\backslash
dots len_b]) + 1 ,$}
\end_layout

\begin_layout Plain Layout


\backslash
State {
\backslash
indent
\backslash
indent
\backslash
indent$
\backslash
textsf{EditDistance}(a[1
\backslash
dots len_a], b[1
\backslash
dots len_b]) + cost)$}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Edit Distance Algorithm
\begin_inset CommandInset label
LatexCommand label
name "alg:Edit-Distance-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Description of Working
\end_layout

\begin_layout Standard
The Edit Distance Algorithm as shown in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Edit-Distance-Algorithm"

\end_inset

, creates 4 cases that define the problem.
 The first cases defines, then when both strings are 0 length, the distance
 is 0.
 The second and third cases are simply that is the length of one of the
 string arguments is 0, then the edit distance is simply the length of the
 alternate argument string.
 (These are the base cases for the algorithm).
 These 3 cases are clearly displayed in the mathematical description given
 above.
\end_layout

\begin_layout Standard
The final and fourth case breaks the main problem into a set of subproblems,
 in that this may be E(
\begin_inset Formula $a,b-1$
\end_inset

), E(
\begin_inset Formula $a-1,b$
\end_inset

) and E
\begin_inset Formula $(a-1,b-1)+[a_{i}\neq b_{j}]$
\end_inset

 respectively.
 As it's not possible to determine the correct course of action, we attempt
 all 3 subproblems and take the minimum of the three.
\end_layout

\begin_layout Standard
Since examination of the relations reveals that E(
\begin_inset Formula $a,b$
\end_inset

) depends only on E(
\begin_inset Formula $a',b'$
\end_inset

) where 
\begin_inset Formula $a'$
\end_inset

 is shorter than 
\begin_inset Formula $a$
\end_inset

, or 
\begin_inset Formula $b'$
\end_inset

 is shorter than 
\begin_inset Formula $b$
\end_inset

, or both.
 This allows the dynamic programming technique to be used, in that a two
 dimension matrix 
\begin_inset Formula $m$
\end_inset

 can be used to hold the distance values and the matrix can be computed
 row by row.
 That is row 
\begin_inset Formula $m$
\end_inset

[i,] depends only on row 
\begin_inset Formula $m[i-1,]$
\end_inset

.
 
\end_layout

\begin_layout Standard
This has multiple advantages, in that we avoid recursion of the main algorithm,
 and previously calculated values are not recaculated.
\end_layout

\begin_layout Standard
The gives the a performance complexity of 
\series bold
O(|a|.|b|)
\series default
 or 
\series bold
O(n
\begin_inset script superscript

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset

)
\series default
 if 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 have similar lengths.
\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
An implementation of the Edit Distance Algorithm can be found in Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Edit-Distance-Algorithm"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

public class EditDistance {
\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Return the the cost of the difference between the two characters.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param a The first character
\end_layout

\begin_layout Plain Layout

   * @param b The second character
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public int diff(char a, char b) {
\end_layout

\begin_layout Plain Layout

    return (a == b ? 0 : 1);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Calculate the edit distance between the two strings.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param source The source string
\end_layout

\begin_layout Plain Layout

   * @param target The resulting string.
\end_layout

\begin_layout Plain Layout

   * @return The distance between both strings
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public int editDistance(String source, String target) {
\end_layout

\begin_layout Plain Layout

    // create the matrix
\end_layout

\begin_layout Plain Layout

    int editMatrix[][] = new int[source.length() + 1][target.length() + 1];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // initialise first column
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i <= source.length(); i++) {
\end_layout

\begin_layout Plain Layout

      editMatrix[i][0] = i;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // initialise first row
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i <= target.length(); i++) {
\end_layout

\begin_layout Plain Layout

      editMatrix[0][i] = i;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Complete the matrix
\end_layout

\begin_layout Plain Layout

    for (int i = 1; i <= source.length(); i++) {
\end_layout

\begin_layout Plain Layout

      for (int j = 1; j <= target.length(); j++) {
\end_layout

\begin_layout Plain Layout

        editMatrix[i][j] = Math.min(Math.min(editMatrix[i - 1][j] + 1,
\end_layout

\begin_layout Plain Layout

             editMatrix[i][j - 1] + 1),
\end_layout

\begin_layout Plain Layout

             editMatrix[i - 1][j - 1] + diff(source.charAt(i - 1), target.charAt(j
 - 1)));
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return editMatrix[source.length()][target.length()];
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Edit Distance Algorithm (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Edit-Distance-Algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Problem - Edit Distance
\end_layout

\begin_layout Standard
Calculate the Levenshtein Distance between two stings 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

.
 The cost of deletion is 1, the cost of insertion is 1, and the cost of
 substitution is 1.
\end_layout

\begin_layout Standard
INPUT
\end_layout

\begin_layout Standard
The input begins with a line containing a single integer, 
\begin_inset Formula $T$
\end_inset

, the number of test cases which follow.
 For each test case, two lines of text, each with length between 0 and 1000
 folllow.
\end_layout

\begin_layout Standard
SAMPLE INPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
2 
\begin_inset Newline newline
\end_inset

polynomial 
\begin_inset Newline newline
\end_inset

exponential 
\begin_inset Newline newline
\end_inset

virtual 
\begin_inset Newline newline
\end_inset

ritual 
\begin_inset Newline newline
\end_inset

four 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

four
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OUTPUT
\end_layout

\begin_layout Standard
For each test case output the Levenshtein Distance between the two strings
 on a line by itself.
\end_layout

\begin_layout Standard
SAMPLE OUTPUT
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
6
\begin_inset Newline newline
\end_inset

2
\begin_inset Newline newline
\end_inset

4
\begin_inset Newline newline
\end_inset

4
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Sample Solution
\end_layout

\begin_layout Standard
A sample solution to the Edit Distance problem can be found in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Solution-to-Edit"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import java.util.Scanner;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EditDistanceProblem {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Main
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

    new EditDistanceProblem().run();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  public void run() {
\end_layout

\begin_layout Plain Layout

    Scanner sc = new Scanner(System.in);
\end_layout

\begin_layout Plain Layout

    // number of test cases
\end_layout

\begin_layout Plain Layout

    int cases = sc.nextInt();
\end_layout

\begin_layout Plain Layout

    sc.nextLine();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    while (cases-- > 0) {
\end_layout

\begin_layout Plain Layout

      // calculate the distance and output
\end_layout

\begin_layout Plain Layout

      System.out.println(editDistance(sc.nextLine(), sc.nextLine()));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Return the the cost of the difference between the two characters.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param a The first character
\end_layout

\begin_layout Plain Layout

   * @param b The second character
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public int diff(char a, char b) {
\end_layout

\begin_layout Plain Layout

    return (a == b ? 0 : 1);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Calculate the edit distance between the two strings.
\end_layout

\begin_layout Plain Layout

   *
\end_layout

\begin_layout Plain Layout

   * @param source The source string
\end_layout

\begin_layout Plain Layout

   * @param target The resulting string.
\end_layout

\begin_layout Plain Layout

   * @return The distance between both strings
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  public int editDistance(String source, String target) {
\end_layout

\begin_layout Plain Layout

    // create the matrix
\end_layout

\begin_layout Plain Layout

    int editMatrix[][] = new int[source.length() + 1][target.length() + 1];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // initialise first column
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i <= source.length(); i++) {
\end_layout

\begin_layout Plain Layout

      editMatrix[i][0] = i;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // initialise first row
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i <= target.length(); i++) {
\end_layout

\begin_layout Plain Layout

      editMatrix[0][i] = i;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Complete the matrix
\end_layout

\begin_layout Plain Layout

    for (int i = 1; i <= source.length(); i++) {
\end_layout

\begin_layout Plain Layout

      for (int j = 1; j <= target.length(); j++) {
\end_layout

\begin_layout Plain Layout

        editMatrix[i][j] = Math.min(Math.min(editMatrix[i - 1][j] + 1,
\end_layout

\begin_layout Plain Layout

             editMatrix[i][j - 1] + 1),
\end_layout

\begin_layout Plain Layout

             editMatrix[i - 1][j - 1] + diff(source.charAt(i - 1), target.charAt(j
 - 1)));
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return editMatrix[source.length()][target.length()];
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Solution to Edit Distance Problem (Java)
\begin_inset CommandInset label
LatexCommand label
name "lis:Solution-to-Edit"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The solution to this problem is rather simple as it primarily relies on
 the implementation of the algorithm itself to produce a correct result.
\end_layout

\begin_layout Standard
Some sample cases that must be considered are:
\end_layout

\begin_layout Itemize
Zero Length Strings.
\end_layout

\begin_layout Standard
However there is no requirement for explicit testing of these conditions
 within the algorithm, as the algorithm naturally handles these conditions.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Afterword
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
\start_of_appendix
References
\end_layout

\begin_layout Standard
Throughout this guide multipe sources where used to construct this guide.
 The main sources of information presented through out this guide were:
\end_layout

\begin_layout Itemize
Corney, M.
 (2011).
 INB204 Special Topic Advanced Algorithms, Semester 2, 2011, Lecture Slides
 and Notes.
\end_layout

\begin_layout Itemize
Tang, M.
 (2012).
 INB371 Data Structures and Algorithms, Semester 1, 2012, Lecture Slides
 and Notes.
\end_layout

\begin_layout Itemize
Goodrich, M., Tamassia, R., (2002) 
\shape italic
Algorithm Design: Foundations, Analysis and Internet Examples
\shape default
, Wiley Press.
 ISBN: 0-471-38365-1 (QUT Library: 005.1 622)
\end_layout

\begin_layout Standard
Additionally, the following sections were derived from the following sources:
\end_layout

\begin_layout Itemize
Section 2.5 - Competition Strategy, derived from:
\end_layout

\begin_deeper
\begin_layout Itemize
Corney, M.
 (2011).
 ACM Style Programming Competitions.pdf (part of INB204 Special Topic Advanced
 Algorithms, Semester 2, 2011, Notes).
\end_layout

\end_deeper
\begin_layout Itemize
Section 4.2 - Program Structure, derived from:
\end_layout

\begin_deeper
\begin_layout Itemize
Corney, M.
 (2010).
 Program Structure - Java.pdf (part of INB204 Special Topic Advanced Algorithms,
 Semester 2, 2011, Notes).
\end_layout

\end_deeper
\begin_layout Itemize
Section 5.3.1 - Array Performance, Timing Values and Cache layouts, derived
 from:
\end_layout

\begin_deeper
\begin_layout Itemize
Intel Corporation, (2002) 
\shape italic
Intel Pentium 4 and Intel Xeon Processor Optimisation Reference Manual
\shape default
.
 Intel Corporation, Order Number: 248966-007 (No longer available in print
 and very limited circulation, but newer editions in electronic form may
 be found at: 
\begin_inset CommandInset href
LatexCommand href
target "http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html"

\end_inset

 ).
\end_layout

\end_deeper
\begin_layout Itemize
Section 6.1.1 - Greatest Common Divisor, Description Text, derived from:
\end_layout

\begin_deeper
\begin_layout Itemize
Wikipedia (n.d.), Greatest Common Divisor, Retrieved August 16, 2012, from
 
\begin_inset CommandInset href
LatexCommand href
target "http://en.wikipedia.org/wiki/Greatest_common_divisor"

\end_inset


\end_layout

\begin_layout Itemize
Wolfram Mathworld (n.d.), Greatest Common Divisor, Retrieved August 13, 2012,
 from 
\begin_inset CommandInset href
LatexCommand href
target "http://mathworld.wolfram.com/GreatestCommonDivisor.html"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Section 6.1.2 - Sieve of Eratosthenes, Figure 6.1, derived from:
\end_layout

\begin_deeper
\begin_layout Itemize
Wikipedia (n.d.), Sieve of Eratosthenes, Retrieved August 15, 2012, from 
\begin_inset CommandInset href
LatexCommand href
target "http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Section 6.3.6.1 - A* Search, Figures, derived from:
\end_layout

\begin_deeper
\begin_layout Itemize
Lester, P.
 (2005), A* Pathfinding for Beginners, Retrived September 10, 2012, from
 
\begin_inset CommandInset href
LatexCommand href
target "http://www.policyalmanac.org/games/aStarTutorial.htm"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Section 6.5.1 - Bentley-Ottmann Algorithm, algorithm derived from:
\end_layout

\begin_deeper
\begin_layout Itemize
Sunday, D (2006), Intersection for a 2D set of Segments, Retrieved September
 20, 2012, from 
\begin_inset CommandInset href
LatexCommand href
target "http://softsurfer.com/Archive/algorithm_0108/algorithm_0108.htm"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Knapsack-Problem"

\end_inset

 - Knapsack Description, excerpts taken from:
\end_layout

\begin_deeper
\begin_layout Itemize
Wikipedia (n.d.), Knapsack problem, Retrieved September 17, 2012, from 
\begin_inset CommandInset href
LatexCommand href
target "http://en.wikipedia.org/wiki/Knapsack_problem"

\end_inset


\end_layout

\end_deeper
\end_body
\end_document
